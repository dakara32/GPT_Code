```text
# === Chat Paste Pack ===
# Repo: dakara32/GPT_Code @ main
# Files: tools/api_health_probe.py, .github/workflows/api-health.yml
# 作成日時: 2025-09-24 17:32:11 (JST)
# 使い方: 下のチャンクを順に貼ればこのチャットで全体把握できます。
# 注記: 各ファイルは個別に L1.. で行番号付与。
---

## <tools/api_health_probe.py>
```text
L1 #!/usr/bin/env python3
L2 # -*- coding: utf-8 -*-
L3 """
L4 api_health_probe.py — 選定プログラム依存API（Yahoo Finance / SEC / Finnhub）の総合ヘルスチェック
L5 Usage:
L6   export SLACK_WEBHOOK_URL=...
L7   export FINNHUB_API_KEY=...            # 任意（無ければ FinnhubはSKIPPED）
L8   export SEC_EMAIL=you@example.com      # 推奨（SEC User-Agent に使用）
L9   python tools/api_health_probe.py
L10 Env (optional):
L11   CSV_CURRENT=./current.csv
L12   CSV_CANDIDATE=./candidate.csv
L13   YF_PERIOD=1y
L14   YF_MIN_LEN=120
L15   TIMEOUT_MS_WARN=5000
L16   MAX_WORKERS=8
L17   SOFT_FAIL=0   # 1なら常にexit 0
L18 Exit codes:
L19   HEALTHY=0, DEGRADED=10, DOWN=20 （SOFT_FAIL=1なら常に0）
L20 """
L21 import os, sys, time, json, math, csv, re, concurrent.futures as cf
L22 from typing import List, Dict, Tuple
L23 import pandas as pd
L24 import numpy as np
L25 import requests
L26 import yfinance as yf
L27
L28 # ---- Settings
L29 CSV_CURRENT = os.getenv("CSV_CURRENT","./current.csv")
L30 CSV_CANDIDATE= os.getenv("CSV_CANDIDATE","./candidate.csv")
L31 YF_PERIOD   = os.getenv("YF_PERIOD","1y")
L32 YF_MIN_LEN  = int(os.getenv("YF_MIN_LEN","120"))
L33 TIMEOUT_MS_WARN = int(os.getenv("TIMEOUT_MS_WARN","5000"))
L34 SOFT_FAIL   = os.getenv("SOFT_FAIL","0") == "1"
L35 FINN_KEY    = os.getenv("FINNHUB_API_KEY")
L36 SLACK_WEBHOOK = os.getenv("SLACK_WEBHOOK_URL") or os.getenv("SLACK_WEBHOOK")
L37 SEC_EMAIL   = os.getenv("SEC_EMAIL","")
L38 MAX_WORKERS = int(os.getenv("MAX_WORKERS","8"))
L39 # “任意API”の扱い：ここに列挙されたAPIがDOWNでも全体は最大DEGRADED止まり
L40 OPTIONAL_APIS = set([x.strip().upper() for x in os.getenv("OPTIONAL_APIS","FINNHUB").split(",") if x.strip()])
L41 # 退出条件（既定: DEGRADED）。DOWNにすれば「DOWNの時だけ失敗」
L42 EXIT_ON_LEVEL = os.getenv("EXIT_ON_LEVEL","DEGRADED").upper()
L43
L44 # ---- Utils
L45 def _now_ms() -> int: return int(time.time()*1000)
L46
L47 def _post_slack(text: str):
L48     if not SLACK_WEBHOOK:
L49         print("[SLACK] webhook missing; print only\n"+text); return
L50     try:
L51         r = requests.post(SLACK_WEBHOOK, json={"text": text}, timeout=5)
L52         print(f"[SLACK] status={r.status_code}"); r.raise_for_status()
L53     except Exception as e: print(f"[SLACK] send error: {e}")
L54
L55 def _read_tickers(path: str) -> List[str]:
L56     if not os.path.exists(path): return []
L57     # 'ticker','symbol','Symbol','Ticker' の列に対応。無ければ1列CSVも許容。
L58     try:
L59         df = pd.read_csv(path)
L60         for c in ["ticker","symbol","Symbol","Ticker"]:
L61             if c in df.columns:
L62                 col = df[c].astype(str).str.strip()
L63                 return [t for t in col if t and t.lower()!="nan"]
L64         with open(path, newline="") as f:
L65             rd = csv.reader(f)
L66             vals = [row[0].strip() for row in rd if row]
L67             if vals and vals[0].lower() in ("ticker","symbol"): vals = vals[1:]
L68             return [v for v in vals if v]
L69     except Exception:
L70         return []
L71
L72 def _autodiscover_csv() -> tuple[str|None, str|None]:
L73     """
L74     リポジトリ内から current*.csv / candidate*.csv を再帰探索し、最初に見つけたものを返す。
L75     明示指定（ENV）があればそれを優先。見つからなければ None。
L76     """
L77     cur = CSV_CURRENT if os.path.exists(CSV_CURRENT) else None
L78     cand = CSV_CANDIDATE if os.path.exists(CSV_CANDIDATE) else None
L79     if cur and cand:
L80         return cur, cand
L81
L82     for root, _, files in os.walk(".", topdown=True):
L83         for fn in files:
L84             if not fn.lower().endswith(".csv"):
L85                 continue
L86             path = os.path.join(root, fn)
L87             name = fn.lower()
L88             if not cur and "current" in name:
L89                 cur = path
L90             if not cand and "candidate" in name:
L91                 cand = path
L92         if cur and cand:
L93             break
L94     return cur, cand
L95
L96 def _fmt_ms(ms: int) -> str:
L97     return f"{ms}ms" if ms < 1000 else f"{ms/1000:.2f}s"
L98
L99 # ---- Ticker 正規化（YF用）
L100 def _yf_variants(sym: str):
L101     s = (sym or "").upper()
L102     cands = []
L103     def add(x):
L104         if x and x not in cands: cands.append(x)
L105     add(s)
L106     add(s.replace(".","-"))   # BRK.B -> BRK-B, PBR.A -> PBR-A
L107     add(re.sub(r"[.\-^]", "", s))  # 記号除去
L108     return cands
L109
L110 # ================================================================
L111 # Yahoo Finance: price series ヘルス
L112 # ================================================================
L113 def yf_price_health(tickers: List[str]) -> Tuple[str, Dict]:
L114     t0 = _now_ms()
L115     data = yf.download(tickers, period=YF_PERIOD, auto_adjust=True, progress=False, threads=True)
L116     close = data["Close"] if isinstance(data, pd.DataFrame) and "Close" in data else pd.DataFrame()
L117     per_ticker_missing = {}
L118     nf=[]          # 一括でも別名再試行でも取得できず
L119     missing=[]     # 列はあるがNaN/不足
L120     ok=[]          # 問題なし
L121     alias_fixed=[] # (orig, alias) 別名で回復
L122     for t in tickers:
L123         if t not in close.columns:
L124             # 簡易ノーマライズ後、個別で5dだけ再取得して最低限の生存確認
L125             recovered = False
L126             for alias in _yf_variants(t):
L127                 try:
L128                     s = yf.Ticker(alias).history(period="5d", auto_adjust=True)["Close"]
L129                     if isinstance(s, pd.Series) and s.notna().sum() > 0:
L130                         recovered = True
L131                         alias_fixed.append((t, alias))
L132                         break
L133                 except Exception:
L134                     pass
L135             if not recovered:
L136                 nf.append(t); per_ticker_missing[t]={"dates":set(),"max_gap":0}; continue
L137             # 再取得で回復した場合はOK扱い（dates/max_gapは空のまま）
L138             ok.append(t); per_ticker_missing.setdefault(t, {"dates":set(),"max_gap":0}); continue
L139         s = close[t]; n = s.shape[0]; nn = int(s.notna().sum())
L140         isna = s.isna().values; idx = s.index
L141         total_nan = int(isna.sum()); cur=max_gap=0
L142         dates = set(str(d.date()) for d,v in zip(idx,isna) if v)
L143         for v in isna:
L144             if v: cur+=1
L145             else:
L146                 if cur>0: max_gap=max(max_gap,cur); cur=0
L147         if cur>0: max_gap=max(max_gap,cur)
L148         per_ticker_missing[t] = {"dates":dates,"max_gap":max_gap}
L149         if nn==0 or total_nan>0 or n<YF_MIN_LEN: missing.append(t)
L150         else: ok.append(t)
L151     ms = _now_ms()-t0
L152     level = "HEALTHY" if len(ok)==len(tickers) else ("DEGRADED" if len(ok)>=len(tickers)//2 else "DOWN")
L153     slow = " SLOW" if ms>=TIMEOUT_MS_WARN else ""
L154     return f"YF_PRICE:{level} ok={len(ok)}/{len(tickers)} latency={_fmt_ms(ms)}{slow}", {
L155         "level":level,"latency_ms":ms,"ok":ok,"nf":nf,"missing":missing,
L156         "per_ticker_missing":per_ticker_missing,
L157         "alias_fixed": alias_fixed
L158     }
L159
L160 # ================================================================
L161 # Yahoo Finance: fast_info.lastPrice ヘルス
L162 # ================================================================
L163 def yf_fastinfo_health(tickers: List[str]) -> Tuple[str, Dict]:
L164     t0 = _now_ms(); tk = yf.Tickers(" ".join(tickers)); bad=[]
L165     for t in tickers:
L166         try:
L167             v = tk.tickers[t].fast_info.get("lastPrice", None)
L168             if v is None or (isinstance(v,float) and math.isnan(v)): bad.append(t)
L169         except Exception: bad.append(t)
L170     ms=_now_ms()-t0
L171     level = "HEALTHY" if not bad else ("DEGRADED" if len(bad)<=len(tickers)//2 else "DOWN")
L172     slow = " SLOW" if ms>=TIMEOUT_MS_WARN else ""
L173     return f"YF_INFO:{level} bad={len(bad)}/{len(tickers)} latency={_fmt_ms(ms)}{slow}", {
L174         "level":level,"latency_ms":ms,"bad":bad
L175     }
L176
L177 # ================================================================
L178 # Yahoo Finance: financials（CFO/Capex/FCF）ヘルス
L179 # ================================================================
L180 _CF_ALIASES = {"cfo":["Operating Cash Flow","Total Cash From Operating Activities"],
L181                "capex":["Capital Expenditure","Capital Expenditures"]}
L182 def _pick_row(df: pd.DataFrame, names: List[str]) -> pd.Series|None:
L183     if df is None or df.empty: return None
L184     idx_lower = {str(i).lower():i for i in df.index}
L185     for n in names:
L186         k = n.lower()
L187         if k in idx_lower: return df.loc[idx_lower[k]]
L188     return None
L189 def _sum_last_n(s: pd.Series|None, n:int) -> float|None:
L190     if s is None or s.empty: return None
L191     v = s.dropna().astype(float); return None if v.empty else v.iloc[:n].sum()
L192 def _latest(s: pd.Series|None) -> float|None:
L193     if s is None or s.empty: return None
L194     v = s.dropna().astype(float); return v.iloc[0] if not v.empty else None
L195
L196 def yf_financials_health(tickers: List[str]) -> Tuple[str, Dict]:
L197     t0=_now_ms(); bad=[]
L198     def one(t):
L199         try:
L200             tk = yf.Ticker(t)
L201             qcf = tk.quarterly_cashflow
L202             cfo_q = _pick_row(qcf, _CF_ALIASES["cfo"])
L203             cap_q = _pick_row(qcf, _CF_ALIASES["capex"])
L204             fcf_q = _pick_row(qcf, ["Free Cash Flow","FreeCashFlow","Free cash flow"])
L205             cfo = _sum_last_n(cfo_q,4); cap = _sum_last_n(cap_q,4); fcf = _sum_last_n(fcf_q,4)
L206             if any(v is None for v in (cfo,cap,fcf)):
L207                 acf = tk.cashflow
L208                 if cfo is None: cfo=_latest(_pick_row(acf,_CF_ALIASES["cfo"]))
L209                 if cap is None: cap=_latest(_pick_row(acf,_CF_ALIASES["capex"]))
L210                 if fcf is None: fcf=_latest(_pick_row(acf,["Free Cash Flow","FreeCashFlow","Free cash flow"]))
L211             return None if all(v is not None for v in (cfo,cap,fcf)) else t
L212         except Exception: return t
L213     with cf.ThreadPoolExecutor(max_workers=MAX_WORKERS) as ex:
L214         for r in ex.map(one, tickers):
L215             if r: bad.append(r)
L216     ms=_now_ms()-t0
L217     level = "HEALTHY" if not bad else ("DEGRADED" if len(bad)<=len(tickers)//2 else "DOWN")
L218     slow = " SLOW" if ms>=TIMEOUT_MS_WARN else ""
L219     return f"YF_FIN:{level} bad={len(bad)}/{len(tickers)} latency={_fmt_ms(ms)}{slow}", {
L220         "level":level,"latency_ms":ms,"bad":bad
L221     }
L222
L223 # ================================================================
L224 # Finnhub: cash-flow（CFO/Capex）ヘルス（フォールバック）
L225 # ================================================================
L226 _FINN_CFO_KEYS   = ["netCashProvidedByOperatingActivities","netCashFromOperatingActivities","cashFlowFromOperatingActivities","operatingCashFlow"]
L227 _FINN_CAPEX_KEYS = ["capitalExpenditure","capitalExpenditures","purchaseOfPPE","investmentsInPropertyPlantAndEquipment"]
L228
L229 def _finn_get(session: requests.Session, url: str, params: dict, retries: int=3, sleep_s: float=0.5):
L230     for i in range(retries):
L231         r = session.get(url, params=params, timeout=15)
L232         if r.status_code==429:
L233             time.sleep(min(2**i*sleep_s, 4.0)); continue
L234         r.raise_for_status(); return r.json()
L235     r.raise_for_status()
L236
L237 def finnhub_health(tickers: List[str]) -> Tuple[str, Dict]:
L238     if not FINN_KEY:
L239         return "FINNHUB:SKIPPED (no key)", dict(level="SKIPPED",bad=[])
L240     t0=_now_ms(); base="https://finnhub.io/api/v1"; s=requests.Session(); bad=[]
L241     for sym in tickers:
L242         try:
L243             j=_finn_get(s,f"{base}/stock/cash-flow",{"symbol":sym,"frequency":"quarterly","limit":8,"token":FINN_KEY})
L244             arr=j.get("cashFlow") or []
L
```