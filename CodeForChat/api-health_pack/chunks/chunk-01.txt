```text
# === Chat Paste Pack ===
# Repo: dakara32/GPT_Code @ main
# Files: tools/api_health_probe.py, .github/workflows/api-health.yml
# 作成日時: 2025-09-27 11:38:42 (JST)
# 使い方: 下のチャンクを順に貼ればこのチャットで全体把握できます。
# 注記: 各ファイルは個別に L1.. で行番号付与。
---

## <tools/api_health_probe.py>
```text
L1 #!/usr/bin/env python3
L2 # -*- coding: utf-8 -*-
L3 """
L4 api_health_probe.py — 選定プログラム依存API（Yahoo Finance / SEC / Finnhub）の総合ヘルスチェック
L5
L6 機能:
L7 - CSV自動検出（current*/candidate*）
L8 - 各APIのヘルス: YF価格/YF fast_info/YF財務/SEC companyfacts/Finnhub cash-flow
L9 - 遅延測定・しきい値SLOW表示
L10 - 共通欠損日の簡易OUTAGE検知（価格系列ベース）
L11 - “変なティッカー”の常時通報（aliasで回復 / not found）
L12 - Slack通知はアイコン付き、NG銘柄は改行して全件列挙
L13 - EXIT_ON_LEVEL でCIの失敗基準を制御（既定DEGRADED、workflowでDOWNに設定推奨）
L14 - Finnhubは任意API（OPTIONAL_APIS=FINNHUB）＝単独DOWNでも全体は最大DEGRADED
L15
L16 Env:
L17   SLACK_WEBHOOK_URL=[必須] Slack Incoming Webhook
L18   FINNHUB_API_KEY   [任意]
L19   SEC_CONTACT_EMAIL [推奨]  # 無い場合はSECをSKIPPED（403回避）
L20   # 後方互換: SEC_EMAIL があれば SEC_CONTACT_EMAIL の代替として使用
L21   CSV_CURRENT=./current.csv
L22   CSV_CANDIDATE=./candidate.csv
L23   YF_PERIOD=1y
L24   YF_MIN_LEN=120
L25   TIMEOUT_MS_WARN=5000
L26   MAX_WORKERS=8
L27   OPTIONAL_APIS=FINNHUB
L28   EXIT_ON_LEVEL=DEGRADED  # workflow側で DOWN を指定すると“DOWNの時だけ”失敗
L29   SOFT_FAIL=0             # 1なら常にexit 0
L30 """
L31 import os, sys, time, json, math, csv, re, concurrent.futures as cf
L32 from typing import List, Dict, Tuple
L33 import pandas as pd
L34 import numpy as np
L35 import requests
L36 import yfinance as yf
L37
L38 # ==== Settings
L39 CSV_CURRENT = os.getenv("CSV_CURRENT","./current.csv")
L40 CSV_CANDIDATE= os.getenv("CSV_CANDIDATE","./candidate.csv")
L41 YF_PERIOD   = os.getenv("YF_PERIOD","1y")
L42 YF_MIN_LEN  = int(os.getenv("YF_MIN_LEN","120"))
L43 TIMEOUT_MS_WARN = int(os.getenv("TIMEOUT_MS_WARN","5000"))
L44 SOFT_FAIL   = os.getenv("SOFT_FAIL","0") == "1"
L45 FINN_KEY      = os.getenv("FINNHUB_API_KEY")
L46 SLACK_WEBHOOK = os.getenv("SLACK_WEBHOOK_URL") or os.getenv("SLACK_WEBHOOK")
L47 # SECメールは SEC_CONTACT_EMAIL を優先（後方互換で SEC_EMAIL）
L48 SEC_CONTACT_EMAIL = (os.getenv("SEC_CONTACT_EMAIL") or os.getenv("SEC_EMAIL") or "").strip()
L49 MAX_WORKERS = int(os.getenv("MAX_WORKERS","8"))
L50 OPTIONAL_APIS = set([x.strip().upper() for x in os.getenv("OPTIONAL_APIS","FINNHUB").split(",") if x.strip()])
L51 EXIT_ON_LEVEL = os.getenv("EXIT_ON_LEVEL","DEGRADED").upper()
L52
L53 # ==== Utils
L54 def _now_ms() -> int: return int(time.time()*1000)
L55
L56 def _post_slack(text: str):
L57     if not SLACK_WEBHOOK:
L58         print("[SLACK] webhook missing; print only\n"+text); return
L59     try:
L60         r = requests.post(SLACK_WEBHOOK, json={"text": text}, timeout=8)
L61         print(f"[SLACK] status={r.status_code}"); r.raise_for_status()
L62     except Exception as e: print(f"[SLACK] send error: {e}")
L63
L64 def _read_tickers(path: str) -> List[str]:
L65     if not os.path.exists(path): return []
L66     try:
L67         df = pd.read_csv(path)
L68         for c in ["ticker","symbol","Symbol","Ticker"]:
L69             if c in df.columns:
L70                 col = df[c].astype(str).str.strip()
L71                 return [t for t in col if t and t.lower()!="nan"]
L72         with open(path, newline="") as f:
L73             rd = csv.reader(f)
L74             vals = [row[0].strip() for row in rd if row]
L75             if vals and vals[0].lower() in ("ticker","symbol"): vals = vals[1:]
L76             return [v for v in vals if v]
L77     except Exception:
L78         return []
L79
L80 def _autodiscover_csv() -> tuple[str|None, str|None]:
L81     cur, cand = (CSV_CURRENT if os.path.exists(CSV_CURRENT) else None,
L82                  CSV_CANDIDATE if os.path.exists(CSV_CANDIDATE) else None)
L83     if cur and cand: return cur, cand
L84     for root, _, files in os.walk(".", topdown=True):
L85         for fn in files:
L86             if not fn.lower().endswith(".csv"): continue
L87             p = os.path.join(root, fn); fl = fn.lower()
L88             if "current" in fl and not cur: cur = p
L89             if "candidate" in fl and not cand: cand = p
L90         if cur and cand: break
L91     return cur, cand
L92
L93 def _fmt_ms(ms: int) -> str:
L94     return f"{ms}ms" if ms < 1000 else f"{ms/1000:.2f}s"
L95
L96 def _latency_icon(ms: int) -> str:
L97     return "🐢" if ms >= TIMEOUT_MS_WARN else "✅"
L98
L99 # ==== SEC helpers
L100 def _sec_headers():
L101     """
L102     SECは連絡先付きUser-Agent/Fromが推奨（SEC_CONTACT_EMAIL）。
L103     連絡先が空でも動かすが、403時は上位でSKIP。
L104     """
L105     mail = SEC_CONTACT_EMAIL
L106     ua   = f"api-health-probe/1 ({mail})" if mail else "api-health-probe/1"
L107     h    = {"User-Agent": ua[:200], "Accept": "application/json"}
L108     if mail:
L109         h["From"] = mail[:200]
L110     return h
L111
L112 def _sec_get(url: str, params=None, retries=3, sleep_s: float=0.5):
L113     last_err = None
L114     for i in range(retries):
L115         try:
L116             r = requests.get(url, params=params or {}, headers=_sec_headers(), timeout=15)
L117             if r.status_code == 429:
L118                 time.sleep(min(2**i*sleep_s, 4.0)); continue
L119             if r.status_code == 403:
L120                 return None
L121             r.raise_for_status()
L122             return r.json()
L123         except Exception as e:
L124             last_err = e
L125             time.sleep(min(2**i*sleep_s, 2.0))
L126     return None
L127
L128 def _sec_ticker_map() -> Dict[str,str]:
L129     j = _sec_get("https://www.sec.gov/files/company_tickers.json")
L130     if j is None: return {}
L131     out={}
L132     it=(j.values() if isinstance(j,dict) else j)
L133     for item in it:
L134         try:
L135             t=(item.get("ticker") or item.get("TICKER") or "").upper()
L136             cik=str(item.get("cik_str") or item.get("CIK") or "").zfill(10)
L137             if t and cik: out[t]=cik
L138         except Exception: continue
L139     return out
L140
L141 # ==== Yahoo Finance: ticker variants (for recovery)
L142 def _yf_variants(sym: str):
L143     s = (sym or "").upper()
L144     cands = []
L145     def add(x):
L146         if x and x not in cands: cands.append(x)
L147     add(s)
L148     add(s.replace(".","-"))            # BRK.B -> BRK-B, PBR.A -> PBR-A
L149     add(re.sub(r"[.\-^]", "", s))      # 記号除去
L150     return cands
L151
L152 # ==== YF: price series health
L153 def yf_price_health(tickers: List[str]) -> Tuple[str, Dict]:
L154     t0 = _now_ms()
L155     data = yf.download(tickers, period=YF_PERIOD, auto_adjust=True, progress=False, threads=True)
L156     close = data["Close"] if isinstance(data, pd.DataFrame) and "Close" in data else pd.DataFrame()
L157
L158     per_ticker_missing = {}
L159     nf=[]          # 一括でも別名再試行でも取得できず
L160     missing=[]     # 列はあるがNaN/不足
L161     ok=[]          # 問題なし
L162     alias_fixed=[] # (orig, alias) 別名で回復
L163
L164     for t in tickers:
L165         if t not in close.columns:
L166             recovered = False
L167             for alias in _yf_variants(t):
L168                 try:
L169                     s = yf.Ticker(alias).history(period="5d", auto_adjust=True)["Close"]
L170                     if isinstance(s, pd.Series) and s.notna().sum() > 0:
L171                         recovered = True
L172                         alias_fixed.append((t, alias))
L173                         break
L174                 except Exception:
L175                     pass
L176             if not recovered:
L177                 nf.append(t); per_ticker_missing[t]={"dates":set(),"max_gap":0}; continue
L178             ok.append(t); per_ticker_missing.setdefault(t, {"dates":set(),"max_gap":0}); continue
L179
L180         s = close[t]; n = s.shape[0]; nn = int(s.notna().sum())
L181         isna = s.isna().values; idx = s.index
L182         total_nan = int(isna.sum()); cur=max_gap=0
L183         dates = set(str(d.date()) for d,v in zip(idx,isna) if v)
L184         for v in isna:
L185             if v: cur+=1
L186             else:
L187                 if cur>0: max_gap=max(max_gap,cur); cur=0
L188         if cur>0: max_gap=max(max_gap,cur)
L189         per_ticker_missing[t] = {"dates":dates,"max_gap":max_gap}
L190         if nn==0 or total_nan>0 or n<YF_MIN_LEN: missing.append(t)
L191         else: ok.append(t)
L192
L193     ms = _now_ms()-t0
L194     total = len(tickers)
L195     bad = list(dict.fromkeys([*nf, *missing]))
L196     level = "HEALTHY" if not bad else ("DOWN" if total > 0 and len(bad) >= total else "DEGRADED")
L197     det = f"YF_PRICE:{level} bad={len(bad)}/{total} latency={_fmt_ms(ms)} {_latency_icon(ms)}"
L198     meta = {"level":level,"latency_ms":ms,"ok":ok,"nf":nf,"missing":missing,
L199             "per_ticker_missing":per_ticker_missing,"alias_fixed":alias_fixed,"bad":bad}
L200     return det, meta
L201
L202 # ==== YF: fast_info health
L203 def yf_fastinfo_health(tickers: List[str]) -> Tuple[str, Dict]:
L204     t0 = _now_ms()
L205     tk = yf.Tickers(" ".join(tickers))
L206     bad=[]
L207     for t in tickers:
L208         try:
L209             v = tk.tickers[t].fast_info.get("lastPrice", None)
L210             if v is None or (isinstance(v,float) and math.isnan(v)): bad.append(t)
L211         except Exception: bad.append(t)
L212     ms=_now_ms()-t0
L213     total=len(tickers)
L214     level = "HEALTHY" if not bad else ("DOWN" if total > 0 and len(bad) >= total else "DEGRADED")
L215     det = f"YF_INFO:{level} bad={len(bad)}/{total} latency={_fmt_ms(ms)} {_latency_icon(ms)}"
L216     return det, {"level":level,"latency_ms":ms,"bad":bad}
L217
L218 # ==== YF: financials health (CFO/Capex/FCF)
L219 _CF_ALIASES = {"cfo":["Operating Cash Flow","Total Cash From Operating Activities"],
L220                "capex":["Capital Expenditure","Capital Expenditures"]}
L221 def _pick_row(df: pd.DataFrame, names: List[str]) -> pd.Series|None:
L222     if df is None or df.empty: return None
L223     idx_lower = {str(i).lower():i for i in df.index}
L224     for n in names:
L225         k = n.lower()
L226         if k in idx_lower: return df.loc[idx_lower[k]]
L227     return None
L228 def _sum_last_n(s: pd.Series|None, n:int) -> float|None:
L229     if s is None or s.empty: return None
L230     v = s.dropna().astype(float); return None if v.empty else v.iloc[:n].sum()
L231 def _latest(s: pd.Series|None) -> float|None:
L232     if s is None or s.empty: return None
L233     v = s.dropna().astype(float); return v.iloc[0] if not v.empty else None
L234
L235 def yf_financials_health(tickers: List[str]) -> Tuple[str, Dict]:
L236     t0=_now_ms(); bad=[]
L237     def one(t):
L238         try:
L239             tk = yf.Ticker(t)
L240             qcf = tk.quarterly_cashflow
L241             cfo_q = _pick_row(qcf, _CF_ALIASES["cfo"])
L242             cap_q = _pick_row(qcf, _CF_ALIASES["capex"])
L243             fcf_q = _pick_row(qcf, ["Free Cash Flow","FreeCashFlow","Free cash flow"])
L244             cfo = _sum_last_n(cfo_q,4); cap = _sum_last_n(cap_q,4); fcf = _sum_last_n(fcf_q,4)
L245             if any(v is None for v in (cfo,cap,fcf)):
L246                 acf = tk.cashflow
L247                 if cfo is None: cfo=_latest(_pick_row(acf,_CF_ALIASES["cfo"]))
L248                 if cap is None: cap=_latest(_pick_row(acf,_CF_ALIASES["capex"]))
L249                 if fcf is None: fcf=_latest(_pick_row(acf,["Free Cash Flow","FreeCashFlow","Free cash flow"]))
L250             return None if all(v is not None for v in (cfo,cap,fcf)) else t
L251         except Exception: return t
L252     with cf.ThreadPoolExecutor(max_workers=MAX_WORKERS) as ex:
L253         for r in ex.map(one, tickers):
L254             if r: bad.append(r)
L255     ms=_now_ms()-t0
L256     total=len(tickers)
L257     level = "HEALTHY" if not bad else ("DOWN" if total > 0 and len(bad) >= total else "DEGRADED")
L258     det = f"YF_FIN:{level} bad={len(bad)}/{total} latency={_fmt_ms(ms)} {_latency_icon(ms)}"
L259     return det, {"level":level,"latency_ms":ms,"bad":bad}
L260
L261 # ==== Finnhub: cash-fl
```