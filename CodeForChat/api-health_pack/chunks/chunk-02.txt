```text
245             def pick(item,keys):
L246                 for k in keys:
L247                     if k in item and item[k] is not None: return item[k]
L248             cfo_vals=[pick(x,_FINN_CFO_KEYS) for x in arr[:4]]
L249             cap_vals=[pick(x,_FINN_CAPEX_KEYS) for x in arr[:4]]
L250             cfo_ttm = np.nansum([np.nan if v is None else float(v) for v in cfo_vals]) if any(v is not None for v in cfo_vals) else None
L251             cap_ttm = np.nansum([np.nan if v is None else float(v) for v in cap_vals]) if any(v is not None for v in cap_vals) else None
L252             if cfo_ttm is None or cap_ttm is None:
L253                 j=_finn_get(s,f"{base}/stock/cash-flow",{"symbol":sym,"frequency":"annual","limit":1,"token":FINN_KEY})
L254                 arr=j.get("cashFlow") or []
L255                 if arr:
L256                     item0=arr[0]
L257                     if cfo_ttm is None:
L258                         v=pick(item0,_FINN_CFO_KEYS); 
L259                         if v is not None: cfo_ttm=float(v)
L260                     if cap_ttm is None:
L261                         v=pick(item0,_FINN_CAPEX_KEYS); 
L262                         if v is not None: cap_ttm=float(v)
L263             if cfo_ttm is None or cap_ttm is None: bad.append(sym)
L264         except Exception: bad.append(sym)
L265     ms=_now_ms()-t0
L266     level="HEALTHY" if not bad else ("DEGRADED" if len(bad)<=len(tickers)//2 else "DOWN")
L267     slow=" SLOW" if ms>=TIMEOUT_MS_WARN else ""
L268     return f"FINNHUB:{level} bad={len(bad)}/{len(tickers)} latency={_fmt_ms(ms)}{slow}",{
L269         "level":level,"latency_ms":ms,"bad":bad
L270     }
L271
L272 # ================================================================
L273 # SEC: companyfacts（Revenue/EPS）ヘルス
L274 # ================================================================
L275 def _sec_headers():
L276     """
L277     SECは連絡先付きUser-Agent/Fromを強く推奨・一部で必須。
L278     SEC_EMAILが空なら最低限のUAにしつつ、403発生時は上位でSKIP扱いにする。
L279     """
L280     ua = (f"api-health-probe/1 (+mailto:{SEC_EMAIL})" if SEC_EMAIL else "api-health-probe/1")
L281     hdr = {
L282         "User-Agent": ua[:200],
L283         "Accept": "application/json",
L284     }
L285     if SEC_EMAIL:
L286         hdr["From"] = SEC_EMAIL[:200]
L287     return hdr
L288
L289 def _sec_get(url: str, params=None, retries=3, sleep_s: float=0.5):
L290     """
L291     403やネットワークエラーは上位でSKIP判定できるよう None を返す。
L292     """
L293     for i in range(retries):
L294         try:
L295             r = requests.get(url, params=params or {}, headers=_sec_headers(), timeout=15)
L296             if r.status_code==429:
L297                 time.sleep(min(2**i*sleep_s, 4.0)); continue
L298             if r.status_code==403:
L299                 # UA/From未設定やアクセス制限。上位でSKIP。
L300                 return None
L301             r.raise_for_status(); return r.json()
L302         except Exception:
L303             time.sleep(min(2**i*sleep_s, 2.0))
L304     return None
L305
L306 def _sec_ticker_map() -> Dict[str,str]:
L307     j = _sec_get("https://www.sec.gov/files/company_tickers.json")
L308     if j is None:
L309         return {}
L310     out={}
L311     it=(j.values() if isinstance(j,dict) else j)
L312     for item in it:
L313         try:
L314             t=(item.get("ticker") or item.get("TICKER") or "").upper()
L315             cik=str(item.get("cik_str") or item.get("CIK") or "").zfill(10)
L316             if t and cik: out[t]=cik
L317         except Exception: continue
L318     return out
L319
L320 SEC_REV_TAGS=["Revenues","RevenueFromContractWithCustomerExcludingAssessedTax","SalesRevenueNet","SalesRevenueGoodsNet","SalesRevenueServicesNet","Revenue"]
L321 SEC_EPS_TAGS=["EarningsPerShareDiluted","EarningsPerShareBasicAndDiluted","EarningsPerShare","EarningsPerShareBasic"]
L322
L323 def _normalize_for_sec(sym: str) -> List[str]:
L324     s=(sym or "").upper(); outs=[]; add=lambda x: outs.append(x) if x and x not in outs else None
L325     add(s); add(s.replace(".","-")); add(s.replace("-","")); add(s.replace(".","")); return outs
L326
L327 def _units_for_tags(facts: dict, spaces: List[str], tags: List[str]) -> list:
L328     got=[]
L329     for sp in spaces:
L330         d=(facts.get("facts") or {}).get(sp) or {}
L331         for tg in tags:
L332             arr=(d.get(tg) or {}).get("units") or {}
L333             for unit, vals in (arr.items() if isinstance(arr,dict) else []):
L334                 if isinstance(vals,list) and vals: got.append(vals)
L335     return got
L336
L337 def _series_q_and_a(arrs: list) -> Tuple[list, list]:
L338     q_pairs,a_pairs=[],[]
L339     for vals in arrs:
L340         for v in vals:
L341             try:
L342                 dt=v.get("end") or v.get("fy"); val=float(v.get("val")); form=(v.get("form") or "").upper()
L343                 if "10-Q" in form or "6-K" in form or form=="Q": q_pairs.append((dt,val))
L344                 elif "10-K" in form or "20-F" in form or form=="K": a_pairs.append((dt,val))
L345             except Exception: pass
L346     q_pairs=sorted(q_pairs,key=lambda x: str(x[0]),reverse=True)
L347     a_pairs=sorted(a_pairs,key=lambda x: str(x[0]),reverse=True)
L348     return q_pairs,a_pairs
L349
L350 def sec_health(tickers: List[str]) -> Tuple[str, Dict]:
L351     t0=_now_ms(); t2cik=_sec_ticker_map(); bad=[]
L352     # CIKマップが取れない（403/ネット断/UA未設定など）はSKIPPED
L353     if not t2cik:
L354         ms=_now_ms()-t0
L355         note="no SEC_EMAIL/403" if not SEC_EMAIL else "SEC endpoint blocked"
L356         det=f"SEC:SKIPPED ({note}) latency={_fmt_ms(ms)}"
L357         return det,{"level":"SKIPPED","latency_ms":ms,"bad":[]}
L358     for t in tickers:
L359         cands=_normalize_for_sec(t); cik=next((t2cik.get(x) for x in cands if t2cik.get(x)), None)
L360         if not cik: bad.append(t); continue
L361         try:
L362             j=_sec_get(f"https://data.sec.gov/api/xbrl/companyfacts/CIK{cik}.json")
L363             if j is None:
L364                 bad.append(t); continue
L365             rev_arr=_units_for_tags(j,["us-gaap","ifrs-full"],SEC_REV_TAGS)
L366             eps_arr=_units_for_tags(j,["us-gaap","ifrs-full"],SEC_EPS_TAGS)
L367             rev_q,rev_a=_series_q_and_a(rev_arr); eps_q,eps_a=_series_q_and_a(eps_arr)
L368             if not (rev_q or rev_a) or not (eps_q or eps_a): bad.append(t)
L369         except Exception: bad.append(t)
L370         time.sleep(0.30)  # SEC負荷配慮
L371     ms=_now_ms()-t0
L372     level="HEALTHY" if not bad else ("DEGRADED" if len(bad)<=len(tickers)//2 else "DOWN")
L373     slow=" SLOW" if ms>=TIMEOUT_MS_WARN else ""
L374     return f"SEC:{level} bad={len(bad)}/{len(tickers)} latency={_fmt_ms(ms)}{slow}",{
L375         "level":level,"latency_ms":ms,"bad":bad
L376     }
L377
L378 # ================================================================
L379 # Orchestration
L380 # ================================================================
L381 def main():
L382     cur_path, cand_path = _autodiscover_csv()
L383     if not cur_path or not cand_path:
L384         msg = f"⚠️ CSV not found. cur={cur_path} cand={cand_path} (set CSV_CURRENT/CSV_CANDIDATE or place files)"
L385         print(msg); _post_slack(msg)
L386         if SOFT_FAIL:
L387             sys.exit(0)
L388         sys.exit(78)
L389
L390     tickers=sorted(set(_read_tickers(cur_path)+_read_tickers(cand_path)))
L391     if not tickers:
L392         msg = f"⚠️ No tickers from CSV. cur={cur_path} cand={cand_path}"
L393         print(msg); _post_slack(msg)
L394         if SOFT_FAIL:
L395             sys.exit(0)
L396         sys.exit(78)
L397
L398     # YF
L399     det_price,meta_price=yf_price_health(tickers)
L400     det_info ,meta_info =yf_fastinfo_health(tickers)
L401     det_fin  ,meta_fin  =yf_financials_health(tickers)
L402
L403     # SEC
L404     det_sec  ,meta_sec  =sec_health(tickers)
L405
L406     # Finnhub（必要時のみ。YF財務NG銘柄へのフォールバック検証）
L407     need_finn=meta_fin["bad"]
L408     det_finn,meta_finn  =finnhub_health(need_finn if need_finn else tickers[:0])
L409
L410     # API別レベル
L411     levels_map = {
L412         "YF_PRICE": meta_price["level"],
L413         "YF_INFO" : meta_info ["level"],
L414         "YF_FIN"  : meta_fin  ["level"],
L415         "SEC"     : meta_sec  ["level"],
L416         "FINNHUB" : meta_finn.get("level","SKIPPED"),
L417     }
L418     pri={"DOWN":3,"DEGRADED":2,"HEALTHY":1,"SKIPPED":0}
L419     # コアAPI（OPTIONAL_APIS 以外）のワースト
L420     core_levels = [lvl for api,lvl in levels_map.items() if api not in OPTIONAL_APIS]
L421     core_worst = max(core_levels, key=lambda x: pri.get(x,0)) if core_levels else "HEALTHY"
L422     # 全体ワースト（表示用）
L423     all_worst  = max(levels_map.values(), key=lambda x: pri.get(x,0))
L424     # ただし、DOWN が OPTIONAL_APIS のみから来ている場合は全体を DEGRADED までに抑制
L425     if all_worst=="DOWN" and core_worst!="DOWN":
L426         worst = "DEGRADED"
L427     else:
L428         worst = all_worst
L429     emoji={"HEALTHY":"✅","DEGRADED":"⚠️","DOWN":"🛑"}.get(worst,"ℹ️")
L430
L431     # 共通障害（同一日だけの欠損が過半）を簡易検知（価格系列ベース）
L432     outage_note=""
L433     try:
L434         from collections import Counter
L435         missing_dates=meta_price.get("per_ticker_missing",{})
L436         date_counter=Counter(); one_day_missing=0
L437         for _,info in missing_dates.items():
L438             dates=info.get("dates",set()); max_gap=info.get("max_gap",0)
L439             if len(dates)==1 and max_gap==1:
L440                 one_day_missing+=1; date_counter.update(dates)
L441         threshold=max(1,len(tickers)//2)
L442         if one_day_missing>=threshold:
L443             (missing_day,hits),=date_counter.most_common(1)
L444             outage_note=f" | OUTAGE: common_missing_day={missing_day} hits={hits}"
L445             if worst=="HEALTHY":
L446                 worst="DEGRADED"; emoji="🟠"
L447     except Exception:
L448         pass
L449
L450     summary=f"{emoji} API_HEALTH {worst}{outage_note} (exit_on={EXIT_ON_LEVEL})\n{det_price} | {det_info} | {det_fin} | {det_sec} | {det_finn}"
L451     has_problem=("DEGRADED" in worst) or ("DOWN" in worst)
L452
L453     if has_problem:
L454         def head_problem(xs): return ", ".join(xs[:10]) + (f" …(+{len(xs)-10})" if len(xs)>10 else "")
L455         lines=[]
L456         if meta_price["missing"] or meta_price["nf"]:
L457             xs=[*meta_price["nf"],*meta_price["missing"]]; lines.append(f"YF_PRICE NG: {head_problem(xs)}")
L458         if meta_info["bad"]:  lines.append(f"YF_INFO NG: {head_problem(meta_info['bad'])}")
L459         if meta_fin["bad"]:   lines.append(f"YF_FIN NG: {head_problem(meta_fin['bad'])}")
L460         if meta_sec["bad"]:   lines.append(f"SEC NG: {head_problem(meta_sec['bad'])}")
L461         if meta_finn.get("bad"): lines.append(f"FINNHUB NG: {head_problem(meta_finn['bad'])}")
L462         text=summary + ("\n" + "\n".join(lines) if lines else "")
L463     else:
L464         text=summary
L465
L466     # “変なティッカー”は毎回通報
L467     def head_pair(pairs):
L468         xs=[f"{a}->{b}" for (a,b) in pairs[:10]]
L469         return ", ".join(xs) + (f" …(+{len(pairs)-10})" if len(pairs)>10 else "")
L470     def head(xs):
L471         return ", ".join(xs[:10]) + (f" …(+{len(xs)-10})" if len(xs)>10 else "")
L472     alias_fixed = meta_price.get("alias_fixed", [])
L473     still_missing = meta_price.get("nf", [])
L474     weird_lines = []
L475     if alias_fixed:
L476         weird_lines.append(f"Weird tickers (alias fixed): {head_pair(alias_fixed)}")
L477     if still_missing:
L478         weird_lines.append(f"Weird tickers (not found): {head(still_missing)}")
L479     if weird_lines:
L480         text = text + "\n" + "\n".join(weird_lines)
L481
L482     print(text); _post_slack(text)
L483     if SOFT_FAIL: sys.exit(0)
L484     # 退出判定：基準は“コアAPIの状態”。OPTIONALがDOWNでも coreがHEALTHY/DEGRADEDなら緩和。
L485     exit_by = core_worst if core_worst!="HEALTHY" else worst
L486     def _rank(x): return {"HEALTHY":1,"DEGRADED":2,"DOWN":3}.get(x,0)
L487     # EXIT_ON_LEVEL 未満なら成功終了
L488   
```