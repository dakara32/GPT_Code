```text
ivities","cashFlowFromOperatingActivities","operatingCashFlow"]
L261 _FINN_CAPEX_KEYS = ["capitalExpenditure","capitalExpenditures","purchaseOfPPE","investmentsInPropertyPlantAndEquipment"]
L262
L263 def _finn_get(session: requests.Session, url: str, params: dict, retries: int=3, sleep_s: float=0.5):
L264     for i in range(retries):
L265         r = session.get(url, params=params, timeout=15)
L266         if r.status_code==429:
L267             time.sleep(min(2**i*sleep_s, 4.0)); continue
L268         r.raise_for_status(); return r.json()
L269     r.raise_for_status()
L270
L271 def finnhub_health(tickers: List[str]) -> Tuple[str, Dict]:
L272     if not FINN_KEY:
L273         return "FINNHUB:SKIPPED (no key)", dict(level="SKIPPED",bad=[])
L274     t0=_now_ms(); base="https://finnhub.io/api/v1"; s=requests.Session(); bad=[]
L275     for sym in tickers:
L276         try:
L277             j=_finn_get(s,f"{base}/stock/cash-flow",{"symbol":sym,"frequency":"quarterly","limit":8,"token":FINN_KEY})
L278             arr=j.get("cashFlow") or []
L279             def pick(item,keys):
L280                 for k in keys:
L281                     if k in item and item[k] is not None: return item[k]
L282             cfo_vals=[pick(x,_FINN_CFO_KEYS) for x in arr[:4]]
L283             cap_vals=[pick(x,_FINN_CAPEX_KEYS) for x in arr[:4]]
L284             cfo_ttm = np.nansum([np.nan if v is None else float(v) for v in cfo_vals]) if any(v is not None for v in cfo_vals) else None
L285             cap_ttm = np.nansum([np.nan if v is None else float(v) for v in cap_vals]) if any(v is not None for v in cap_vals) else None
L286             if cfo_ttm is None or cap_ttm is None:
L287                 j=_finn_get(s,f"{base}/stock/cash-flow",{"symbol":sym,"frequency":"annual","limit":1,"token":FINN_KEY})
L288                 arr=j.get("cashFlow") or []
L289                 if arr:
L290                     item0=arr[0]
L291                     if cfo_ttm is None:
L292                         v=pick(item0,_FINN_CFO_KEYS); 
L293                         if v is not None: cfo_ttm=float(v)
L294                     if cap_ttm is None:
L295                         v=pick(item0,_FINN_CAPEX_KEYS); 
L296                         if v is not None: cap_ttm=float(v)
L297             if cfo_ttm is None or cap_ttm is None: bad.append(sym)
L298         except Exception: bad.append(sym)
L299     ms=_now_ms()-t0
L300     level="HEALTHY" if not bad else ("DEGRADED" if len(bad)<=len(tickers)//2 else "DOWN")
L301     slow=" SLOW" if ms>=TIMEOUT_MS_WARN else ""
L302     return f"FINNHUB:{level} bad={len(bad)}/{len(tickers)} latency={_fmt_ms(ms)}{slow}",{
L303         "level":level,"latency_ms":ms,"bad":bad
L304     }
L305
L306 # ==== SEC: companyfacts (Revenue/EPS) health
L307 SEC_REV_TAGS=["Revenues","RevenueFromContractWithCustomerExcludingAssessedTax","SalesRevenueNet","SalesRevenueGoodsNet","SalesRevenueServicesNet","Revenue"]
L308 SEC_EPS_TAGS=["EarningsPerShareDiluted","EarningsPerShareBasicAndDiluted","EarningsPerShare","EarningsPerShareBasic"]
L309
L310 def _units_for_tags(facts: dict, spaces: List[str], tags: List[str]) -> list:
L311     got=[]
L312     for sp in spaces:
L313         d=(facts.get("facts") or {}).get(sp) or {}
L314         for tg in tags:
L315             arr=(d.get(tg) or {}).get("units") or {}
L316             for unit, vals in (arr.items() if isinstance(arr,dict) else []):
L317                 if isinstance(vals,list) and vals: got.append(vals)
L318     return got
L319
L320 def _series_q_and_a(arrs: list) -> Tuple[list, list]:
L321     q_pairs,a_pairs=[],[]
L322     for vals in arrs:
L323         for v in vals:
L324             try:
L325                 dt=v.get("end") or v.get("fy"); val=float(v.get("val")); form=(v.get("form") or "").upper()
L326                 if "10-Q" in form or "6-K" in form or form=="Q": q_pairs.append((dt,val))
L327                 elif "10-K" in form or "20-F" in form or form=="K": a_pairs.append((dt,val))
L328             except Exception: pass
L329     q_pairs=sorted(q_pairs,key=lambda x: str(x[0]),reverse=True)
L330     a_pairs=sorted(a_pairs,key=lambda x: str(x[0]),reverse=True)
L331     return q_pairs,a_pairs
L332
L333 def sec_health(tickers: List[str]) -> Tuple[str, Dict]:
L334     t0=_now_ms(); t2cik=_sec_ticker_map(); bad=[]
L335     if not t2cik:
L336         ms=_now_ms()-t0
L337         det = f"SEC:SKIPPED (no SEC_CONTACT_EMAIL/403) latency={_fmt_ms(ms)}"
L338         return det, {"level":"SKIPPED","latency_ms":ms,"bad":[]}
L339     for t in tickers:
L340         # '.'„Å®'-'„ÅÆ„ÇÜ„Çâ„Åé„ÇíË®±ÂÆπ„Åó„ÅüÁ∞°Êòì„Éû„ÉÉ„ÉÅ
L341         cands = [(t or "").upper(), (t or "").upper().replace(".","-"), (t or "").upper().replace("-",""), (t or "").upper().replace(".","")]
L342         cik = next((t2cik.get(x) for x in cands if t2cik.get(x)), None)
L343         if not cik:
L344             bad.append(t); continue
L345         try:
L346             j=_sec_get(f"https://data.sec.gov/api/xbrl/companyfacts/CIK{cik}.json")
L347             if j is None: bad.append(t); continue
L348             rev_arr=_units_for_tags(j,["us-gaap","ifrs-full"],SEC_REV_TAGS)
L349             eps_arr=_units_for_tags(j,["us-gaap","ifrs-full"],SEC_EPS_TAGS)
L350             rev_q,rev_a=_series_q_and_a(rev_arr); eps_q,eps_a=_series_q_and_a(eps_arr)
L351             if not (rev_q or rev_a) or not (eps_q or eps_a): bad.append(t)
L352         except Exception: bad.append(t)
L353         time.sleep(0.30)
L354     ms=_now_ms()-t0
L355     level="HEALTHY" if not bad else ("DEGRADED" if len(bad)<=len(tickers)//2 else "DOWN")
L356     slow=" SLOW" if ms>=TIMEOUT_MS_WARN else ""
L357     return f"SEC:{level} bad={len(bad)}/{len(tickers)} latency={_fmt_ms(ms)}{slow}",{
L358         "level":level,"latency_ms":ms,"bad":bad
L359     }
L360
L361 # ==== Orchestration
L362 def main():
L363     cur_path, cand_path = _autodiscover_csv()
L364     if not cur_path or not cand_path:
L365         msg = f"‚ö†Ô∏è CSV not found. cur={cur_path} cand={cand_path} (set CSV_CURRENT/CSV_CANDIDATE or place files)"
L366         print(msg); _post_slack(msg)
L367         if SOFT_FAIL: sys.exit(0)
L368         sys.exit(78)
L369
L370     tickers=sorted(set(_read_tickers(cur_path)+_read_tickers(cand_path)))
L371     if not tickers:
L372         msg = f"‚ö†Ô∏è No tickers from CSV. cur={cur_path} cand={cand_path}"
L373         print(msg); _post_slack(msg)
L374         if SOFT_FAIL: sys.exit(0)
L375         sys.exit(78)
L376
L377     det_price,meta_price=yf_price_health(tickers)
L378     det_info ,meta_info =yf_fastinfo_health(tickers)
L379     det_fin  ,meta_fin  =yf_financials_health(tickers)
L380     det_sec  ,meta_sec  =sec_health(tickers)
L381
L382     need_finn=meta_fin["bad"]
L383     det_finn,meta_finn  =finnhub_health(need_finn if need_finn else tickers[:0])
L384
L385     levels_map = {
L386         "YF_PRICE": meta_price["level"],
L387         "YF_INFO" : meta_info ["level"],
L388         "YF_FIN"  : meta_fin  ["level"],
L389         "SEC"     : meta_sec  ["level"],
L390         "FINNHUB" : meta_finn.get("level","SKIPPED"),
L391     }
L392     pri={"DOWN":3,"DEGRADED":2,"HEALTHY":1,"SKIPPED":0}
L393     core_levels = [lvl for api,lvl in levels_map.items() if api not in OPTIONAL_APIS]
L394     core_worst = max(core_levels, key=lambda x: pri.get(x,0)) if core_levels else "HEALTHY"
L395     all_worst  = max(levels_map.values(), key=lambda x: pri.get(x,0))
L396     worst = "DEGRADED" if (all_worst=="DOWN" and core_worst!="DOWN") else all_worst
L397     emoji={"HEALTHY":"‚úÖ","DEGRADED":"‚ö†Ô∏è","DOWN":"üõë"}.get(worst,"‚ÑπÔ∏è")
L398
L399     # ‰æ°Ê†ºÁ≥ªÂàó„ÅÆÂÖ±ÈÄöÈöúÂÆ≥ÔºàÂêå‰∏ÄÊó•„Å†„Åë„ÅÆÊ¨†Êêç„ÅåÈÅéÂçäÔºâÁ∞°ÊòìÊ§úÁü•
L400     outage_note=""
L401     try:
L402         from collections import Counter
L403         missing_dates=meta_price.get("per_ticker_missing",{})
L404         date_counter=Counter(); one_day_missing=0
L405         for _,info in missing_dates.items():
L406             dates=info.get("dates",set()); max_gap=info.get("max_gap",0)
L407             if len(dates)==1 and max_gap==1:
L408                 one_day_missing+=1; date_counter.update(dates)
L409         threshold=max(1,len(tickers)//2)
L410         if one_day_missing>=threshold:
L411             (missing_day,hits),=date_counter.most_common(1)
L412             outage_note=f" | OUTAGE: common_missing_day={missing_day} hits={hits}"
L413             if worst=="HEALTHY": worst="DEGRADED"; emoji="üü†"
L414     except Exception:
L415         pass
L416
L417     # ÂêÑAPI„ÅÆ„Ç¢„Ç§„Ç≥„É≥‰ªò‰∏é
L418     def icon_for(level: str) -> str:
L419         return {"HEALTHY":"‚úÖ","DEGRADED":"‚ö†Ô∏è","DOWN":"üõë","SKIPPED":"‚è≠Ô∏è"}.get(level, "‚ÑπÔ∏è")
L420     det_price = f"{icon_for(levels_map['YF_PRICE'])} {det_price}"
L421     det_info  = f"{icon_for(levels_map['YF_INFO' ])} {det_info}"
L422     det_fin   = f"{icon_for(levels_map['YF_FIN'  ])} {det_fin}"
L423     det_sec   = f"{icon_for(levels_map['SEC'     ])} {det_sec}"
L424     det_finn  = f"{icon_for(levels_map['FINNHUB' ])} {det_finn}"
L425
L426     summary=f"{emoji} API_HEALTH {worst}{outage_note} (exit_on={EXIT_ON_LEVEL})\n{det_price} | {det_info} | {det_fin} | {det_sec} | {det_finn}"
L427     has_problem=("DEGRADED" in worst) or ("DOWN" in worst)
L428
L429     if has_problem:
L430         def all_list(xs): return ", ".join(xs)
L431         lines=[]
L432         if meta_price["missing"] or meta_price["nf"]:
L433             xs=[*meta_price["nf"],*meta_price["missing"]]
L434             lines.append("YF_PRICE NG:\n" + all_list(xs))
L435         if meta_info["bad"]:
L436             lines.append("YF_INFO NG:\n" + all_list(meta_info["bad"]))
L437         if meta_fin["bad"]:
L438             lines.append("YF_FIN NG:\n" + all_list(meta_fin["bad"]))
L439         if meta_sec["bad"]:
L440             lines.append("SEC NG:\n" + all_list(meta_sec["bad"]))
L441         if meta_finn.get("bad"):
L442             lines.append("FINNHUB NG:\n" + all_list(meta_finn["bad"]))
L443         text=summary + ("\n" + "\n".join(lines) if lines else "")
L444     else:
L445         text=summary
L446
L447     # Â§â„Å™„ÉÜ„Ç£„ÉÉ„Ç´„Éº„ÅØÊØéÂõûÂÖ®‰ª∂ÈÄöÂ†±
L448     def pair_all(pairs): return ", ".join(f"{a}->{b}" for (a,b) in pairs)
L449     def list_all(xs): return ", ".join(xs)
L450     alias_fixed = meta_price.get("alias_fixed", [])
L451     still_missing = meta_price.get("nf", [])
L452     weird_lines = []
L453     if alias_fixed:
L454         weird_lines.append("Weird tickers (alias fixed):\n" + pair_all(alias_fixed))
L455     if still_missing:
L456         weird_lines.append("Weird tickers (not found):\n" + list_all(still_missing))
L457     if weird_lines:
L458         text = text + "\n" + "\n".join(weird_lines)
L459
L460     print(text); _post_slack(text)
L461     if SOFT_FAIL: sys.exit(0)
L462     # ÈÄÄÂá∫Âà§ÂÆöÔºö„Ç≥„Ç¢API„ÇíÂÑ™ÂÖà„ÄÇOPTIONAL„ÅåDOWN„Åß„ÇÇ core„ÅåHEALTHY/DEGRADED„Å™„ÇâÁ∑©Âíå„ÄÇ
L463     exit_by = core_worst if core_worst!="HEALTHY" else worst
L464     def _rank(x): return {"HEALTHY":1,"DEGRADED":2,"DOWN":3}.get(x,0)
L465     if _rank(exit_by) < _rank(EXIT_ON_LEVEL): sys.exit(0)
L466     sys.exit(20 if exit_by=="DOWN" else 10)
L467
L468 if __name__=="__main__":
L469     main()
```

## <.github/workflows/api-health.yml>
```text
L1 name: api-health-probe
L2 on:
L3   push:
L4     branches: [ main ]
L5
L6 jobs:
L7   probe:
L8     runs-on: ubuntu-latest
L9     timeout-minutes: 10
L10     steps:
L11       - uses: actions/checkout@v4
L12       - name: Show repo tree (CSV check)
L13         run: |
L14           echo "== ls -R (top 300 lines) =="
L15           ls -R | head -n 300 || true
L16           echo "== probable csv files =="
L17           (git ls-files | grep -Ei '(current|candidate).*\.csv$' || true)
L18       - uses: actions/setup-python@v5
L19         with:
L20           python-version: "3.11"
L21       - name: Install deps
L22         run: |
L23           python -m pip install --upgrade pip
L24           pip install yfinance pandas numpy requests
L25       - name: Run API health probe
L26         env:
L27           SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
L28           FINNHUB_API_KEY:   ${{ secrets.FINNHUB_API_KE
```