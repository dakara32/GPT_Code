```text
t details:
L287         print("‚ö†Ô∏è audit[G-CD details]: ÊúâÂäπ„Å™ÈäòÊüÑ„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì")
L288         print("üìù audit[G-CD summary]: avg_low/peak60=1.0000  drawdown=0.00%  => NORMAL")
L289         return "NORMAL", 0.0
L290
L291     details.sort(key=lambda x: x[4], reverse=True)
L292     today = pd.Timestamp.today(tz="America/New_York").date().isoformat()
L293     print(f"üìù audit[G-CD details] {today}  G={len(g_syms)}")
L294     print("  SYMBOL        Peak60(H)     Low(T)     ratio    DD%")
L295     for sym, peak, low, ratio, ddpct in details:
L296         print(f"  {sym:<8}  {peak:>12.6g}  {low:>10.6g}   {ratio:>6.3f}  {ddpct:>6.2f}")
L297
L298     avg_ratio = float(np.mean([r for _, _, _, r, _ in details]))
L299     gcd_pct = max(0.0, (1.0 - avg_ratio) * 100.0)
L300     mode = "EMERG" if gcd_pct >= CD_EMERG * 100 else "CAUTION" if gcd_pct >= CD_CAUTION * 100 else "NORMAL"
L301     print(
L302         f"üìù audit[G-CD summary]: avg_low/peak60={avg_ratio:.4f}  drawdown={gcd_pct:.2f}%  => {mode}"
L303     )
L304     return mode, gcd_pct
L305 # Debug flag
L306 debug_mode = False  # set to True for detailed output
L307
L308 # --- Finnhub settings & helper ---
L309 FINNHUB_API_KEY = os.environ.get("FINNHUB_API_KEY")
L310 if not FINNHUB_API_KEY:
L311     raise ValueError("FINNHUB_API_KEY not set (Áí∞Â¢ÉÂ§âÊï∞„ÅåÊú™Ë®≠ÂÆö„Åß„Åô)")
L312
L313 RATE_LIMIT = 55  # requests per minute (free tier is 60)
L314 call_times = []
L315
L316
L317 def finnhub_get(endpoint, params):
L318     """Call Finnhub API with basic rate limiting."""
L319     now = time.time()
L320     cutoff = now - 60
L321     while call_times and call_times[0] < cutoff:
L322         call_times.pop(0)
L323     if len(call_times) >= RATE_LIMIT:
L324         sleep_time = 60 - (now - call_times[0])
L325         time.sleep(sleep_time)
L326     params = {**params, "token": FINNHUB_API_KEY}
L327     try:
L328         resp = requests.get(f"https://finnhub.io/api/v1/{endpoint}", params=params)
L329         resp.raise_for_status()
L330         data = resp.json()
L331     except requests.exceptions.JSONDecodeError as e:
L332         print(f"‚ö†Ô∏è Finnhub API JSON decode error: {e}")
L333         return {}
L334     except Exception as e:
L335         print(f"‚ö†Ô∏è Finnhub API error: {e}")
L336         return {}
L337     call_times.append(time.time())
L338     return data
L339
L340
L341 def fetch_price(symbol):
L342     try:
L343         data = finnhub_get("quote", {"symbol": symbol})
L344         price = data.get("c")
L345         return float(price) if price not in (None, 0) else float("nan")
L346     except Exception:
L347         return float("nan")
L348
L349
L350 def fetch_vix_ma5():
L351     """Retrieve VIX 5-day moving average via yfinance."""
L352     try:
L353         vix = (
L354             yf.download("^VIX", period="7d", interval="1d", progress=False, auto_adjust=False)["Close"]
L355             .dropna()
L356             .tail(5)
L357         )
L358         if len(vix) < 5:
L359             return float("nan")
L360         return vix.mean().item()
L361     except Exception:
L362         return float("nan")
L363
L364
L365
L366 # === Minervini-like sell signals ===
L367 def _yf_df(sym, period="6mo"):
L368     """Êó•Ë∂≥/MA/Âá∫Êù•È´òÂπ≥Âùá„ÇíÂèñÂæó„ÄÇÊ¨†ÊêçÊôÇ„ÅØ None„ÄÇ"""
L369     try:
L370         df = yf.download(sym, period=period, interval="1d", auto_adjust=False, progress=False)
L371         if df is None or df.empty:
L372             return None
L373         return df.dropna().assign(
L374             ma20=lambda d: d["Close"].rolling(20).mean(),
L375             ma50=lambda d: d["Close"].rolling(50).mean(),
L376             vol50=lambda d: d["Volume"].rolling(50).mean(),
L377         )
L378     except Exception:
L379         return None
L380
L381
L382 def _scalar(row, col):
L383     """Series/np„Çπ„Ç´„É©‚ÜíPython„Çπ„Ç´„É©ÂåñÔºàNaN„ÅØNaN„ÅÆ„Åæ„ÅæÔºâ"""
L384     try:
L385         v = row[col]
L386         if hasattr(v, "item"):
L387             try:
L388                 v = v.item()
L389             except Exception:
L390                 pass
L391         return v
L392     except Exception:
L393         return float("nan")
L394
L395
L396 def _is_strict_down(seq):
L397     """Êï∞Âàó„ÅåÂé≥ÂØÜ„Å´ÈÄ£Á∂ö„ÅßÂàá„Çä‰∏ã„Åå„Å£„Å¶„ÅÑ„Çã„ÅãÔºàlen>=4„ÇíÊÉ≥ÂÆöÔºâ„ÄÇNaNÂê´„Åø„ÅØFalse„ÄÇ"""
L398     try:
L399         xs = [float(x) for x in seq]
L400         if any(pd.isna(x) for x in xs) or len(xs) < 4:
L401             return False
L402         return all(b < a for a, b in zip(xs[:-1], xs[1:]))
L403     except Exception:
L404         return False
L405
L406
L407 def _signals_for_day(df, idx):
L408     """df.loc[idx] 1Êó•ÂàÜ„Å´ÂØæ„Åó„Ç∑„Ç∞„Éä„É´ÈÖçÂàó„ÇíËøî„ÅôÔºàÂÄ§Âãï„Åç/Âá∫Êù•È´ò„Éô„Éº„Çπ„ÅÆ„ÅøÔºâ„ÄÇ"""
L409     try:
L410         sig = []
L411         d = df.loc[idx]
L412         close = _scalar(d, "Close")
L413         ma20 = _scalar(d, "ma20")
L414         ma50 = _scalar(d, "ma50")
L415         vol = _scalar(d, "Volume")
L416         vol50 = _scalar(d, "vol50")
L417
L418         if pd.notna(close) and pd.notna(ma20) and close < ma20:
L419             sig.append("20DMA‚Üì")
L420
L421         if all(pd.notna(x) for x in (close, ma50, vol, vol50)) and close < ma50 and vol > 1.5 * vol50:
L422             sig.append("50DMA‚Üì(Â§ßÂïÜ„ÅÑ)")
L423
L424         last4 = df.loc[:idx].tail(4)
L425         last10 = df.loc[:idx].tail(10)
L426
L427         lows_desc = _is_strict_down(last4["Low"].tolist()) if last4["Low"].notna().all() else False
L428         reds = int((last10["Close"] < last10["Open"]).sum()) if last10[["Close", "Open"]].notna().all().all() else 0
L429         if lows_desc or reds > 5:
L430             sig.append("ÈÄ£Á∂öÂÆâÂÄ§/Èô∞Á∑öÂÑ™Âã¢")
L431
L432         ups = int((last10["Close"] > last10["Open"]).sum()) if last10[["Close", "Open"]].notna().all().all() else 0
L433         if ups >= 7:
L434             sig.append("‰∏ä„ÅíÂÅèÈáç(>70%)")
L435
L436         last15 = df.loc[:idx].tail(15)
L437         base0 = _scalar(last15.iloc[0], "Close") if len(last15) > 0 else float("nan")
L438         if pd.notna(base0) and pd.notna(close) and base0 != 0 and (close / base0 - 1) >= 0.25:
L439             sig.append("+25%/15Êó•ÂÜÖ")
L440
L441         if len(df.loc[:idx]) >= 2:
L442             t1, t0 = df.loc[:idx].iloc[-2], df.loc[:idx].iloc[-1]
L443             t1_high = _scalar(t1, "High")
L444             t0_open = _scalar(t0, "Open")
L445             t0_close = _scalar(t0, "Close")
L446             if all(pd.notna(x) for x in (t1_high, t0_open, t0_close)):
L447                 if (t0_open > t1_high * 1.02) and (t0_close < t0_open):
L448                     sig.append("GU‚ÜíÈô∞Á∑ö")
L449         return sig
L450     except Exception:
L451         return []
L452
L453
L454 def scan_sell_signals(symbols, lookback_days=5):
L455     """
L456     Áõ¥Ëøë lookback_days Êó•„ÅÆ„ÅÜ„Å°‰∏ÄÂ∫¶„Åß„ÇÇ„Ç∑„Ç∞„Éä„É´„ÅåÂá∫„Åü„Çâ {sym: [(date,[signals]),...]} „ÇíËøî„Åô„ÄÇ
L457     Êó•‰ªò„ÅØ YYYY-MM-DD„ÄÇSlack„ÅßÂàóÊåô„Åô„Çã„ÄÇ
L458     """
L459     out = {}
L460     for s in symbols:
L461         df = _yf_df(s)
L462         if df is None or len(df) < 60:
L463             continue
L464         alerts = []
L465         for idx in df.tail(lookback_days).index:
L466             tags = _signals_for_day(df, idx)
L467             if tags:
L468                 alerts.append((idx.strftime("%Y-%m-%d"), tags))
L469         if alerts:
L470             out[s] = alerts
L471     return out
L472
L473
L474 def load_portfolio():
L475     tickers_path = Path(__file__).with_name("current_tickers.csv")
L476     with tickers_path.open() as f:
L477         rows = [row for row in csv.reader(f) if row and row[0].strip()]
L478     n = len(rows)
L479     portfolio = []
L480     for row in rows:
L481         sym = row[0].strip().upper()
L482         qty = int(row[1]) if len(row) > 1 and row[1].strip() else 0
L483         bucket = row[2].strip().upper() if len(row) > 2 else ""
L484         entry = {
L485             "symbol": sym,
L486             "shares": qty,
L487             "target_ratio": 1 / n if n else 0.0,
L488             "bucket": bucket,
L489         }
L490         portfolio.append(entry)
L491     return portfolio
L492
L493
L494 def compute_threshold():
L495     vix_ma5 = fetch_vix_ma5()
L496     drift_threshold = 10 if vix_ma5 < 20 else 12 if vix_ma5 < 26 else float("inf")
L497     return vix_ma5, drift_threshold
L498
L499
L500 def compute_threshold_by_mode(mode: str):
L501     """„É¢„Éº„Éâ„Å´Âøú„Åò„Å¶ÁèæÈáë‰øùÊúâÁéá„Å®„Éâ„É™„Éï„ÉàÈñæÂÄ§„ÇíËøî„ÅôÔºàREADMEÊ∫ñÊã†Ôºâ"""
L502     m = (mode or "NORMAL").upper()
L503     cash_ratio = config.CASH_RATIO_BY_MODE.get(
L504         m, config.CASH_RATIO_BY_MODE.get("NORMAL", 0.10)
L505     )
L506     drift_threshold = config.DRIFT_THRESHOLD_BY_MODE.get(
L507         m, config.DRIFT_THRESHOLD_BY_MODE.get("NORMAL", 12)
L508     )
L509     return cash_ratio, drift_threshold
L510
L511
L512 def recommended_counts_by_mode(mode: str) -> tuple[int, int, int]:
L513     """
L514     „É¢„Éº„ÉâÂà•„ÅÆÊé®Â•®‰øùÊúâÊï∞ (G_count, D_count, cash_slots) „ÇíËøî„Åô„ÄÇ
L515     cash_slots„ÅØ„ÄåÂ§ñ„ÅôGÊû†„ÅÆÊï∞„ÄçÔºàÂêÑÊû†=5%Ôºâ„ÄÇ
L516     NORMAL: G12/D8/ÁèæÈáëÂåñ0, CAUTION: G10/D8/ÁèæÈáëÂåñ2, EMERG: G8/D8/ÁèæÈáëÂåñ4
L517     """
L518     m = (mode or "NORMAL").upper()
L519     base = config.COUNTS_BY_MODE.get("NORMAL", config.COUNTS_BASE)
L520     now  = config.COUNTS_BY_MODE.get(m, base)
L521     cash_slots = max(0, base["G"] - now["G"])
L522     return now["G"], now["D"], cash_slots
L523
L524
L525 def _mode_tail_line(final_mode: str) -> str:
L526     """‚ë†„Éñ„É≠„ÉÉ„ÇØÂÜÖ„ÅÆ‚Äú„Åì„ÅÆ„É¢„Éº„Éâ„ÅÆË®≠ÂÆö‚Äù„ÇíÊîπË°åÔºã„Ç¢„Ç§„Ç≥„É≥„ÅßÊï¥ÂΩ¢Ôºàüìä„ÅØË°®Á§∫„Åó„Å™„ÅÑÔºâ"""
L527     fm = (final_mode or "NORMAL").upper()
L528     base_ts = config.TS_BASE_BY_MODE.get(fm, config.TS_BASE_BY_MODE.get("NORMAL", 0.15))
L529     ts_base_pct = int(round(base_ts * 100))
L530     d1, d2, d3 = config.TS_STEP_DELTAS_PT
L531     step30 = max(ts_base_pct - d1, 0)
L532     step60 = max(ts_base_pct - d2, 0)
L533     step100 = max(ts_base_pct - d3, 0)
L534     g_cnt, d_cnt, cash_slots = recommended_counts_by_mode(fm)
L535     cash_pct = config.CASH_RATIO_BY_MODE.get(fm, config.CASH_RATIO_BY_MODE.get("NORMAL", 0.10)) * 100
L536     return "\n".join([
L537         "„Äî„Åì„ÅÆ„É¢„Éº„Éâ„ÅÆË®≠ÂÆö„Äï",
L538         f"üéØ TSÂü∫Êú¨: -{ts_base_pct}ÔºÖÔºà+30%‚Üí-{step30}ÔºÖÔºè+60%‚Üí-{step60}ÔºÖÔºè+100%‚Üí-{step100}ÔºÖÔºâ",
L539         f"üß© Êé®Â•®‰øùÊúâ: G{g_cnt}„ÉªD{d_cnt}ÔºàÁèæÈáëÂåñÊû† {cash_slots}Ôºâ",
L540         f"üíº Êé®Â•®ÁèæÈáëÊØîÁéá: {cash_pct:.0f}ÔºÖ",
L541     ])
L542
L543
L544 def build_dataframe(portfolio):
L545     for stock in portfolio:
L546         price = fetch_price(stock["symbol"])
L547         stock["price"] = price
L548         stock["value"] = price * stock["shares"]
L549
L550     df = pd.DataFrame(portfolio)
L551     total_value = df["value"].sum()
L552     df["current_ratio"] = df["value"] / total_value
L553     df["drift"] = df["current_ratio"] - df["target_ratio"]
L554     df["drift_abs"] = df["drift"].abs()
L555     total_drift_abs = df["drift_abs"].sum()
L556     df["adjusted_ratio"] = df["current_ratio"] - df["drift"] / 2
L557     df["adjustable"] = (
L558         (df["adjusted_ratio"] * total_value) >= df["price"]
L559     ) & df["price"].notna() & df["price"].gt(0)
L560     return df, total_value, total_drift_abs
L561
L562
L563 def simulate(df, total_value, total_drift_abs, drift_threshold):
L564     alert = drift_threshold != float("inf") and total_drift_abs * 100 > drift_threshold
L565     if alert:
L566         df["trade_shares"] = df.apply(
L567             lambda r: int(round(((r["adjusted_ratio"] * total_value) - r["value"]) / r["price"]))
L568             if r["adjustable"] and r["price"] > 0 else 0,
L569             axis=1,
L570         )
L571         df["new_shares"] = df["shares"] + df["trade_shares"]
L572         df["new_value"] = df["new_shares"] * df["price"]
L573         new_total_value = df["new_value"].sum()
L574         df["simulated_ratio"] = df["new_value"] / new_total_value
L575         df["simulated_drift_abs"] = (df["simulated_ratio"] - df["target_ratio"]).abs()
L576         simulated_total_drift_abs = df["simulated_drift_abs"].sum()
L577     else:
L578         df["trade_shares"] = np.nan
L579         df["new_shares"] = np.nan
L580         df["new_value"] = np.nan
L581         new_total_value = np.nan
L582         df["simulated_ratio"] = np.nan
L583         df["simulated_drift_abs"] = np.nan
L584         simulated_total_drift_abs = np.nan
L585     return df, alert, new_total_value, simulated_total_drift_abs
L586
L587
L588 def prep
```