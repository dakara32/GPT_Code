```text
  => NORMAL")
L287         return "NORMAL", 0.0
L288
L289     details.sort(key=lambda x: x[4], reverse=True)
L290     today = pd.Timestamp.today(tz="America/New_York").date().isoformat()
L291     print(f"📝 audit[G-CD details] {today}  G={len(g_syms)}")
L292     print("  SYMBOL        Peak60(H)     Low(T)     ratio    DD%")
L293     for sym, peak, low, ratio, ddpct in details:
L294         print(f"  {sym:<8}  {peak:>12.6g}  {low:>10.6g}   {ratio:>6.3f}  {ddpct:>6.2f}")
L295
L296     avg_ratio = float(np.mean([r for _, _, _, r, _ in details]))
L297     gcd_pct = max(0.0, (1.0 - avg_ratio) * 100.0)
L298     mode = "EMERG" if gcd_pct >= CD_EMERG * 100 else "CAUTION" if gcd_pct >= CD_CAUTION * 100 else "NORMAL"
L299     print(
L300         f"📝 audit[G-CD summary]: avg_low/peak60={avg_ratio:.4f}  drawdown={gcd_pct:.2f}%  => {mode}"
L301     )
L302     return mode, gcd_pct
L303 # Debug flag
L304 debug_mode = False  # set to True for detailed output
L305
L306 # --- Finnhub settings & helper ---
L307 FINNHUB_API_KEY = os.environ.get("FINNHUB_API_KEY")
L308 if not FINNHUB_API_KEY:
L309     raise ValueError("FINNHUB_API_KEY not set (環境変数が未設定です)")
L310
L311 RATE_LIMIT = 55  # requests per minute (free tier is 60)
L312 call_times = []
L313
L314
L315 def finnhub_get(endpoint, params):
L316     """Call Finnhub API with basic rate limiting."""
L317     now = time.time()
L318     cutoff = now - 60
L319     while call_times and call_times[0] < cutoff:
L320         call_times.pop(0)
L321     if len(call_times) >= RATE_LIMIT:
L322         sleep_time = 60 - (now - call_times[0])
L323         time.sleep(sleep_time)
L324     params = {**params, "token": FINNHUB_API_KEY}
L325     try:
L326         resp = requests.get(f"https://finnhub.io/api/v1/{endpoint}", params=params)
L327         resp.raise_for_status()
L328         data = resp.json()
L329     except requests.exceptions.JSONDecodeError as e:
L330         print(f"⚠️ Finnhub API JSON decode error: {e}")
L331         return {}
L332     except Exception as e:
L333         print(f"⚠️ Finnhub API error: {e}")
L334         return {}
L335     call_times.append(time.time())
L336     return data
L337
L338
L339 def fetch_price(symbol):
L340     try:
L341         data = finnhub_get("quote", {"symbol": symbol})
L342         price = data.get("c")
L343         return float(price) if price not in (None, 0) else float("nan")
L344     except Exception:
L345         return float("nan")
L346
L347
L348 def fetch_vix_ma5():
L349     """Retrieve VIX 5-day moving average via yfinance."""
L350     try:
L351         vix = (
L352             yf.download("^VIX", period="7d", interval="1d", progress=False, auto_adjust=False)["Close"]
L353             .dropna()
L354             .tail(5)
L355         )
L356         if len(vix) < 5:
L357             return float("nan")
L358         return vix.mean().item()
L359     except Exception:
L360         return float("nan")
L361
L362
L363
L364 # === Minervini-like sell signals ===
L365 def _yf_df(sym, period="6mo"):
L366     """日足/MA/出来高平均を取得。欠損時は None。"""
L367     try:
L368         df = yf.download(sym, period=period, interval="1d", auto_adjust=False, progress=False)
L369         if df is None or df.empty:
L370             return None
L371         return df.dropna().assign(
L372             ma20=lambda d: d["Close"].rolling(20).mean(),
L373             ma50=lambda d: d["Close"].rolling(50).mean(),
L374             vol50=lambda d: d["Volume"].rolling(50).mean(),
L375         )
L376     except Exception:
L377         return None
L378
L379
L380 def _scalar(row, col):
L381     """Series/npスカラ→Pythonスカラ化（NaNはNaNのまま）"""
L382     try:
L383         v = row[col]
L384         if hasattr(v, "item"):
L385             try:
L386                 v = v.item()
L387             except Exception:
L388                 pass
L389         return v
L390     except Exception:
L391         return float("nan")
L392
L393
L394 def _is_strict_down(seq):
L395     """数列が厳密に連続で切り下がっているか（len>=4を想定）。NaN含みはFalse。"""
L396     try:
L397         xs = [float(x) for x in seq]
L398         if any(pd.isna(x) for x in xs) or len(xs) < 4:
L399             return False
L400         return all(b < a for a, b in zip(xs[:-1], xs[1:]))
L401     except Exception:
L402         return False
L403
L404
L405 def _signals_for_day(df, idx):
L406     """df.loc[idx] 1日分に対しシグナル配列を返す（値動き/出来高ベースのみ）。"""
L407     try:
L408         sig = []
L409         d = df.loc[idx]
L410         close = _scalar(d, "Close")
L411         ma20 = _scalar(d, "ma20")
L412         ma50 = _scalar(d, "ma50")
L413         vol = _scalar(d, "Volume")
L414         vol50 = _scalar(d, "vol50")
L415
L416         if pd.notna(close) and pd.notna(ma20) and close < ma20:
L417             sig.append("20DMA↓")
L418
L419         if all(pd.notna(x) for x in (close, ma50, vol, vol50)) and close < ma50 and vol > 1.5 * vol50:
L420             sig.append("50DMA↓(大商い)")
L421
L422         last4 = df.loc[:idx].tail(4)
L423         last10 = df.loc[:idx].tail(10)
L424
L425         lows_desc = _is_strict_down(last4["Low"].tolist()) if last4["Low"].notna().all() else False
L426         reds = int((last10["Close"] < last10["Open"]).sum()) if last10[["Close", "Open"]].notna().all().all() else 0
L427         if lows_desc or reds > 5:
L428             sig.append("連続安値/陰線優勢")
L429
L430         ups = int((last10["Close"] > last10["Open"]).sum()) if last10[["Close", "Open"]].notna().all().all() else 0
L431         if ups >= 7:
L432             sig.append("上げ偏重(>70%)")
L433
L434         last15 = df.loc[:idx].tail(15)
L435         base0 = _scalar(last15.iloc[0], "Close") if len(last15) > 0 else float("nan")
L436         if pd.notna(base0) and pd.notna(close) and base0 != 0 and (close / base0 - 1) >= 0.25:
L437             sig.append("+25%/15日内")
L438
L439         if len(df.loc[:idx]) >= 2:
L440             t1, t0 = df.loc[:idx].iloc[-2], df.loc[:idx].iloc[-1]
L441             t1_high = _scalar(t1, "High")
L442             t0_open = _scalar(t0, "Open")
L443             t0_close = _scalar(t0, "Close")
L444             if all(pd.notna(x) for x in (t1_high, t0_open, t0_close)):
L445                 if (t0_open > t1_high * 1.02) and (t0_close < t0_open):
L446                     sig.append("GU→陰線")
L447         return sig
L448     except Exception:
L449         return []
L450
L451
L452 def scan_sell_signals(symbols, lookback_days=5):
L453     """
L454     直近 lookback_days 日のうち一度でもシグナルが出たら {sym: [(date,[signals]),...]} を返す。
L455     日付は YYYY-MM-DD。Slackで列挙する。
L456     """
L457     out = {}
L458     for s in symbols:
L459         df = _yf_df(s)
L460         if df is None or len(df) < 60:
L461             continue
L462         alerts = []
L463         for idx in df.tail(lookback_days).index:
L464             tags = _signals_for_day(df, idx)
L465             if tags:
L466                 alerts.append((idx.strftime("%Y-%m-%d"), tags))
L467         if alerts:
L468             out[s] = alerts
L469     return out
L470
L471
L472 def load_portfolio():
L473     tickers_path = Path(__file__).with_name("current_tickers.csv")
L474     with tickers_path.open() as f:
L475         rows = [row for row in csv.reader(f) if row and row[0].strip()]
L476     n = len(rows)
L477     portfolio = []
L478     for row in rows:
L479         sym = row[0].strip().upper()
L480         qty = int(row[1]) if len(row) > 1 and row[1].strip() else 0
L481         bucket = row[2].strip().upper() if len(row) > 2 else ""
L482         entry = {
L483             "symbol": sym,
L484             "shares": qty,
L485             "target_ratio": 1 / n if n else 0.0,
L486             "bucket": bucket,
L487         }
L488         portfolio.append(entry)
L489     return portfolio
L490
L491
L492 def compute_threshold():
L493     vix_ma5 = fetch_vix_ma5()
L494     drift_threshold = 10 if vix_ma5 < 20 else 12 if vix_ma5 < 26 else float("inf")
L495     return vix_ma5, drift_threshold
L496
L497
L498 def compute_threshold_by_mode(mode: str):
L499     """モードに応じて現金保有率とドリフト閾値を返す（README準拠）"""
L500     m = (mode or "NORMAL").upper()
L501     cash_ratio = config.CASH_RATIO_BY_MODE.get(
L502         m, config.CASH_RATIO_BY_MODE.get("NORMAL", 0.10)
L503     )
L504     drift_threshold = config.DRIFT_THRESHOLD_BY_MODE.get(
L505         m, config.DRIFT_THRESHOLD_BY_MODE.get("NORMAL", 12)
L506     )
L507     return cash_ratio, drift_threshold
L508
L509
L510 def recommended_counts_by_mode(mode: str) -> tuple[int, int, int]:
L511     """
L512     モード別の推奨保有数 (G_count, D_count, cash_slots) を返す。
L513     cash_slotsは「外すG枠の数」（各枠=5%）。
L514     NORMAL: G12/D8/現金化0, CAUTION: G10/D8/現金化2, EMERG: G8/D8/現金化4
L515     """
L516     m = (mode or "NORMAL").upper()
L517     base = config.COUNTS_BY_MODE.get("NORMAL", config.COUNTS_BASE)
L518     now  = config.COUNTS_BY_MODE.get(m, base)
L519     cash_slots = max(0, base["G"] - now["G"])
L520     return now["G"], now["D"], cash_slots
L521
L522
L523 def _mode_tail_line(final_mode: str) -> str:
L524     fm = (final_mode or "NORMAL").upper()
L525     base_ts = config.TS_BASE_BY_MODE.get(fm, config.TS_BASE_BY_MODE.get("NORMAL", 0.15))
L526     ts_base = int(round(base_ts * 100))
L527     g_cnt, d_cnt, cash_slots = recommended_counts_by_mode(fm)
L528     cash_pct = config.CASH_RATIO_BY_MODE.get(
L529         fm, config.CASH_RATIO_BY_MODE.get("NORMAL", 0.10)
L530     ) * 100
L531     return (
L532         f"〔このモードの設定〕TS基本: -{ts_base}% ／ "
L533         f"推奨保有: G{g_cnt}・D{d_cnt}（現金化枠 {cash_slots}）／ "
L534         f"推奨現金比率: {cash_pct:.0f}%"
L535     )
L536
L537
L538 def build_dataframe(portfolio):
L539     for stock in portfolio:
L540         price = fetch_price(stock["symbol"])
L541         stock["price"] = price
L542         stock["value"] = price * stock["shares"]
L543
L544     df = pd.DataFrame(portfolio)
L545     total_value = df["value"].sum()
L546     df["current_ratio"] = df["value"] / total_value
L547     df["drift"] = df["current_ratio"] - df["target_ratio"]
L548     df["drift_abs"] = df["drift"].abs()
L549     total_drift_abs = df["drift_abs"].sum()
L550     df["adjusted_ratio"] = df["current_ratio"] - df["drift"] / 2
L551     df["adjustable"] = (
L552         (df["adjusted_ratio"] * total_value) >= df["price"]
L553     ) & df["price"].notna() & df["price"].gt(0)
L554     return df, total_value, total_drift_abs
L555
L556
L557 def simulate(df, total_value, total_drift_abs, drift_threshold):
L558     alert = drift_threshold != float("inf") and total_drift_abs * 100 > drift_threshold
L559     if alert:
L560         df["trade_shares"] = df.apply(
L561             lambda r: int(round(((r["adjusted_ratio"] * total_value) - r["value"]) / r["price"]))
L562             if r["adjustable"] and r["price"] > 0 else 0,
L563             axis=1,
L564         )
L565         df["new_shares"] = df["shares"] + df["trade_shares"]
L566         df["new_value"] = df["new_shares"] * df["price"]
L567         new_total_value = df["new_value"].sum()
L568         df["simulated_ratio"] = df["new_value"] / new_total_value
L569         df["simulated_drift_abs"] = (df["simulated_ratio"] - df["target_ratio"]).abs()
L570         simulated_total_drift_abs = df["simulated_drift_abs"].sum()
L571     else:
L572         df["trade_shares"] = np.nan
L573         df["new_shares"] = np.nan
L574         df["new_value"] = np.nan
L575         new_total_value = np.nan
L576         df["simulated_ratio"] = np.nan
L577         df["simulated_drift_abs"] = np.nan
L578         simulated_total_drift_abs = np.nan
L579     return df, alert, new_total_value, simulated_total_drift_abs
L580
L581
L582 def prepare_summary(df, total_drift_abs, alert):
L583     summary = {
L584         "symbol": "合計",
L585         "shares": df["shares"].sum(),
L586         "value": df["value"].sum(),
L587         "current_ratio": np.nan,
L588         "drift_abs": total_drift_abs,
L589     }
L590     if alert:
L591         summary["trade_shares"] = np.nan
L592     # Sort details by evaluation value descending before appending summary
L593     df = df.sort_values(by="valu
```