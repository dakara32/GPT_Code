```text
it[G-CD details]: ÊúâÂäπ„Å™ÈäòÊüÑ„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì")
L287         print("üìù audit[G-CD summary]: avg_low/peak60=1.0000  drawdown=0.00%  => NORMAL")
L288         return "NORMAL", 0.0
L289
L290     details.sort(key=lambda x: x[4], reverse=True)
L291     today = pd.Timestamp.today(tz="America/New_York").date().isoformat()
L292     print(f"üìù audit[G-CD details] {today}  G={len(g_syms)}")
L293     print("  SYMBOL        Peak60(H)     Low(T)     ratio    DD%")
L294     for sym, peak, low, ratio, ddpct in details:
L295         print(f"  {sym:<8}  {peak:>12.6g}  {low:>10.6g}   {ratio:>6.3f}  {ddpct:>6.2f}")
L296
L297     avg_ratio = float(np.mean([r for _, _, _, r, _ in details]))
L298     gcd_pct = max(0.0, (1.0 - avg_ratio) * 100.0)
L299     mode = "EMERG" if gcd_pct >= CD_EMERG * 100 else "CAUTION" if gcd_pct >= CD_CAUTION * 100 else "NORMAL"
L300     print(
L301         f"üìù audit[G-CD summary]: avg_low/peak60={avg_ratio:.4f}  drawdown={gcd_pct:.2f}%  => {mode}"
L302     )
L303     return mode, gcd_pct
L304 # Debug flag
L305 debug_mode = False  # set to True for detailed output
L306
L307 # --- Finnhub settings & helper ---
L308 FINNHUB_API_KEY = os.environ.get("FINNHUB_API_KEY")
L309 if not FINNHUB_API_KEY:
L310     raise ValueError("FINNHUB_API_KEY not set (Áí∞Â¢ÉÂ§âÊï∞„ÅåÊú™Ë®≠ÂÆö„Åß„Åô)")
L311
L312 RATE_LIMIT = 55  # requests per minute (free tier is 60)
L313 call_times = []
L314
L315
L316 def finnhub_get(endpoint, params):
L317     """Call Finnhub API with basic rate limiting."""
L318     now = time.time()
L319     cutoff = now - 60
L320     while call_times and call_times[0] < cutoff:
L321         call_times.pop(0)
L322     if len(call_times) >= RATE_LIMIT:
L323         sleep_time = 60 - (now - call_times[0])
L324         time.sleep(sleep_time)
L325     params = {**params, "token": FINNHUB_API_KEY}
L326     try:
L327         resp = requests.get(f"https://finnhub.io/api/v1/{endpoint}", params=params)
L328         resp.raise_for_status()
L329         data = resp.json()
L330     except requests.exceptions.JSONDecodeError as e:
L331         print(f"‚ö†Ô∏è Finnhub API JSON decode error: {e}")
L332         return {}
L333     except Exception as e:
L334         print(f"‚ö†Ô∏è Finnhub API error: {e}")
L335         return {}
L336     call_times.append(time.time())
L337     return data
L338
L339
L340 def fetch_price(symbol):
L341     try:
L342         data = finnhub_get("quote", {"symbol": symbol})
L343         price = data.get("c")
L344         return float(price) if price not in (None, 0) else float("nan")
L345     except Exception:
L346         return float("nan")
L347
L348
L349 def fetch_vix_ma5():
L350     """Retrieve VIX 5-day moving average via yfinance."""
L351     try:
L352         vix = (
L353             yf.download("^VIX", period="7d", interval="1d", progress=False, auto_adjust=False)["Close"]
L354             .dropna()
L355             .tail(5)
L356         )
L357         if len(vix) < 5:
L358             return float("nan")
L359         return vix.mean().item()
L360     except Exception:
L361         return float("nan")
L362
L363
L364
L365 # === Minervini-like sell signals ===
L366 def _yf_df(sym, period="6mo"):
L367     """Êó•Ë∂≥/MA/Âá∫Êù•È´òÂπ≥Âùá„ÇíÂèñÂæó„ÄÇÊ¨†ÊêçÊôÇ„ÅØ None„ÄÇ"""
L368     try:
L369         df = yf.download(sym, period=period, interval="1d", auto_adjust=False, progress=False)
L370         if df is None or df.empty:
L371             return None
L372         return df.dropna().assign(
L373             ma20=lambda d: d["Close"].rolling(20).mean(),
L374             ma50=lambda d: d["Close"].rolling(50).mean(),
L375             vol50=lambda d: d["Volume"].rolling(50).mean(),
L376         )
L377     except Exception:
L378         return None
L379
L380
L381 def _scalar(row, col):
L382     """Series/np„Çπ„Ç´„É©‚ÜíPython„Çπ„Ç´„É©ÂåñÔºàNaN„ÅØNaN„ÅÆ„Åæ„ÅæÔºâ"""
L383     try:
L384         v = row[col]
L385         if hasattr(v, "item"):
L386             try:
L387                 v = v.item()
L388             except Exception:
L389                 pass
L390         return v
L391     except Exception:
L392         return float("nan")
L393
L394
L395 def _is_strict_down(seq):
L396     """Êï∞Âàó„ÅåÂé≥ÂØÜ„Å´ÈÄ£Á∂ö„ÅßÂàá„Çä‰∏ã„Åå„Å£„Å¶„ÅÑ„Çã„ÅãÔºàlen>=4„ÇíÊÉ≥ÂÆöÔºâ„ÄÇNaNÂê´„Åø„ÅØFalse„ÄÇ"""
L397     try:
L398         xs = [float(x) for x in seq]
L399         if any(pd.isna(x) for x in xs) or len(xs) < 4:
L400             return False
L401         return all(b < a for a, b in zip(xs[:-1], xs[1:]))
L402     except Exception:
L403         return False
L404
L405
L406 def _signals_for_day(df, idx):
L407     """df.loc[idx] 1Êó•ÂàÜ„Å´ÂØæ„Åó„Ç∑„Ç∞„Éä„É´ÈÖçÂàó„ÇíËøî„ÅôÔºàÂÄ§Âãï„Åç/Âá∫Êù•È´ò„Éô„Éº„Çπ„ÅÆ„ÅøÔºâ„ÄÇ"""
L408     try:
L409         sig = []
L410         d = df.loc[idx]
L411         close = _scalar(d, "Close")
L412         ma20 = _scalar(d, "ma20")
L413         ma50 = _scalar(d, "ma50")
L414         vol = _scalar(d, "Volume")
L415         vol50 = _scalar(d, "vol50")
L416
L417         if pd.notna(close) and pd.notna(ma20) and close < ma20:
L418             sig.append("20DMA‚Üì")
L419
L420         if all(pd.notna(x) for x in (close, ma50, vol, vol50)) and close < ma50 and vol > 1.5 * vol50:
L421             sig.append("50DMA‚Üì(Â§ßÂïÜ„ÅÑ)")
L422
L423         last4 = df.loc[:idx].tail(4)
L424         last10 = df.loc[:idx].tail(10)
L425
L426         lows_desc = _is_strict_down(last4["Low"].tolist()) if last4["Low"].notna().all() else False
L427         reds = int((last10["Close"] < last10["Open"]).sum()) if last10[["Close", "Open"]].notna().all().all() else 0
L428         if lows_desc or reds > 5:
L429             sig.append("ÈÄ£Á∂öÂÆâÂÄ§/Èô∞Á∑öÂÑ™Âã¢")
L430
L431         ups = int((last10["Close"] > last10["Open"]).sum()) if last10[["Close", "Open"]].notna().all().all() else 0
L432         if ups >= 7:
L433             sig.append("‰∏ä„ÅíÂÅèÈáç(>70%)")
L434
L435         last15 = df.loc[:idx].tail(15)
L436         base0 = _scalar(last15.iloc[0], "Close") if len(last15) > 0 else float("nan")
L437         if pd.notna(base0) and pd.notna(close) and base0 != 0 and (close / base0 - 1) >= 0.25:
L438             sig.append("+25%/15Êó•ÂÜÖ")
L439
L440         if len(df.loc[:idx]) >= 2:
L441             t1, t0 = df.loc[:idx].iloc[-2], df.loc[:idx].iloc[-1]
L442             t1_high = _scalar(t1, "High")
L443             t0_open = _scalar(t0, "Open")
L444             t0_close = _scalar(t0, "Close")
L445             if all(pd.notna(x) for x in (t1_high, t0_open, t0_close)):
L446                 if (t0_open > t1_high * 1.02) and (t0_close < t0_open):
L447                     sig.append("GU‚ÜíÈô∞Á∑ö")
L448         return sig
L449     except Exception:
L450         return []
L451
L452
L453 def scan_sell_signals(symbols, lookback_days=5):
L454     """
L455     Áõ¥Ëøë lookback_days Êó•„ÅÆ„ÅÜ„Å°‰∏ÄÂ∫¶„Åß„ÇÇ„Ç∑„Ç∞„Éä„É´„ÅåÂá∫„Åü„Çâ {sym: [(date,[signals]),...]} „ÇíËøî„Åô„ÄÇ
L456     Êó•‰ªò„ÅØ YYYY-MM-DD„ÄÇSlack„ÅßÂàóÊåô„Åô„Çã„ÄÇ
L457     """
L458     out = {}
L459     for s in symbols:
L460         df = _yf_df(s)
L461         if df is None or len(df) < 60:
L462             continue
L463         alerts = []
L464         for idx in df.tail(lookback_days).index:
L465             tags = _signals_for_day(df, idx)
L466             if tags:
L467                 alerts.append((idx.strftime("%Y-%m-%d"), tags))
L468         if alerts:
L469             out[s] = alerts
L470     return out
L471
L472
L473 def load_portfolio():
L474     tickers_path = Path(__file__).with_name("current_tickers.csv")
L475     with tickers_path.open() as f:
L476         rows = [row for row in csv.reader(f) if row and row[0].strip()]
L477     n = len(rows)
L478     portfolio = []
L479     for row in rows:
L480         sym = row[0].strip().upper()
L481         qty = int(row[1]) if len(row) > 1 and row[1].strip() else 0
L482         bucket = row[2].strip().upper() if len(row) > 2 else ""
L483         entry = {
L484             "symbol": sym,
L485             "shares": qty,
L486             "target_ratio": 1 / n if n else 0.0,
L487             "bucket": bucket,
L488         }
L489         portfolio.append(entry)
L490     return portfolio
L491
L492
L493 def compute_threshold():
L494     vix_ma5 = fetch_vix_ma5()
L495     drift_threshold = 10 if vix_ma5 < 20 else 12 if vix_ma5 < 26 else float("inf")
L496     return vix_ma5, drift_threshold
L497
L498
L499 def compute_threshold_by_mode(mode: str):
L500     """„É¢„Éº„Éâ„Å´Âøú„Åò„Å¶ÁèæÈáë‰øùÊúâÁéá„Å®„Éâ„É™„Éï„ÉàÈñæÂÄ§„ÇíËøî„ÅôÔºàREADMEÊ∫ñÊã†Ôºâ"""
L501     m = (mode or "NORMAL").upper()
L502     cash_ratio = config.CASH_RATIO_BY_MODE.get(
L503         m, config.CASH_RATIO_BY_MODE.get("NORMAL", 0.10)
L504     )
L505     drift_threshold = config.DRIFT_THRESHOLD_BY_MODE.get(
L506         m, config.DRIFT_THRESHOLD_BY_MODE.get("NORMAL", 12)
L507     )
L508     return cash_ratio, drift_threshold
L509
L510
L511 def recommended_counts_by_mode(mode: str) -> tuple[int, int, int]:
L512     """
L513     „É¢„Éº„ÉâÂà•„ÅÆÊé®Â•®‰øùÊúâÊï∞ (G_count, D_count, cash_slots) „ÇíËøî„Åô„ÄÇ
L514     cash_slots„ÅØ„ÄåÂ§ñ„ÅôGÊû†„ÅÆÊï∞„ÄçÔºàÂêÑÊû†=5%Ôºâ„ÄÇ
L515     NORMAL: G12/D8/ÁèæÈáëÂåñ0, CAUTION: G10/D8/ÁèæÈáëÂåñ2, EMERG: G8/D8/ÁèæÈáëÂåñ4
L516     """
L517     m = (mode or "NORMAL").upper()
L518     base = config.COUNTS_BY_MODE.get("NORMAL", config.COUNTS_BASE)
L519     now  = config.COUNTS_BY_MODE.get(m, base)
L520     cash_slots = max(0, base["G"] - now["G"])
L521     return now["G"], now["D"], cash_slots
L522
L523
L524 def _mode_tail_line(final_mode: str) -> str:
L525     """‚ë†„Éñ„É≠„ÉÉ„ÇØÂÜÖ„ÅÆ‚Äú„Åì„ÅÆ„É¢„Éº„Éâ„ÅÆË®≠ÂÆö‚Äù„ÇíÊîπË°åÔºã„Ç¢„Ç§„Ç≥„É≥„ÅßÊï¥ÂΩ¢Ôºàüìä„ÅØË°®Á§∫„Åó„Å™„ÅÑÔºâ"""
L526     fm = (final_mode or "NORMAL").upper()
L527     base_ts = config.TS_BASE_BY_MODE.get(fm, config.TS_BASE_BY_MODE.get("NORMAL", 0.15))
L528     ts_base_pct = int(round(base_ts * 100))
L529     d1, d2, d3 = config.TS_STEP_DELTAS_PT
L530     step30 = max(ts_base_pct - d1, 0)
L531     step60 = max(ts_base_pct - d2, 0)
L532     step100 = max(ts_base_pct - d3, 0)
L533     g_cnt, d_cnt, cash_slots = recommended_counts_by_mode(fm)
L534     cash_pct = config.CASH_RATIO_BY_MODE.get(fm, config.CASH_RATIO_BY_MODE.get("NORMAL", 0.10)) * 100
L535     return "\n".join([
L536         "„Äî„Åì„ÅÆ„É¢„Éº„Éâ„ÅÆË®≠ÂÆö„Äï",
L537         f"üéØ TSÂü∫Êú¨: -{ts_base_pct}ÔºÖÔºà+30%‚Üí-{step30}ÔºÖÔºè+60%‚Üí-{step60}ÔºÖÔºè+100%‚Üí-{step100}ÔºÖÔºâ",
L538         f"üß© Êé®Â•®‰øùÊúâ: G{g_cnt}„ÉªD{d_cnt}ÔºàÁèæÈáëÂåñÊû† {cash_slots}Ôºâ",
L539         f"üíº Êé®Â•®ÁèæÈáëÊØîÁéá: {cash_pct:.0f}ÔºÖ",
L540     ])
L541
L542
L543 def build_dataframe(portfolio):
L544     for stock in portfolio:
L545         price = fetch_price(stock["symbol"])
L546         stock["price"] = price
L547         stock["value"] = price * stock["shares"]
L548
L549     df = pd.DataFrame(portfolio)
L550     total_value = df["value"].sum()
L551     df["current_ratio"] = df["value"] / total_value
L552     df["drift"] = df["current_ratio"] - df["target_ratio"]
L553     df["drift_abs"] = df["drift"].abs()
L554     total_drift_abs = df["drift_abs"].sum()
L555     df["adjusted_ratio"] = df["current_ratio"] - df["drift"] / 2
L556     df["adjustable"] = (
L557         (df["adjusted_ratio"] * total_value) >= df["price"]
L558     ) & df["price"].notna() & df["price"].gt(0)
L559     return df, total_value, total_drift_abs
L560
L561
L562 def simulate(df, total_value, total_drift_abs, drift_threshold):
L563     alert = drift_threshold != float("inf") and total_drift_abs * 100 > drift_threshold
L564     if alert:
L565         df["trade_shares"] = df.apply(
L566             lambda r: int(round(((r["adjusted_ratio"] * total_value) - r["value"]) / r["price"]))
L567             if r["adjustable"] and r["price"] > 0 else 0,
L568             axis=1,
L569         )
L570         df["new_shares"] = df["shares"] + df["trade_shares"]
L571         df["new_value"] = df["new_shares"] * df["price"]
L572         new_total_value = df["new_value"].sum()
L573         df["simulated_ratio"] = df["new_value"] / new_total_value
L574         df["simulated_drift_abs"] = (df["simulated_ratio"] - df["target_ratio"]).abs()
L575         simulated_total_drift_abs = df["simulated_drift_abs"].sum()
L576     else:
L577         df["trade_shares"] = np.nan
L578         df["new_shares"] = np.nan
L579         df["new_value"] = np.nan
L580         new_total_value = np.nan
L581         df["simulated_ratio"] = np.nan
L582         df["simulated_drift_abs"] = np.nan
L583         simulated_total_drift_abs = np.nan
L584     return df, alert, new_total_value, simulated_total_drift_abs
L585
L586
L587 def prepare_summary(df, total_drift_abs, aler
```