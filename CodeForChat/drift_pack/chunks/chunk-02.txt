```text
     )
L301             writer.writerows(rows)
L302
L303     k5 = len(uniq_hits)
L304     mode1 = "EMERG" if k5 >= 8 else "CAUTION" if k5 >= 6 else "NORMAL"
L305     return mode1, k5, today_hits
L306 # Debug flag
L307 debug_mode = False  # set to True for detailed output
L308
L309 # --- Finnhub settings & helper ---
L310 FINNHUB_API_KEY = os.environ.get("FINNHUB_API_KEY")
L311 if not FINNHUB_API_KEY:
L312     raise ValueError("FINNHUB_API_KEY not set (環境変数が未設定です)")
L313
L314 RATE_LIMIT = 55  # requests per minute (free tier is 60)
L315 call_times = []
L316
L317
L318 def finnhub_get(endpoint, params):
L319     """Call Finnhub API with basic rate limiting."""
L320     now = time.time()
L321     cutoff = now - 60
L322     while call_times and call_times[0] < cutoff:
L323         call_times.pop(0)
L324     if len(call_times) >= RATE_LIMIT:
L325         sleep_time = 60 - (now - call_times[0])
L326         time.sleep(sleep_time)
L327     params = {**params, "token": FINNHUB_API_KEY}
L328     try:
L329         resp = requests.get(f"https://finnhub.io/api/v1/{endpoint}", params=params)
L330         resp.raise_for_status()
L331         data = resp.json()
L332     except requests.exceptions.JSONDecodeError as e:
L333         print(f"⚠️ Finnhub API JSON decode error: {e}")
L334         return {}
L335     except Exception as e:
L336         print(f"⚠️ Finnhub API error: {e}")
L337         return {}
L338     call_times.append(time.time())
L339     return data
L340
L341
L342 def fetch_price(symbol):
L343     try:
L344         data = finnhub_get("quote", {"symbol": symbol})
L345         price = data.get("c")
L346         return float(price) if price not in (None, 0) else float("nan")
L347     except Exception:
L348         return float("nan")
L349
L350
L351 def fetch_vix_ma5():
L352     """Retrieve VIX 5-day moving average via yfinance."""
L353     try:
L354         vix = (
L355             yf.download("^VIX", period="7d", interval="1d", progress=False, auto_adjust=False)["Close"]
L356             .dropna()
L357             .tail(5)
L358         )
L359         if len(vix) < 5:
L360             return float("nan")
L361         return vix.mean().item()
L362     except Exception:
L363         return float("nan")
L364
L365
L366
L367 # === Minervini-like sell signals ===
L368 def _yf_df(sym, period="6mo"):
L369     """日足/MA/出来高平均を取得。欠損時は None。"""
L370     try:
L371         df = yf.download(sym, period=period, interval="1d", auto_adjust=False, progress=False)
L372         if df is None or df.empty:
L373             return None
L374         return df.dropna().assign(
L375             ma20=lambda d: d["Close"].rolling(20).mean(),
L376             ma50=lambda d: d["Close"].rolling(50).mean(),
L377             vol50=lambda d: d["Volume"].rolling(50).mean(),
L378         )
L379     except Exception:
L380         return None
L381
L382
L383 def _scalar(row, col):
L384     """Series/npスカラ→Pythonスカラ化（NaNはNaNのまま）"""
L385     try:
L386         v = row[col]
L387         if hasattr(v, "item"):
L388             try:
L389                 v = v.item()
L390             except Exception:
L391                 pass
L392         return v
L393     except Exception:
L394         return float("nan")
L395
L396
L397 def _is_strict_down(seq):
L398     """数列が厳密に連続で切り下がっているか（len>=4を想定）。NaN含みはFalse。"""
L399     try:
L400         xs = [float(x) for x in seq]
L401         if any(pd.isna(x) for x in xs) or len(xs) < 4:
L402             return False
L403         return all(b < a for a, b in zip(xs[:-1], xs[1:]))
L404     except Exception:
L405         return False
L406
L407
L408 def _signals_for_day(df, idx):
L409     """df.loc[idx] 1日分に対しシグナル配列を返す（値動き/出来高ベースのみ）。"""
L410     try:
L411         sig = []
L412         d = df.loc[idx]
L413         close = _scalar(d, "Close")
L414         ma20 = _scalar(d, "ma20")
L415         ma50 = _scalar(d, "ma50")
L416         vol = _scalar(d, "Volume")
L417         vol50 = _scalar(d, "vol50")
L418
L419         if pd.notna(close) and pd.notna(ma20) and close < ma20:
L420             sig.append("20DMA↓")
L421
L422         if all(pd.notna(x) for x in (close, ma50, vol, vol50)) and close < ma50 and vol > 1.5 * vol50:
L423             sig.append("50DMA↓(大商い)")
L424
L425         last4 = df.loc[:idx].tail(4)
L426         last10 = df.loc[:idx].tail(10)
L427
L428         lows_desc = _is_strict_down(last4["Low"].tolist()) if last4["Low"].notna().all() else False
L429         reds = int((last10["Close"] < last10["Open"]).sum()) if last10[["Close", "Open"]].notna().all().all() else 0
L430         if lows_desc or reds > 5:
L431             sig.append("連続安値/陰線優勢")
L432
L433         ups = int((last10["Close"] > last10["Open"]).sum()) if last10[["Close", "Open"]].notna().all().all() else 0
L434         if ups >= 7:
L435             sig.append("上げ偏重(>70%)")
L436
L437         last15 = df.loc[:idx].tail(15)
L438         base0 = _scalar(last15.iloc[0], "Close") if len(last15) > 0 else float("nan")
L439         if pd.notna(base0) and pd.notna(close) and base0 != 0 and (close / base0 - 1) >= 0.25:
L440             sig.append("+25%/15日内")
L441
L442         if len(df.loc[:idx]) >= 2:
L443             t1, t0 = df.loc[:idx].iloc[-2], df.loc[:idx].iloc[-1]
L444             t1_high = _scalar(t1, "High")
L445             t0_open = _scalar(t0, "Open")
L446             t0_close = _scalar(t0, "Close")
L447             if all(pd.notna(x) for x in (t1_high, t0_open, t0_close)):
L448                 if (t0_open > t1_high * 1.02) and (t0_close < t0_open):
L449                     sig.append("GU→陰線")
L450         return sig
L451     except Exception:
L452         return []
L453
L454
L455 def scan_sell_signals(symbols, lookback_days=5):
L456     """
L457     直近 lookback_days 日のうち一度でもシグナルが出たら {sym: [(date,[signals]),...]} を返す。
L458     日付は YYYY-MM-DD。Slackで列挙する。
L459     """
L460     out = {}
L461     for s in symbols:
L462         df = _yf_df(s)
L463         if df is None or len(df) < 60:
L464             continue
L465         alerts = []
L466         for idx in df.tail(lookback_days).index:
L467             tags = _signals_for_day(df, idx)
L468             if tags:
L469                 alerts.append((idx.strftime("%Y-%m-%d"), tags))
L470         if alerts:
L471             out[s] = alerts
L472     return out
L473
L474
L475 def load_portfolio():
L476     tickers_path = Path(__file__).with_name("current_tickers.csv")
L477     with tickers_path.open() as f:
L478         rows = [row for row in csv.reader(f) if row and row[0].strip()]
L479     n = len(rows)
L480     portfolio = []
L481     for row in rows:
L482         sym = row[0].strip().upper()
L483         qty = int(row[1]) if len(row) > 1 and row[1].strip() else 0
L484         bucket = row[2].strip().upper() if len(row) > 2 else ""
L485         entry = {
L486             "symbol": sym,
L487             "shares": qty,
L488             "target_ratio": 1 / n if n else 0.0,
L489             "bucket": bucket,
L490         }
L491         portfolio.append(entry)
L492     return portfolio
L493
L494
L495 def compute_threshold():
L496     vix_ma5 = fetch_vix_ma5()
L497     drift_threshold = 10 if vix_ma5 < 20 else 12 if vix_ma5 < 26 else float("inf")
L498     return vix_ma5, drift_threshold
L499
L500
L501 def compute_threshold_by_mode(mode: str):
L502     """モードに応じて現金保有率とドリフト閾値を返す（README準拠）"""
L503     m = (mode or "NORMAL").upper()
L504     cash_map = {"NORMAL": 0.10, "CAUTION": 0.125, "EMERG": 0.20}
L505     drift_map = config.DRIFT_THRESHOLD_BY_MODE
L506     return cash_map.get(m, 0.10), drift_map.get(m, 12)
L507
L508
L509 def recommended_counts_by_mode(mode: str) -> tuple[int, int, int]:
L510     """
L511     モード別の推奨保有数 (G_count, D_count, cash_slots) を返す。
L512     cash_slotsは「外すG枠の数」（各枠=5%）。
L513     NORMAL: G12/D8/現金化0, CAUTION: G10/D8/現金化2, EMERG: G8/D8/現金化4
L514     """
L515     m = (mode or "NORMAL").upper()
L516     base = config.COUNTS_BY_MODE.get("NORMAL", config.COUNTS_BASE)
L517     now  = config.COUNTS_BY_MODE.get(m, base)
L518     cash_slots = max(0, base["G"] - now["G"])
L519     return now["G"], now["D"], cash_slots
L520
L521
L522 def build_dataframe(portfolio):
L523     for stock in portfolio:
L524         price = fetch_price(stock["symbol"])
L525         stock["price"] = price
L526         stock["value"] = price * stock["shares"]
L527
L528     df = pd.DataFrame(portfolio)
L529     total_value = df["value"].sum()
L530     df["current_ratio"] = df["value"] / total_value
L531     df["drift"] = df["current_ratio"] - df["target_ratio"]
L532     df["drift_abs"] = df["drift"].abs()
L533     total_drift_abs = df["drift_abs"].sum()
L534     df["adjusted_ratio"] = df["current_ratio"] - df["drift"] / 2
L535     df["adjustable"] = (
L536         (df["adjusted_ratio"] * total_value) >= df["price"]
L537     ) & df["price"].notna() & df["price"].gt(0)
L538     return df, total_value, total_drift_abs
L539
L540
L541 def simulate(df, total_value, total_drift_abs, drift_threshold):
L542     alert = drift_threshold != float("inf") and total_drift_abs * 100 > drift_threshold
L543     if alert:
L544         df["trade_shares"] = df.apply(
L545             lambda r: int(round(((r["adjusted_ratio"] * total_value) - r["value"]) / r["price"]))
L546             if r["adjustable"] and r["price"] > 0 else 0,
L547             axis=1,
L548         )
L549         df["new_shares"] = df["shares"] + df["trade_shares"]
L550         df["new_value"] = df["new_shares"] * df["price"]
L551         new_total_value = df["new_value"].sum()
L552         df["simulated_ratio"] = df["new_value"] / new_total_value
L553         df["simulated_drift_abs"] = (df["simulated_ratio"] - df["target_ratio"]).abs()
L554         simulated_total_drift_abs = df["simulated_drift_abs"].sum()
L555     else:
L556         df["trade_shares"] = np.nan
L557         df["new_shares"] = np.nan
L558         df["new_value"] = np.nan
L559         new_total_value = np.nan
L560         df["simulated_ratio"] = np.nan
L561         df["simulated_drift_abs"] = np.nan
L562         simulated_total_drift_abs = np.nan
L563     return df, alert, new_total_value, simulated_total_drift_abs
L564
L565
L566 def prepare_summary(df, total_drift_abs, alert):
L567     summary = {
L568         "symbol": "合計",
L569         "shares": df["shares"].sum(),
L570         "value": df["value"].sum(),
L571         "current_ratio": np.nan,
L572         "drift_abs": total_drift_abs,
L573     }
L574     if alert:
L575         summary["trade_shares"] = np.nan
L576     # Sort details by evaluation value descending before appending summary
L577     df = df.sort_values(by="value", ascending=False)
L578     df = pd.concat([df, pd.DataFrame([summary])], ignore_index=True)
L579     if alert:
L580         cols = ["symbol", "shares", "value", "current_ratio", "drift_abs", "trade_shares"]
L581         df_small = df[cols].copy()
L582         df_small.columns = ["sym", "qty", "val", "now", "|d|", "Δqty"]
L583     else:
L584         cols = ["symbol", "shares", "value", "current_ratio", "drift_abs"]
L585         df_small = df[cols].copy()
L586         df_small.columns = ["sym", "qty", "val", "now", "|d|"]
L587     return df_small
L588
L589
L590 def currency(x):
L591     return f"${x:,.0f}" if pd.notnull(x) else ""
L592
L593
L594 def formatters_for(alert):
L595     formatters = {"val": currency, "now": "{:.2%}".format, "|d|": "{:.2%}".format}
L596     if alert:
L597         formatters["Δqty"] = "{:.0f}".format
L598     return formatters
L599
L600
L601 def build_header(mode, cash_ratio, drift_threshold, total_drift_abs, alert, simulated_total_drift_abs):
L602     header = (
L603         f"*💼 現金保有率:* {cash_ratio*100:.1f}%\n"
L604         f"*📊 ドリフト閾値:* {'🔴(停止)' if drift_threshold == float('inf') else str(drift_threshold)+'%'}\n"
L605         f"*📉 現在のドリフト合計:* {total_drift_abs * 100:.2f}%\n"
L606     )
L607     if alert:
L608         header += f"*🔁 半戻し後ドリフト合計(想定):* {simulated_total_drift_abs * 100:.2f}%\n"
L609         header += "🚨 *アラート: 発生！！ Δqtyのマイナス銘柄を売却、任意の銘柄を買い増してバランスを取りましょう！*\n"
L610     el
```