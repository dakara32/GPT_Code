```text
etails.sort(key=lambda x: x[4], reverse=True)
L286     today = pd.Timestamp.today(tz="America/New_York").date().isoformat()
L287     print(f"üìù audit[G-CD details] {today}  G={len(g_syms)}")
L288     print("  SYMBOL        Peak60(H)     Low(T)     ratio    DD%")
L289     for sym, peak, low, ratio, ddpct in details:
L290         print(f"  {sym:<8}  {peak:>12.6g}  {low:>10.6g}   {ratio:>6.3f}  {ddpct:>6.2f}")
L291
L292     avg_ratio = float(np.mean([r for _, _, _, r, _ in details]))
L293     gcd_pct = max(0.0, (1.0 - avg_ratio) * 100.0)
L294     mode = "EMERG" if gcd_pct >= CD_EMERG * 100 else "CAUTION" if gcd_pct >= CD_CAUTION * 100 else "NORMAL"
L295     print(
L296         f"üìù audit[G-CD summary]: avg_low/peak60={avg_ratio:.4f}  drawdown={gcd_pct:.2f}%  => {mode}"
L297     )
L298     return mode, gcd_pct
L299 # Debug flag
L300 debug_mode = False  # set to True for detailed output
L301
L302 # --- Finnhub settings & helper ---
L303 FINNHUB_API_KEY = os.environ.get("FINNHUB_API_KEY")
L304 if not FINNHUB_API_KEY:
L305     raise ValueError("FINNHUB_API_KEY not set (Áí∞Â¢ÉÂ§âÊï∞„ÅåÊú™Ë®≠ÂÆö„Åß„Åô)")
L306
L307 RATE_LIMIT = 55  # requests per minute (free tier is 60)
L308 call_times = []
L309
L310
L311 def finnhub_get(endpoint, params):
L312     """Call Finnhub API with basic rate limiting."""
L313     now = time.time()
L314     cutoff = now - 60
L315     while call_times and call_times[0] < cutoff:
L316         call_times.pop(0)
L317     if len(call_times) >= RATE_LIMIT:
L318         sleep_time = 60 - (now - call_times[0])
L319         time.sleep(sleep_time)
L320     params = {**params, "token": FINNHUB_API_KEY}
L321     try:
L322         resp = requests.get(f"https://finnhub.io/api/v1/{endpoint}", params=params)
L323         resp.raise_for_status()
L324         data = resp.json()
L325     except requests.exceptions.JSONDecodeError as e:
L326         print(f"‚ö†Ô∏è Finnhub API JSON decode error: {e}")
L327         return {}
L328     except Exception as e:
L329         print(f"‚ö†Ô∏è Finnhub API error: {e}")
L330         return {}
L331     call_times.append(time.time())
L332     return data
L333
L334
L335 def fetch_price(symbol):
L336     try:
L337         data = finnhub_get("quote", {"symbol": symbol})
L338         price = data.get("c")
L339         return float(price) if price not in (None, 0) else float("nan")
L340     except Exception:
L341         return float("nan")
L342
L343
L344 def fetch_vix_ma5():
L345     """Retrieve VIX 5-day moving average via yfinance."""
L346     try:
L347         vix = (
L348             yf.download("^VIX", period="7d", interval="1d", progress=False, auto_adjust=False)["Close"]
L349             .dropna()
L350             .tail(5)
L351         )
L352         if len(vix) < 5:
L353             return float("nan")
L354         return vix.mean().item()
L355     except Exception:
L356         return float("nan")
L357
L358
L359
L360 # === Minervini-like sell signals ===
L361 def _yf_df(sym, period="6mo"):
L362     """Êó•Ë∂≥/MA/Âá∫Êù•È´òÂπ≥Âùá„ÇíÂèñÂæó„ÄÇÊ¨†ÊêçÊôÇ„ÅØ None„ÄÇ"""
L363     try:
L364         df = yf.download(sym, period=period, interval="1d", auto_adjust=False, progress=False)
L365         if df is None or df.empty:
L366             return None
L367         return df.dropna().assign(
L368             ma20=lambda d: d["Close"].rolling(20).mean(),
L369             ma50=lambda d: d["Close"].rolling(50).mean(),
L370             vol50=lambda d: d["Volume"].rolling(50).mean(),
L371         )
L372     except Exception:
L373         return None
L374
L375
L376 def _scalar(row, col):
L377     """Series/np„Çπ„Ç´„É©‚ÜíPython„Çπ„Ç´„É©ÂåñÔºàNaN„ÅØNaN„ÅÆ„Åæ„ÅæÔºâ"""
L378     try:
L379         v = row[col]
L380         if hasattr(v, "item"):
L381             try:
L382                 v = v.item()
L383             except Exception:
L384                 pass
L385         return v
L386     except Exception:
L387         return float("nan")
L388
L389
L390 def _is_strict_down(seq):
L391     """Êï∞Âàó„ÅåÂé≥ÂØÜ„Å´ÈÄ£Á∂ö„ÅßÂàá„Çä‰∏ã„Åå„Å£„Å¶„ÅÑ„Çã„ÅãÔºàlen>=4„ÇíÊÉ≥ÂÆöÔºâ„ÄÇNaNÂê´„Åø„ÅØFalse„ÄÇ"""
L392     try:
L393         xs = [float(x) for x in seq]
L394         if any(pd.isna(x) for x in xs) or len(xs) < 4:
L395             return False
L396         return all(b < a for a, b in zip(xs[:-1], xs[1:]))
L397     except Exception:
L398         return False
L399
L400
L401 def _signals_for_day(df, idx):
L402     """df.loc[idx] 1Êó•ÂàÜ„Å´ÂØæ„Åó„Ç∑„Ç∞„Éä„É´ÈÖçÂàó„ÇíËøî„ÅôÔºàÂÄ§Âãï„Åç/Âá∫Êù•È´ò„Éô„Éº„Çπ„ÅÆ„ÅøÔºâ„ÄÇ"""
L403     try:
L404         sig = []
L405         d = df.loc[idx]
L406         close = _scalar(d, "Close")
L407         ma20 = _scalar(d, "ma20")
L408         ma50 = _scalar(d, "ma50")
L409         vol = _scalar(d, "Volume")
L410         vol50 = _scalar(d, "vol50")
L411
L412         if pd.notna(close) and pd.notna(ma20) and close < ma20:
L413             sig.append("20DMA‚Üì")
L414
L415         if all(pd.notna(x) for x in (close, ma50, vol, vol50)) and close < ma50 and vol > 1.5 * vol50:
L416             sig.append("50DMA‚Üì(Â§ßÂïÜ„ÅÑ)")
L417
L418         last4 = df.loc[:idx].tail(4)
L419         last10 = df.loc[:idx].tail(10)
L420
L421         lows_desc = _is_strict_down(last4["Low"].tolist()) if last4["Low"].notna().all() else False
L422         reds = int((last10["Close"] < last10["Open"]).sum()) if last10[["Close", "Open"]].notna().all().all() else 0
L423         if lows_desc or reds > 5:
L424             sig.append("ÈÄ£Á∂öÂÆâÂÄ§/Èô∞Á∑öÂÑ™Âã¢")
L425
L426         ups = int((last10["Close"] > last10["Open"]).sum()) if last10[["Close", "Open"]].notna().all().all() else 0
L427         if ups >= 7:
L428             sig.append("‰∏ä„ÅíÂÅèÈáç(>70%)")
L429
L430         last15 = df.loc[:idx].tail(15)
L431         base0 = _scalar(last15.iloc[0], "Close") if len(last15) > 0 else float("nan")
L432         if pd.notna(base0) and pd.notna(close) and base0 != 0 and (close / base0 - 1) >= 0.25:
L433             sig.append("+25%/15Êó•ÂÜÖ")
L434
L435         if len(df.loc[:idx]) >= 2:
L436             t1, t0 = df.loc[:idx].iloc[-2], df.loc[:idx].iloc[-1]
L437             t1_high = _scalar(t1, "High")
L438             t0_open = _scalar(t0, "Open")
L439             t0_close = _scalar(t0, "Close")
L440             if all(pd.notna(x) for x in (t1_high, t0_open, t0_close)):
L441                 if (t0_open > t1_high * 1.02) and (t0_close < t0_open):
L442                     sig.append("GU‚ÜíÈô∞Á∑ö")
L443         return sig
L444     except Exception:
L445         return []
L446
L447
L448 def scan_sell_signals(symbols, lookback_days=5):
L449     """
L450     Áõ¥Ëøë lookback_days Êó•„ÅÆ„ÅÜ„Å°‰∏ÄÂ∫¶„Åß„ÇÇ„Ç∑„Ç∞„Éä„É´„ÅåÂá∫„Åü„Çâ {sym: [(date,[signals]),...]} „ÇíËøî„Åô„ÄÇ
L451     Êó•‰ªò„ÅØ YYYY-MM-DD„ÄÇSlack„ÅßÂàóÊåô„Åô„Çã„ÄÇ
L452     """
L453     out = {}
L454     for s in symbols:
L455         df = _yf_df(s)
L456         if df is None or len(df) < 60:
L457             continue
L458         alerts = []
L459         for idx in df.tail(lookback_days).index:
L460             tags = _signals_for_day(df, idx)
L461             if tags:
L462                 alerts.append((idx.strftime("%Y-%m-%d"), tags))
L463         if alerts:
L464             out[s] = alerts
L465     return out
L466
L467
L468 def load_portfolio():
L469     tickers_path = Path(__file__).with_name("current_tickers.csv")
L470     with tickers_path.open() as f:
L471         rows = [row for row in csv.reader(f) if row and row[0].strip()]
L472     n = len(rows)
L473     portfolio = []
L474     for row in rows:
L475         sym = row[0].strip().upper()
L476         qty = int(row[1]) if len(row) > 1 and row[1].strip() else 0
L477         bucket = row[2].strip().upper() if len(row) > 2 else ""
L478         entry = {
L479             "symbol": sym,
L480             "shares": qty,
L481             "target_ratio": 1 / n if n else 0.0,
L482             "bucket": bucket,
L483         }
L484         portfolio.append(entry)
L485     return portfolio
L486
L487
L488 def compute_threshold():
L489     vix_ma5 = fetch_vix_ma5()
L490     drift_threshold = 10 if vix_ma5 < 20 else 12 if vix_ma5 < 26 else float("inf")
L491     return vix_ma5, drift_threshold
L492
L493
L494 def compute_threshold_by_mode(mode: str):
L495     """„É¢„Éº„Éâ„Å´Âøú„Åò„Å¶ÁèæÈáë‰øùÊúâÁéá„Å®„Éâ„É™„Éï„ÉàÈñæÂÄ§„ÇíËøî„ÅôÔºàREADMEÊ∫ñÊã†Ôºâ"""
L496     m = (mode or "NORMAL").upper()
L497     cash_ratio = config.CASH_RATIO_BY_MODE.get(
L498         m, config.CASH_RATIO_BY_MODE.get("NORMAL", 0.10)
L499     )
L500     drift_threshold = config.DRIFT_THRESHOLD_BY_MODE.get(
L501         m, config.DRIFT_THRESHOLD_BY_MODE.get("NORMAL", 12)
L502     )
L503     return cash_ratio, drift_threshold
L504
L505
L506 def recommended_counts_by_mode(mode: str) -> tuple[int, int, int]:
L507     """
L508     „É¢„Éº„ÉâÂà•„ÅÆÊé®Â•®‰øùÊúâÊï∞ (G_count, D_count, cash_slots) „ÇíËøî„Åô„ÄÇ
L509     cash_slots„ÅØ„ÄåÂ§ñ„ÅôGÊû†„ÅÆÊï∞„ÄçÔºàÂêÑÊû†=5%Ôºâ„ÄÇ
L510     NORMAL: G12/D8/ÁèæÈáëÂåñ0, CAUTION: G10/D8/ÁèæÈáëÂåñ2, EMERG: G8/D8/ÁèæÈáëÂåñ4
L511     """
L512     m = (mode or "NORMAL").upper()
L513     base = config.COUNTS_BY_MODE.get("NORMAL", config.COUNTS_BASE)
L514     now  = config.COUNTS_BY_MODE.get(m, base)
L515     cash_slots = max(0, base["G"] - now["G"])
L516     return now["G"], now["D"], cash_slots
L517
L518
L519 def _mode_tail_line(final_mode: str) -> str:
L520     fm = (final_mode or "NORMAL").upper()
L521     base_ts = config.TS_BASE_BY_MODE.get(fm, config.TS_BASE_BY_MODE.get("NORMAL", 0.15))
L522     ts_base_pct = int(round(base_ts * 100))
L523     d1, d2, d3 = config.TS_STEP_DELTAS_PT
L524     step30 = max(ts_base_pct - d1, 0)
L525     step60 = max(ts_base_pct - d2, 0)
L526     step100 = max(ts_base_pct - d3, 0)
L527     g_cnt, d_cnt, cash_slots = recommended_counts_by_mode(fm)
L528     cash_pct = config.CASH_RATIO_BY_MODE.get(
L529         fm, config.CASH_RATIO_BY_MODE.get("NORMAL", 0.10)
L530     ) * 100
L531     return (
L532         f"„Äî„Åì„ÅÆ„É¢„Éº„Éâ„ÅÆË®≠ÂÆö„Äï"
L533         f"TSÂü∫Êú¨: -{ts_base_pct}%Ôºà+30%‚Üí-{step30}%Ôºè+60%‚Üí-{step60}%Ôºè+100%‚Üí-{step100}%ÔºâÔºè "
L534         f"Êé®Â•®‰øùÊúâ: G{g_cnt}„ÉªD{d_cnt}ÔºàÁèæÈáëÂåñÊû† {cash_slots}ÔºâÔºè "
L535         f"Êé®Â•®ÁèæÈáëÊØîÁéá: {cash_pct:.0f}%"
L536     )
L537
L538
L539 def build_dataframe(portfolio):
L540     for stock in portfolio:
L541         price = fetch_price(stock["symbol"])
L542         stock["price"] = price
L543         stock["value"] = price * stock["shares"]
L544
L545     df = pd.DataFrame(portfolio)
L546     total_value = df["value"].sum()
L547     df["current_ratio"] = df["value"] / total_value
L548     df["drift"] = df["current_ratio"] - df["target_ratio"]
L549     df["drift_abs"] = df["drift"].abs()
L550     total_drift_abs = df["drift_abs"].sum()
L551     df["adjusted_ratio"] = df["current_ratio"] - df["drift"] / 2
L552     df["adjustable"] = (
L553         (df["adjusted_ratio"] * total_value) >= df["price"]
L554     ) & df["price"].notna() & df["price"].gt(0)
L555     return df, total_value, total_drift_abs
L556
L557
L558 def simulate(df, total_value, total_drift_abs, drift_threshold):
L559     alert = drift_threshold != float("inf") and total_drift_abs * 100 > drift_threshold
L560     if alert:
L561         df["trade_shares"] = df.apply(
L562             lambda r: int(round(((r["adjusted_ratio"] * total_value) - r["value"]) / r["price"]))
L563             if r["adjustable"] and r["price"] > 0 else 0,
L564             axis=1,
L565         )
L566         df["new_shares"] = df["shares"] + df["trade_shares"]
L567         df["new_value"] = df["new_shares"] * df["price"]
L568         new_total_value = df["new_value"].sum()
L569         df["simulated_ratio"] = df["new_value"] / new_total_value
L570         df["simulated_drift_abs"] = (df["simulated_ratio"] - df["target_ratio"]).abs()
L571         simulated_total_drift_abs = df["simulated_drift_abs"].sum()
L572     else:
L573         df["trade_shares"] = np.nan
L574         df["new_shares"] = np.nan
L575         df["new_value"] = np.nan
L576         new_total_value = np.nan
L577         df["simulated_ratio"] = np.nan
L578         df["simulated_drift_abs"] = np.nan
L579         simulated_total_drift_abs = np.nan
L580     return df, alert, new_total_value, simulated_total_drift_abs
L581
L582
L583 def prepare_summary(df, total_drift_abs, alert):
L584     summary = {
L585         "symbol": "ÂêàË®à",
L586         "shares": df["shares"].sum(),
L587         "value": df["value"].sum(),
L588         "current_ratio": np.nan,
L589         "drift_abs": total_drift_abs,
L590
```