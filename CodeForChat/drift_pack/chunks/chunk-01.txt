```text
# === Chat Paste Pack ===
# Repo: dakara32/GPT_Code @ main
# Files: config.py, drift.py, .github/workflows/daily-report.yml, documents/README.md, documents/drift_design.md
# 作成日時: 2025-09-26 20:35:47 (JST)
# 使い方: 下のチャンクを順に貼ればこのチャットで全体把握できます。
# 注記: 各ファイルは個別に L1.. で行番号付与。
---

## <config.py>
```text
L1 # 共通設定（factor / drift から参照）
L2 TOTAL_TARGETS = 20
L3
L4 # 基準のバケット数（NORMAL）
L5 COUNTS_BASE = {"G": 12, "D": 8}
L6
L7 # モード別の推奨バケット数
L8 COUNTS_BY_MODE = {
L9     "NORMAL": {"G": 12, "D": 8},
L10     "CAUTION": {"G": 10, "D": 8},
L11     "EMERG": {"G": 8,  "D": 8},
L12 }
L13
L14 # モード別のドリフト閾値（%）
L15 DRIFT_THRESHOLD_BY_MODE = {"NORMAL": 12, "CAUTION": 14, "EMERG": float("inf")}
L16
L17 # モード別の推奨現金比率
L18 CASH_RATIO_BY_MODE = {
L19     "NORMAL": 0.10,  # 10%
L20     "CAUTION": 0.20,  # 20%
L21     "EMERG": 0.30,  # 30%
L22 }
L23
L24 # モード別のTS（基本幅, 小数=割合）
L25 TS_BASE_BY_MODE = {"NORMAL": 0.15, "CAUTION": 0.13, "EMERG": 0.10}
L26 # 利益到達(+30/+60/+100%)時の段階タイト化（ポイント差）
L27 TS_STEP_DELTAS_PT = (3, 6, 8)
L28
L29 # Breadthの校正は N_G に連動（緊急解除=ceil(1.5*N_G), 通常復帰=3*N_G）
L30 N_G = COUNTS_BASE["G"]
L31 N_D = COUNTS_BASE["D"]
L32
```

## <drift.py>
```text
L1 import pandas as pd, yfinance as yf
L2 import numpy as np
L3 import requests
L4 import os
L5 import json
L6 import time
L7 from pathlib import Path
L8 import csv
L9 import config
L10
L11 # --- GコンポジットDDのしきい値（Growthの平均DD基準）---
L12 CD_CAUTION = 0.10   # -10% で警戒
L13 CD_EMERG = 0.15   # -15% で緊急
L14
L15 MODE_LABELS_JA = {"NORMAL": "通常", "CAUTION": "警戒", "EMERG": "緊急"}
L16 MODE_EMOJIS = {"NORMAL": "🟢", "CAUTION": "⚠️", "EMERG": "🚨"}
L17 MODE_RANK = {"NORMAL": 0, "CAUTION": 1, "EMERG": 2}
L18
L19 # --- breadth utilities (factor parity) ---
L20 BENCH = "^GSPC"
L21 CAND_PRICE_MAX = 450.0
L22 RESULTS_DIR = "results"
L23 os.makedirs(RESULTS_DIR, exist_ok=True)
L24
L25 def _state_file():
L26     return str(Path(RESULTS_DIR) / "breadth_state.json")
L27
L28
L29 def _load_state_dict() -> dict:
L30     try:
L31         with open(_state_file()) as fh:
L32             data = json.load(fh)
L33         return data if isinstance(data, dict) else {}
L34     except Exception:
L35         return {}
L36
L37
L38 def _save_state_dict(state: dict):
L39     try:
L40         with open(_state_file(), "w") as fh:
L41             json.dump(state, fh)
L42     except Exception:
L43         pass
L44
L45
L46 def load_breadth_mode(default: str = "NORMAL") -> str:
L47     state = _load_state_dict()
L48     mode = state.get("breadth_mode", state.get("mode", default))
L49     return mode if mode in MODE_RANK else default
L50
L51
L52 def save_breadth_mode(mode: str):
L53     state = _load_state_dict()
L54     state["breadth_mode"] = mode
L55     _save_state_dict(state)
L56
L57
L58 def load_final_mode(default: str = "NORMAL") -> str:
L59     state = _load_state_dict()
L60     mode = state.get("final_mode", state.get("mode", default))
L61     return mode if mode in MODE_RANK else default
L62
L63
L64 def save_final_mode(mode: str):
L65     state = _load_state_dict()
L66     state["final_mode"] = mode
L67     state.setdefault("breadth_mode", state.get("breadth_mode", mode))
L68     state["mode"] = mode
L69     _save_state_dict(state)
L70
L71
L72 def _read_csv_list(fname):
L73     p = Path(__file__).with_name(fname)
L74     if not p.exists(): return []
L75     return pd.read_csv(p, header=None).iloc[:,0].astype(str).str.upper().tolist()
L76
L77
L78 def _load_universe():
L79     # exist + candidate を使用。candidate は価格上限で事前フィルタ
L80     exist = _read_csv_list("current_tickers.csv")
L81     cand  = _read_csv_list("candidate_tickers.csv")
L82     cand_info = yf.Tickers(" ".join(cand)) if cand else None
L83     cand_keep = []
L84     for t in cand:
L85         try:
L86             px = cand_info.tickers[t].fast_info.get("lastPrice", float("inf"))
L87         except Exception:
L88             px = float("inf")
L89         if pd.notna(px) and float(px) <= CAND_PRICE_MAX:
L90             cand_keep.append(t)
L91     tickers = sorted(set(exist + cand_keep))
L92     return exist, cand_keep, tickers
L93
L94
L95 def _fetch_prices_600d(tickers):
L96     data = yf.download(
L97         tickers + [BENCH],
L98         period="600d",
L99         auto_adjust=True,
L100         progress=False,
L101         threads=False,
L102     )
L103     close = data["Close"]
L104     px = close.dropna(how="all", axis=1).ffill(limit=2)
L105     spx = close[BENCH].reindex(px.index).ffill()
L106     return px, spx
L107
L108
L109 def trend_template_breadth_series(px: pd.DataFrame, spx: pd.Series, win_days: int | None = None) -> pd.Series:
L110     # scorer.py の実装をそのまま移植（ベクトル化版）
L111     import numpy as np, pandas as pd
L112     if px is None or px.empty:
L113         return pd.Series(dtype=int)
L114     px = px.dropna(how="all", axis=1)
L115     if win_days and win_days > 0:
L116         px = px.tail(win_days)
L117     if px.empty:
L118         return pd.Series(dtype=int)
L119     # 欠損吸収
L120     px = px.ffill(limit=2)
L121     spx = spx.reindex(px.index).ffill()
L122
L123     ma50  = px.rolling(50,  min_periods=50).mean()
L124     ma150 = px.rolling(150, min_periods=150).mean()
L125     ma200 = px.rolling(200, min_periods=200).mean()
L126
L127     tt = (px > ma150)
L128     tt &= (px > ma200)
L129     tt &= (ma150 > ma200)
L130     tt &= (ma200 - ma200.shift(21) > 0)
L131     tt &= (ma50  > ma150)
L132     tt &= (ma50  > ma200)
L133     tt &= (px    > ma50)
L134
L135     lo252 = px.rolling(252, min_periods=252).min()
L136     hi252 = px.rolling(252, min_periods=252).max()
L137     tt &= (px.divide(lo252).sub(1.0) >= 0.30)
L138     tt &= (px >= (0.75 * hi252))
L139
L140     r12  = px.divide(px.shift(252)).sub(1.0)
L141     br12 = spx.divide(spx.shift(252)).sub(1.0)
L142     r1   = px.divide(px.shift(22)).sub(1.0)
L143     br1  = spx.divide(spx.shift(22)).sub(1.0)
L144     rs   = 0.7*(r12.sub(br12, axis=0)) + 0.3*(r1.sub(br1, axis=0))
L145     tt &= (rs >= 0.10)
L146
L147     return tt.fillna(False).sum(axis=1).astype(int)
L148
L149
L150 def build_breadth_header():
L151     # factor._build_breadth_lead_lines と同一挙動
L152     exist, cand, tickers = _load_universe()
L153     if not tickers:
L154         return "", "NORMAL", 0
L155     px, spx = _fetch_prices_600d(tickers)
L156     win = int(os.getenv("BREADTH_CALIB_WIN_DAYS", "600"))
L157     C_ts = trend_template_breadth_series(px, spx, win_days=win)
L158     if C_ts.empty:
L159         return "", "NORMAL", 0
L160     warmup = int(os.getenv("BREADTH_WARMUP_DAYS","252"))
L161     base = C_ts.iloc[warmup:] if len(C_ts)>warmup else C_ts
L162     C_full = int(C_ts.iloc[-1])
L163
L164     q05 = int(np.nan_to_num(base.quantile(float(os.getenv("BREADTH_Q_EMERG_IN",  "0.05"))), nan=0.0))
L165     q20 = int(np.nan_to_num(base.quantile(float(os.getenv("BREADTH_Q_EMERG_OUT", "0.20"))), nan=0.0))
L166     q60 = int(np.nan_to_num(base.quantile(float(os.getenv("BREADTH_Q_WARN_OUT",  "0.60"))), nan=0.0))
L167
L168     # G枠サイズ（Breadth基準）
L169     N_G = config.N_G
L170     th_in_rec   = max(N_G, q05)
L171     th_out_rec  = max(int(np.ceil(1.5*N_G)), q20)
L172     th_norm_rec = max(3*N_G, q60)
L173
L174     use_calib = os.getenv("BREADTH_USE_CALIB", "true").strip().lower() == "true"
L175     if use_calib:
L176         th_in, th_out, th_norm, th_src = th_in_rec, th_out_rec, th_norm_rec, "自動"
L177     else:
L178         th_in   = int(os.getenv("GTT_EMERG_IN", str(N_G)))
L179         th_out  = int(os.getenv("GTT_EMERG_OUT", str(int(1.5*N_G))))
L180         th_norm = int(os.getenv("GTT_CAUTION_OUT", str(3*N_G)))
L181         th_src = "手動"
L182
L183     prev = load_breadth_mode("NORMAL")
L184     if   prev == "EMERG":
L185         mode = "EMERG"   if (C_full < th_out)  else ("CAUTION" if (C_full < th_norm) else "NORMAL")
L186     elif prev == "CAUTION":
L187         mode = "CAUTION" if (C_full < th_norm) else "NORMAL"
L188     else:
L189         mode = "EMERG"   if (C_full < th_in)   else ("CAUTION" if (C_full < th_norm) else "NORMAL")
L190     save_breadth_mode(mode)
L191
L192     mode_ja, emoji = MODE_LABELS_JA.get(mode, mode), MODE_EMOJIS.get(mode, "ℹ️")
L193     eff_days = len(base)
L194
L195     lead_lines = [
L196         f"{emoji} *現在モード: {mode_ja}*",
L197         f"テンプレ合格本数: *{C_full}本*",
L198         "しきい値（{0}）".format(th_src),
L199         f"  ・緊急入り: <{th_in}本",
L200         f"  ・緊急解除: ≥{th_out}本",
L201         f"  ・通常復帰: ≥{th_norm}本",
L202         f"参考指標（過去~{win}営業日, 有効={eff_days}日）",
L203         f"  ・下位5%: {q05}本",
L204         f"  ・下位20%: {q20}本",
L205         f"  ・60%分位: {q60}本",
L206     ]
L207     return "```" + "\n".join(lead_lines) + "```", mode, C_full
L208
L209
L210 def _load_growth_symbols(portfolio: list[dict]) -> list[str]:
L211     growth = []
L212     for row in portfolio:
L213         bucket = str(row.get("bucket", "")).strip().upper()
L214         if bucket == "G":
L215             sym = str(row.get("symbol", "")).strip().upper()
L216             if sym:
L217                 growth.append(sym)
L218     return sorted(set(growth))
L219
L220
L221 def _format_mode(mode: str) -> str:
L222     upper = (mode or "NORMAL").upper()
L223     return f"{MODE_EMOJIS.get(upper, 'ℹ️')} {MODE_LABELS_JA.get(upper, upper)}"
L224
L225
L226 def _gcd_mode_today(g_syms: list[str]) -> tuple[str, float]:
L227     """
L228     現在のGrowth群について、Low_today / Peak60(High) の等加重平均から G-CD(%) を算出し、モードを返す。
L229     戻り値: (gcd_mode, gcd_pct)  ※gcd_pctは正の%（例 11.3 は -11.3%の下落）
L230     """
L231
L232     if not g_syms:
L233         print("📝 audit[G-CD details]: G銘柄が空のため算出対象がありません")
L234         print("📝 audit[G-CD summary]: avg_low/peak60=1.0000  drawdown=0.00%  => NORMAL")
L235         return "NORMAL", 0.0
L236
L237     try:
L238         df = yf.download(
L239             g_syms,
L240             period="100d",
L241             interval="1d",
L242             auto_adjust=False,
L243             progress=False,
L244         )
L245     except Exception as e:
L246         print(f"⚠️ audit[G-CD details]: 株価データ取得に失敗しました ({e})")
L247         print("📝 audit[G-CD summary]: avg_low/peak60=1.0000  drawdown=0.00%  => NORMAL")
L248         return "NORMAL", 0.0
L249
L250     if not isinstance(df, pd.DataFrame) or df.empty:
L251         print("⚠️ audit[G-CD details]: 株価データが空のため算出できません")
L252         print("📝 audit[G-CD summary]: avg_low/peak60=1.0000  drawdown=0.00%  => NORMAL")
L253         return "NORMAL", 0.0
L254
L255     hi_all = df.get("High") if isinstance(df, pd.DataFrame) else None
L256     lo_all = df.get("Low") if isinstance(df, pd.DataFrame) else None
L257     if hi_all is None or lo_all is None:
L258         print("⚠️ audit[G-CD details]: High/Low データが欠落しています")
L259         print("📝 audit[G-CD summary]: avg_low/peak60=1.0000  drawdown=0.00%  => NORMAL")
L260         return "NORMAL", 0.0
L261
L262     if isinstance(hi_all, pd.Series):
L263         hi_all = hi_all.to_frame(name=g_syms[0])
L264     if isinstance(lo_all, pd.Series):
L265         lo_all = lo_all.to_frame(name=g_syms[0])
L266
L267     if hi_all.empty or lo_all.empty:
L268         print("⚠️ audit[G-CD details]: High/Low データが空のため算出できません")
L269         print("📝 audit[G-CD summary]: avg_low/peak60=1.0000  drawdown=0.00%  => NORMAL")
L270         return "NORMAL", 0.0
L271
L272     peak60 = hi_all.rolling(60, min_periods=20).max().tail(1).iloc[0]
L273     low_today = lo_all.tail(1).iloc[0]
L274
L275     details: list[tuple[str, float, float, float, float]] = []
L276     for sym in g_syms:
L277         p = float(peak60.get(sym, float("nan"))) if hasattr(peak60, "get") else float("nan")
L278         lt = float(low_today.get(sym, float("nan"))) if hasattr(low_today, "get") else float("nan")
L279         if pd.notna(p) and p > 0 and pd.notna(lt) and lt > 0:
L280             ratio = lt / p
L281             ddpct = (1.0 - ratio) * 100.0
L282             details.append((sym, p, lt, ratio, ddpct))
L283
L284     if not details:
L285         print("⚠️ audit[G-CD details]: 有効な銘柄データがありません")
L286         print("📝 audit[G-CD summary]: avg_low/peak60=1.0000  drawdown=0.00%
```