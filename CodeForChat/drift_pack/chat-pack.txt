# === Chat Paste Pack ===
# Repo: dakara32/GPT_Code @ main
# Files: drift.py, .github/workflows/daily-report.yml, documents/README.md, documents/drift_design.md
# 使い方: 下のチャンクを順に貼ればこのチャットで全体把握できます。
# 注記: 各ファイルは個別に L1.. で行番号付与。
---

## <drift.py>
```text
L1 import pandas as pd, yfinance as yf
L2 import numpy as np
L3 import requests
L4 import os
L5 import csv
L6 import json
L7 import time
L8 from pathlib import Path
L9
L10 # --- breadth utilities (factor parity) ---
L11 BENCH = "^GSPC"
L12 CAND_PRICE_MAX = 450.0
L13 RESULTS_DIR = "results"
L14 os.makedirs(RESULTS_DIR, exist_ok=True)
L15
L16
L17 def _state_file():
L18     return str(Path(RESULTS_DIR) / "breadth_state.json")
L19
L20
L21 def load_mode(default="NORMAL"):
L22     try:
L23         m = json.loads(open(_state_file()).read()).get("mode", default)
L24         return m if m in ("EMERG","CAUTION","NORMAL") else default
L25     except Exception:
L26         return default
L27
L28
L29 def save_mode(mode: str):
L30     try:
L31         open(_state_file(),"w").write(json.dumps({"mode": mode}))
L32     except Exception:
L33         pass
L34
L35
L36 def _read_csv_list(fname):
L37     p = Path(__file__).with_name(fname)
L38     if not p.exists(): return []
L39     return pd.read_csv(p, header=None).iloc[:,0].astype(str).str.upper().tolist()
L40
L41
L42 def _load_universe():
L43     # exist + candidate を使用。candidate は価格上限で事前フィルタ
L44     exist = _read_csv_list("current_tickers.csv")
L45     cand  = _read_csv_list("candidate_tickers.csv")
L46     cand_info = yf.Tickers(" ".join(cand)) if cand else None
L47     cand_keep = []
L48     for t in cand:
L49         try:
L50             px = cand_info.tickers[t].fast_info.get("lastPrice", float("inf"))
L51         except Exception:
L52             px = float("inf")
L53         if pd.notna(px) and float(px) <= CAND_PRICE_MAX:
L54             cand_keep.append(t)
L55     tickers = sorted(set(exist + cand_keep))
L56     return exist, cand_keep, tickers
L57
L58
L59 def _fetch_prices_600d(tickers):
L60     data = yf.download(tickers + [BENCH], period="600d", auto_adjust=True, progress=False)
L61     px   = data["Close"].dropna(how="all", axis=1)
L62     spx  = data["Close"][BENCH].dropna()
L63     return px, spx
L64
L65
L66 def trend_template_breadth_series(px: pd.DataFrame, spx: pd.Series, win_days: int | None = None) -> pd.Series:
L67     # scorer.py の実装をそのまま移植（ベクトル化版）
L68     import numpy as np, pandas as pd
L69     if px is None or px.empty:
L70         return pd.Series(dtype=int)
L71     px = px.dropna(how="all", axis=1)
L72     if win_days and win_days > 0:
L73         px = px.tail(win_days)
L74     if px.empty:
L75         return pd.Series(dtype=int)
L76     spx = spx.reindex(px.index).ffill()
L77
L78     ma50  = px.rolling(50).mean()
L79     ma150 = px.rolling(150).mean()
L80     ma200 = px.rolling(200).mean()
L81
L82     tt = (px > ma150)
L83     tt &= (px > ma200)
L84     tt &= (ma150 > ma200)
L85     tt &= (ma200 - ma200.shift(21) > 0)
L86     tt &= (ma50  > ma150)
L87     tt &= (ma50  > ma200)
L88     tt &= (px    > ma50)
L89
L90     lo252 = px.rolling(252).min()
L91     hi252 = px.rolling(252).max()
L92     tt &= (px.divide(lo252).sub(1.0) >= 0.30)
L93     tt &= (px >= (0.75 * hi252))
L94
L95     r12  = px.divide(px.shift(252)).sub(1.0)
L96     br12 = spx.divide(spx.shift(252)).sub(1.0)
L97     r1   = px.divide(px.shift(22)).sub(1.0)
L98     br1  = spx.divide(spx.shift(22)).sub(1.0)
L99     rs   = 0.7*(r12.sub(br12, axis=0)) + 0.3*(r1.sub(br1, axis=0))
L100     tt &= (rs >= 0.10)
L101
L102     return tt.fillna(False).sum(axis=1).astype(int)
L103
L104
L105 def build_breadth_header():
L106     # factor._build_breadth_lead_lines と同一挙動
L107     exist, cand, tickers = _load_universe()
L108     if not tickers:
L109         return "", "NORMAL", 0
L110     px, spx = _fetch_prices_600d(tickers)
L111     win = int(os.getenv("BREADTH_CALIB_WIN_DAYS", "600"))
L112     C_ts = trend_template_breadth_series(px, spx, win_days=win)
L113     if C_ts.empty:
L114         return "", "NORMAL", 0
L115     warmup = int(os.getenv("BREADTH_WARMUP_DAYS","252"))
L116     base = C_ts.iloc[warmup:] if len(C_ts)>warmup else C_ts
L117     C_full = int(C_ts.iloc[-1])
L118
L119     q05 = int(np.nan_to_num(base.quantile(float(os.getenv("BREADTH_Q_EMERG_IN",  "0.05"))), nan=0.0))
L120     q20 = int(np.nan_to_num(base.quantile(float(os.getenv("BREADTH_Q_EMERG_OUT", "0.20"))), nan=0.0))
L121     q60 = int(np.nan_to_num(base.quantile(float(os.getenv("BREADTH_Q_WARN_OUT",  "0.60"))), nan=0.0))
L122
L123     N_G = 12
L124     th_in_rec   = max(N_G, q05)
L125     th_out_rec  = max(int(np.ceil(1.5*N_G)), q20)
L126     th_norm_rec = max(3*N_G, q60)
L127
L128     use_calib = os.getenv("BREADTH_USE_CALIB", "true").strip().lower() == "true"
L129     if use_calib:
L130         th_in, th_out, th_norm, th_src = th_in_rec, th_out_rec, th_norm_rec, "自動"
L131     else:
L132         th_in   = int(os.getenv("GTT_EMERG_IN", str(N_G)))
L133         th_out  = int(os.getenv("GTT_EMERG_OUT", str(int(1.5*N_G))))
L134         th_norm = int(os.getenv("GTT_CAUTION_OUT", str(3*N_G)))
L135         th_src = "手動"
L136
L137     prev = load_mode("NORMAL")
L138     if   prev == "EMERG":
L139         mode = "EMERG"   if (C_full < th_out)  else ("CAUTION" if (C_full < th_norm) else "NORMAL")
L140     elif prev == "CAUTION":
L141         mode = "CAUTION" if (C_full < th_norm) else "NORMAL"
L142     else:
L143         mode = "EMERG"   if (C_full < th_in)   else ("CAUTION" if (C_full < th_norm) else "NORMAL")
L144     save_mode(mode)
L145
L146     _MODE_JA   = {"EMERG":"緊急","CAUTION":"警戒","NORMAL":"通常"}
L147     _MODE_EMOJI= {"EMERG":"🚨","CAUTION":"⚠️","NORMAL":"🟢"}
L148     mode_ja, emoji = _MODE_JA.get(mode,mode), _MODE_EMOJI.get(mode,"ℹ️")
L149     eff_days = len(base)
L150
L151     lead_lines = [
L152         f"{emoji} *現在モード: {mode_ja}*",
L153         f"テンプレ合格本数: *{C_full}本*",
L154         "しきい値（{0}）".format(th_src),
L155         f"  ・緊急入り: <{th_in}本",
L156         f"  ・緊急解除: ≥{th_out}本",
L157         f"  ・通常復帰: ≥{th_norm}本",
L158         f"参考指標（過去~{win}営業日, 有効={eff_days}日）",
L159         f"  ・下位5%: {q05}本",
L160         f"  ・下位20%: {q20}本",
L161         f"  ・60%分位: {q60}本",
L162     ]
L163     return "```" + "\n".join(lead_lines) + "```", mode, C_full
L164 # Debug flag
L165 debug_mode = False  # set to True for detailed output
L166
L167 # --- Finnhub settings & helper ---
L168 FINNHUB_API_KEY = os.environ.get("FINNHUB_API_KEY")
L169 if not FINNHUB_API_KEY:
L170     raise ValueError("FINNHUB_API_KEY not set (環境変数が未設定です)")
L171
L172 RATE_LIMIT = 55  # requests per minute (free tier is 60)
L173 call_times = []
L174
L175
L176 def finnhub_get(endpoint, params):
L177     """Call Finnhub API with basic rate limiting."""
L178     now = time.time()
L179     cutoff = now - 60
L180     while call_times and call_times[0] < cutoff:
L181         call_times.pop(0)
L182     if len(call_times) >= RATE_LIMIT:
L183         sleep_time = 60 - (now - call_times[0])
L184         time.sleep(sleep_time)
L185     params = {**params, "token": FINNHUB_API_KEY}
L186     try:
L187         resp = requests.get(f"https://finnhub.io/api/v1/{endpoint}", params=params)
L188         resp.raise_for_status()
L189         data = resp.json()
L190     except requests.exceptions.JSONDecodeError as e:
L191         print(f"⚠️ Finnhub API JSON decode error: {e}")
L192         return {}
L193     except Exception as e:
L194         print(f"⚠️ Finnhub API error: {e}")
L195         return {}
L196     call_times.append(time.time())
L197     return data
L198
L199
L200 def fetch_price(symbol):
L201     try:
L202         data = finnhub_get("quote", {"symbol": symbol})
L203         price = data.get("c")
L204         return float(price) if price not in (None, 0) else float("nan")
L205     except Exception:
L206         return float("nan")
L207
L208
L209 def fetch_vix_ma5():
L210     """Retrieve VIX 5-day moving average via yfinance."""
L211     try:
L212         vix = (
L213             yf.download("^VIX", period="7d", interval="1d", progress=False, auto_adjust=False)["Close"]
L214             .dropna()
L215             .tail(5)
L216         )
L217         if len(vix) < 5:
L218             return float("nan")
L219         return vix.mean().item()
L220     except Exception:
L221         return float("nan")
L222
L223
L224
L225 # === Minervini-like sell signals ===
L226 def _yf_df(sym, period="6mo"):
L227     """日足/MA/出来高平均を取得。欠損時は None。"""
L228     try:
L229         df = yf.download(sym, period=period, interval="1d", auto_adjust=False, progress=False)
L230         if df is None or df.empty:
L231             return None
L232         return df.dropna().assign(
L233             ma20=lambda d: d["Close"].rolling(20).mean(),
L234             ma50=lambda d: d["Close"].rolling(50).mean(),
L235             vol50=lambda d: d["Volume"].rolling(50).mean(),
L236         )
L237     except Exception:
L238         return None
L239
L240
L241 def _scalar(row, col):
L242     """Series/npスカラ→Pythonスカラ化（NaNはNaNのまま）"""
L243     try:
L244         v = row[col]
L245         if hasattr(v, "item"):
L246             try:
L247                 v = v.item()
L248             except Exception:
L249                 pass
L250         return v
L251     except Exception:
L252         return float("nan")
L253
L254
L255 def _is_strict_down(seq):
L256     """数列が厳密に連続で切り下がっているか（len>=4を想定）。NaN含みはFalse。"""
L257     try:
L258         xs = [float(x) for x in seq]
L259         if any(pd.isna(x) for x in xs) or len(xs) < 4:
L260             return False
L261         return all(b < a for a, b in zip(xs[:-1], xs[1:]))
L262     except Exception:
L263         return False
L264
L265
L266 def _signals_for_day(df, idx):
L267     """df.loc[idx] 1日分に対しシグナル配列を返す（値動き/出来高ベースのみ）。"""
L268     try:
L269         sig = []
L270         d = df.loc[idx]
L271         close = _scalar(d, "Close")
L272         open_ = _scalar(d, "Open")
L273         ma20 = _scalar(d, "ma20")
L274         ma50 = _scalar(d, "ma50")
L275         vol = _scalar(d, "Volume")
L276         vol50 = _scalar(df.iloc[-1], "vol50")
L277         if any(pd.isna(x) for x in (close, open_, vol, vol50)):
L278             return sig
L279         if pd.notna(ma20) and close < ma20:
L280             sig.append("20DMA↓")
L281         if pd.notna(ma50) and close < ma50 and vol > 1.5 * vol50:
L282             sig.append("50DMA↓(大商い)")
L283
L284         last4 = df.loc[:idx].tail(4)
L285         lows_desc = _is_strict_down(last4["Low"].tolist())
L286         last10 = df.loc[:idx].tail(10)
L287         reds = int((last10["Close"] < last10["Open"]).sum())
L288         if lows_desc or reds > 5:
L289             sig.append("連続安値/陰線優勢")
L290
L291         ups = int((last10["Close"] > last10["Open"]).sum())
L292         if ups >= 7:
L293             sig.append("上げ偏重(>70%)")
L294
L295         last15 = df.loc[:idx].tail(15)
L296         base0 = _scalar(last15.iloc[0], "Close") if len(last15) > 0 else float("nan")
L297         if pd.notna(base0) and base0 != 0 and (close / base0 - 1) >= 0.25:
L298             sig.append("+25%/15日内")
L299
L300         if len(df.loc[:idx]) >= 2:
L301             t1, t0 = df.loc[:idx].iloc[-2], df.loc[:idx].iloc[-1]
L302             t1_high = _scalar(t1, "High")
L303             t0_open = _scalar(t0, "Open")
L304             t0_close = _scalar(t0, "Close")
L305             if all(pd.notna(x) for x in (t1_high, t0_open, t0_close)):
L306                 if (t0_open > t1_high * 1.02) and (t0_close < t0_open):
L307                     sig.append("GU→陰線")
L308         return sig
L309     except Exception:
L310         return []
L311
L312
L313 def scan_sell_signals(symbols, lookback_days=5):
L314     """
L315     直近 lookback_days 日のうち一度でもシグナルが出たら {sym: [(date,[signals]),...]} を返す。
L316     日付は YYYY-MM-DD。Slackで列挙する。
L317     """
L318     out = {}
L319     for s in symbols:
L320         df = _yf_df(s)
L321         if df is None or len(df) < 60:
L322             continue
L323         alerts = []
L324         for idx in df.tail(lookback_days).index:
L325             tags = _signals_for_day(df, idx)
L326             if tags:
L327                 alerts.append((idx.strftime("%Y-%m-%d"), tags))
L328         if alerts:
L329             out[s] = alerts
L330     return out
L331
L332
L333 def load_portfolio():
L334     tickers_path = Path(__file__).with_name("current_tickers.csv")
L335     with tickers_path.open() as f:
L336         reader = list(csv.reader(f))
L337     return [
L338         {"symbol": sym.strip().upper(), "shares": int(qty), "target_ratio": 1 / len(reader)}
L339         for sym, qty in reader
L340     ]
L341
L342
L343 def compute_threshold():
L344     vix_ma5 = fetch_vix_ma5()
L345     drift_threshold = 10 if vix_ma5 < 20 else 12 if vix_ma5 < 26 else float("inf")
L346     return vix_ma5, drift_threshold
L347
L348
L349 def build_dataframe(portfolio):
L350     for stock in portfolio:
L351         price = fetch_price(stock["symbol"])
L352         stock["price"] = price
L353         stock["value"] = price * stock["shares"]
L354
L355     df = pd.DataFrame(portfolio)
L356     total_value = df["value"].sum()
L357     df["current_ratio"] = df["value"] / total_value
L358     df["drift"] = df["current_ratio"] - df["target_ratio"]
L359     df["drift_abs"] = df["drift"].abs()
L360     total_drift_abs = df["drift_abs"].sum()
L361     df["adjusted_ratio"] = df["current_ratio"] - df["drift"] / 2
L362     df["adjustable"] = (
L363         (df["adjusted_ratio"] * total_value) >= df["price"]
L364     ) & df["price"].notna() & df["price"].gt(0)
L365     return df, total_value, total_drift_abs
L366
L367
L368 def simulate(df, total_value, total_drift_abs, drift_threshold):
L369     alert = drift_threshold != float("inf") and total_drift_abs * 100 > drift_threshold
L370     if alert:
L371         df["trade_shares"] = df.apply(
L372             lambda r: int(round(((r["adjusted_ratio"] * total_value) - r["value"]) / r["price"]))
L373             if r["adjustable"] and r["price"] > 0 else 0,
L374             axis=1,
L375         )
L376         df["new_shares"] = df["shares"] + df["trade_shares"]
L377         df["new_value"] = df["new_shares"] * df["price"]
L378         new_total_value = df["new_value"].sum()
L379         df["simulated_ratio"] = df["new_value"] / new_total_value
L380         df["simulated_drift_abs"] = (df["simulated_ratio"] - df["target_ratio"]).abs()
L381         simulated_total_drift_abs = df["simulated_drift_abs"].sum()
L382     else:
L383         df["trade_shares"] = np.nan
L384         df["new_shares"] = np.nan
L385         df["new_value"] = np.nan
L386         new_total_value = np.nan
L387         df["simulated_ratio"] = np.nan
L388         df["simulated_drift_abs"] = np.nan
L389         simulated_total_drift_abs = np.nan
L390     return df, alert, new_total_value, simulated_total_drift_abs
L391
L392
L393 def prepare_summary(df, total_drift_abs, alert):
L394     summary = {
L395         "symbol": "合計",
L396         "shares": df["shares"].sum(),
L397         "value": df["value"].sum(),
L398         "current_ratio": np.nan,
L399         "drift_abs": total_drift_abs,
L400     }
L401     if alert:
L402         summary["trade_shares"] = np.nan
L403     # Sort details by evaluation value descending before appending summary
L404     df = df.sort_values(by="value", ascending=False)
L405     df = pd.concat([df, pd.DataFrame([summary])], ignore_index=True)
L406     if alert:
L407         cols = ["symbol", "shares", "value", "current_ratio", "drift_abs", "trade_shares"]
L408         df_small = df[cols].copy()
L409         df_small.columns = ["sym", "qty", "val", "now", "|d|", "Δqty"]
L410     else:
L411         cols = ["symbol", "shares", "value", "current_ratio", "drift_abs"]
L412         df_small = df[cols].copy()
L413         df_small.columns = ["sym", "qty", "val", "now", "|d|"]
L414     return df_small
L415
L416
L417 def currency(x):
L418     return f"${x:,.0f}" if pd.notnull(x) else ""
L419
L420
L421 def formatters_for(alert):
L422     formatters = {"val": currency, "now": "{:.2%}".format, "|d|": "{:.2%}".format}
L423     if alert:
L424         formatters["Δqty"] = "{:.0f}".format
L425     return formatters
L426
L427
L428 def build_header(vix_ma5, drift_threshold, total_drift_abs, alert, simulated_total_drift_abs):
L429     header = (
L430         f"*📈 VIX MA5:* {vix_ma5:.2f}\n"
L431         f"*📊 ドリフト閾値:* {'🔴(高VIX)' if drift_threshold == float('inf') else str(drift_threshold)+'%'}\n"
L432         f"*📉 現在のドリフト合計:* {total_drift_abs * 100:.2f}%\n"
L433     )
L434     if alert:
L435         header += f"*🔁 半戻し後ドリフト合計(想定):* {simulated_total_drift_abs * 100:.2f}%\n"
L436         header += "🚨 *アラート: 発生！！ Δqtyのマイナス銘柄を売却、任意の銘柄を買い増してバランスを取りましょう！*\n"
L437     else:
L438         header += "✅ アラートなし\n"
L439     return header
L440
L441
L442 def send_slack(text):
L443     SLACK_WEBHOOK_URL = os.environ.get("SLACK_WEBHOOK_URL")
L444     if not SLACK_WEBHOOK_URL:
L445         raise ValueError("SLACK_WEBHOOK_URL not set (環境変数が未設定です)")
L446     payload = {"text": text}
L447     try:
L448         resp = requests.post(SLACK_WEBHOOK_URL, json=payload)
L449         resp.raise_for_status()
L450         print("✅ Slack（Webhook）へ送信しました")
L451     except Exception as e:
L452         print(f"⚠️ Slack通知エラー: {e}")
L453
L454
L455 def send_debug(debug_text):
L456     SLACK_WEBHOOK_URL = os.environ.get("SLACK_WEBHOOK_URL")
L457     if not SLACK_WEBHOOK_URL:
L458         raise ValueError("SLACK_WEBHOOK_URL not set (環境変数が未設定です)")
L459     debug_payload = {"text": "```" + debug_text + "```"}
L460     try:
L461         resp = requests.post(SLACK_WEBHOOK_URL, json=debug_payload)
L462         resp.raise_for_status()
L463         print("✅ Debug情報をSlackに送信しました")
L464     except Exception as e:
L465         print(f"⚠️ Slack通知エラー: {e}")
L466
L467
L468 def main():
L469     portfolio = load_portfolio()
L470     symbols = [r["symbol"] for r in portfolio]
L471     sell_alerts = scan_sell_signals(symbols, lookback_days=5)
L472     vix_ma5, drift_threshold = compute_threshold()
L473     df, total_value, total_drift_abs = build_dataframe(portfolio)
L474     df, alert, new_total_value, simulated_total_drift_abs = simulate(
L475         df, total_value, total_drift_abs, drift_threshold
L476     )
L477     df_small = prepare_summary(df, total_drift_abs, alert)
L478     if 'df_small' in locals() and isinstance(df_small, pd.DataFrame) and not df_small.empty:
L479         col_sym = "sym" if "sym" in df_small.columns else ("symbol" if "symbol" in df_small.columns else None)
L480         if col_sym:
L481             df_small.insert(0, "⚠", df_small[col_sym].apply(lambda x: "🔴" if x in sell_alerts else ""))
L482     formatters = formatters_for(alert)
L483     header = build_header(
L484         vix_ma5, drift_threshold, total_drift_abs, alert, simulated_total_drift_abs
L485     )
L486     if sell_alerts:
L487         def fmt_pair(date_tags):
L488             date, tags = date_tags
L489             return f"{date}:" + "・".join(tags)
L490         listed = []
L491         for t, arr in sell_alerts.items():
L492             listed.append(f"*{t}*（" + ", ".join(fmt_pair(x) for x in arr) + "）")
L493         hits = ", ".join(listed)
L494         if "✅ アラートなし" in header:
L495             header = header.replace(
L496                 "✅ アラートなし",
L497                 f"⚠️ 売りシグナルあり: {len(sell_alerts)}銘柄\n🟥 {hits}",
L498             )
L499         else:
L500             header += f"\n🟥 {hits}"
L501     try:
L502         breadth_block, _mode, _C = build_breadth_header()
L503         if breadth_block:
L504             header = breadth_block + "\n" + header
L505     except Exception:
L506         pass
L507     table_text = df_small.to_string(formatters=formatters, index=False)
L508     send_slack(header + "\n```" + table_text + "```")
L509
L510     if debug_mode:
L511         debug_cols = [
L512             "symbol",
L513             "shares",
L514             "price",
L515             "value",
L516             "current_ratio",
L517             "drift",
L518             "drift_abs",
L519             "adjusted_ratio",
L520             "adjustable",
L521             "trade_shares",
L522             "new_shares",
L523             "new_value",
L524             "simulated_ratio",
L525             "simulated_drift_abs",
L526         ]
L527         debug_text = (
L528             "=== DEBUG: full dataframe ===\n"
L529             + df[debug_cols].to_string()
L530             + f"\n\ntotal_value={total_value}, new_total_value={new_total_value}\n"
L531             + f"total_drift_abs={total_drift_abs}, simulated_total_drift_abs={simulated_total_drift_abs}"
L532         )
L533         print("\n" + debug_text)
L534         send_debug(debug_text)
L535
L536
L537 if __name__ == "__main__":
L538     main()
L539
```

## <.github/workflows/daily-report.yml>
```text
L1 name: Daily Stock Report
L2
L3 on:
L4   push:
L5     branches: [ main ]
L6     paths-ignore:
L7       - 'CodeForChat/**'
L8   schedule:
L9     - cron: '30 23 * * 2-6'  # UTC 23:30 → JST 08:30（火〜土）
L10   workflow_dispatch:
L11
L12 jobs:
L13   build-and-report:
L14     runs-on: ubuntu-latest
L15
L16     steps:
L17       - name: Debug start
L18         run: echo '🚀 DEBUGstarted'
L19               
L20       - name: Checkout repository
L21         uses: actions/checkout@v3
L22
L23       - name: Setup Python
L24         uses: actions/setup-python@v4
L25         with:
L26           python-version: '3.x'
L27
L28       - name: Install dependencies
L29         run: pip install -r requirements.txt
L30
L31       - name: Prepare results directory
L32         run: mkdir -p results
L33
L34       - name: Run drift.py
L35         env:
L36           SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
L37           FINNHUB_API_KEY: ${{ secrets.FINNHUB_API_KEY }}
L38         run: python drift.py
L39
L40       - name: Persist breadth_state.json
L41         if: always()
L42         run: |
L43           git config user.name  "github-actions[bot]"
L44           git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
L45           git add results/breadth_state.json || true
L46           git commit -m "chore: update breadth_state [skip ci]" || echo "no changes"
L47           git push || true
```

## <documents/README.md>
```text
L1 # 運用ルール
L2
L3 ## 基本構成
L4 - 25銘柄を均等配分（現金を除き1銘柄あたり4%）
L5 - moomoo証券で運用
L6
L7 ## Barbell Growth-Defense方針
L8 - Growth枠12銘柄：高成長で乖離源となる攻めの銘柄
L9 - Defense枠13銘柄：低ボラで安定成長し配当を増やす守りの銘柄
L10 - 「猛烈に伸びる攻め × 着実に稼ぐ盾」の組合せで乖離→半戻しプレミアムを狙う
L11
L12 ## レジーム判定（trend_template 合格“本数”で判定）
L13 - 合格本数 = current+candidate 全体のうち、trend_template 条件を満たした銘柄の**本数(C)**
L14 - しきい値は過去~600営業日の分布から**毎回自動採用**（分位点と運用“床”のmax）
L15   - 緊急入り: `max(q05, 12本)`（= N_G）
L16   - 緊急解除: `max(q20, 18本)`（= 1.5×N_G）
L17   - 通常復帰: `max(q60, 36本)`（= 3×N_G）
L18 - ヒステリシス: 前回モードに依存（EMERG→解除は18本以上、CAUTION→通常は36本以上）
L19
L20 ## レジーム別の現金・ドリフト
L21 - **通常(NORMAL)** : 現金 **10%** / ドリフト閾値 **10%**
L22 - **警戒(CAUTION)** : 現金 **12.5%** / ドリフト閾値 **12%**
L23 - **緊急(EMERG)** : 現金 **20%** / **ドリフト売買停止**（25×4%に全戻しのみ）
L24
L25 ## トレーリングストップ（統一）
L26 - G/D 共通の **基本TS=15%**
L27 - 含み益が **+20% / +40% / +60%** 到達で TS を **12% / 9% / 7%** に段階引き上げ
L28 - TS発動で減少した銘柄は翌日以降に補充（※緊急モード中は補充しない）
L29
L30 ## 入替銘柄選定
L31 - Oxfordキャピタル／インカム、Alpha Investor、Motley Fool Stock Advisor、moomooスクリーニング等を参考にchatGPTで検討
L32 - 年間NISA枠はGrowth群の中から低ボラ銘柄を選定し利用。長期保持にはこだわらない。
L33
L34 ## 再エントリー（クールダウン）
L35 - TSヒット後の同銘柄再INは **8営業日** のクールダウンを設ける（期間中は再IN禁止）
L36
L37 ## 実行タイミング
L38 - 判定：米国市場終値直後
L39 - 執行：翌営業日の米国寄付き成行
```

## <documents/drift_design.md>
```text
L1 # drift.py 詳細設計書
L2
L3 ## 概要
L4 - 25銘柄ポートフォリオのドリフトを日次監視し、閾値超過時に半戻し案をSlack通知するスクリプト。
L5 - Finnhubとyfinanceから価格・VIX情報を取得し、現況比率と調整案を計算。
L6
L7 ## 定数・設定
L8 - `FINNHUB_API_KEY` / `SLACK_WEBHOOK_URL` を環境変数から取得。
L9 - 無料枠を考慮したAPIレート制限: `RATE_LIMIT = 55`。
L10 - デバッグ出力用フラグ `debug_mode`。
L11
L12 ## 主な関数
L13 ### finnhub_get
L14 - 基本的なレート制限付きでFinnhub APIを呼び出し、JSONレスポンスを辞書で返す。
L15
L16 ### fetch_price
L17 - `quote` エンドポイントで株価を取得し、失敗時は `NaN` を返す。
L18
L19 ### fetch_vix_ma5
L20 - yfinanceでVIX終値を取得し、直近5営業日の移動平均を算出。
L21
L22 ### load_portfolio
L23 - `current_tickers.csv` から銘柄と保有株数を読み込み、目標比率4%を付与したリストを生成。
L24
L25 ### compute_threshold
L26 - VIX MA5に応じてドリフト閾値を10%/12%/高VIXモード(∞)に設定。
L27
L28 ### build_dataframe
L29 - 各銘柄の評価額や現在比率、ドリフト、半戻し後比率(`adjusted_ratio`)を計算しDataFrame化。
L30
L31 ### simulate
L32 - ドリフト合計が閾値を超えた場合、半戻し後の売買株数と新比率を試算し、シミュレート後ドリフトを返す。
L33
L34 ### prepare_summary
L35 - 評価額順に並べ替えた後、合計行を付与してSlack表示用テーブルを作成。
L36
L37 ### formatters_for / currency
L38 - 通貨・比率・株数の表示フォーマットを定義。
L39
L40 ### build_header
L41 - VIX・閾値・ドリフト値およびアラート有無をSlackメッセージ用ヘッダに整形。
L42
L43 ### send_slack / send_debug
L44 - 通常通知およびデバッグ詳細をSlack Webhookへ送信。
L45
L46 ### main
L47 - 上記関数を順に呼び出し、日次ドリフトチェックの一連処理を実行。
L48
L49 ## 実行フロー
L50 1. `load_portfolio` で現ポートフォリオを読み込む。
L51 2. `compute_threshold` でVIX MA5とドリフト閾値を決定。
L52 3. `build_dataframe` で現在比率とドリフトを計算。
L53 4. `simulate` で閾値超過時の半戻し案を試算。
L54 5. `prepare_summary` と `build_header` で通知本文とテーブルを構築。
L55 6. `send_slack` で結果を送信。`debug_mode` がTrueなら `send_debug` も併用。
```
