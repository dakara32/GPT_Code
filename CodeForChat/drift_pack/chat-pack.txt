# === Chat Paste Pack ===
# Repo: dakara32/GPT_Code @ main
# Files: config.py, drift.py, .github/workflows/daily-report.yml, documents/README.md, documents/drift_design.md
# 作成日時: 2025-09-27 09:05:54 (JST)
# 使い方: 下のチャンクを順に貼ればこのチャットで全体把握できます。
# 注記: 各ファイルは個別に L1.. で行番号付与。
---

## <config.py>
```text
L1 # 共通設定（factor / drift から参照）
L2 TOTAL_TARGETS = 20
L3
L4 # 基準のバケット数（NORMAL）
L5 COUNTS_BASE = {"G": 12, "D": 8}
L6
L7 # モード別の推奨バケット数
L8 COUNTS_BY_MODE = {
L9     "NORMAL": {"G": 12, "D": 8},
L10     "CAUTION": {"G": 10, "D": 8},
L11     "EMERG": {"G": 8,  "D": 8},
L12 }
L13
L14 # モード別のドリフト閾値（%）
L15 DRIFT_THRESHOLD_BY_MODE = {"NORMAL": 12, "CAUTION": 14, "EMERG": float("inf")}
L16
L17 # モード別の推奨現金比率
L18 CASH_RATIO_BY_MODE = {
L19     "NORMAL": 0.10,  # 10%
L20     "CAUTION": 0.20,  # 20%
L21     "EMERG": 0.30,  # 30%
L22 }
L23
L24 # モード別のTS（基本幅, 小数=割合）
L25 TS_BASE_BY_MODE = {"NORMAL": 0.15, "CAUTION": 0.13, "EMERG": 0.10}
L26 # 利益到達(+30/+60/+100%)時の段階タイト化（ポイント差）
L27 TS_STEP_DELTAS_PT = (3, 6, 8)
L28
L29 # Breadthの校正は N_G に連動（緊急解除=ceil(1.5*N_G), 通常復帰=3*N_G）
L30 N_G = COUNTS_BASE["G"]
L31 N_D = COUNTS_BASE["D"]
L32
```

## <drift.py>
```text
L1 import pandas as pd, yfinance as yf
L2 import numpy as np
L3 import requests
L4 import os
L5 import json
L6 import time
L7 from pathlib import Path
L8 import csv
L9 import config
L10
L11 # --- GコンポジットDDのしきい値（Growthの平均DD基準）---
L12 CD_CAUTION = 0.10   # -10% で警戒
L13 CD_EMERG = 0.15   # -15% で緊急
L14
L15 MODE_LABELS_JA = {"NORMAL": "通常", "CAUTION": "警戒", "EMERG": "緊急"}
L16 # Slack通知用のモードアイコン
L17 MODE_EMOJIS = {"NORMAL": "🟢", "CAUTION": "⚠️", "EMERG": "🔴"}
L18 MODE_RANK = {"NORMAL": 0, "CAUTION": 1, "EMERG": 2}
L19
L20 # --- breadth utilities (factor parity) ---
L21 BENCH = "^GSPC"
L22 CAND_PRICE_MAX = 450.0
L23 RESULTS_DIR = "results"
L24 os.makedirs(RESULTS_DIR, exist_ok=True)
L25
L26 def _state_file():
L27     return str(Path(RESULTS_DIR) / "breadth_state.json")
L28
L29
L30 def _load_state_dict() -> dict:
L31     try:
L32         with open(_state_file()) as fh:
L33             data = json.load(fh)
L34         return data if isinstance(data, dict) else {}
L35     except Exception:
L36         return {}
L37
L38
L39 def _save_state_dict(state: dict):
L40     try:
L41         with open(_state_file(), "w") as fh:
L42             json.dump(state, fh)
L43     except Exception:
L44         pass
L45
L46
L47 def load_breadth_mode(default: str = "NORMAL") -> str:
L48     state = _load_state_dict()
L49     mode = state.get("breadth_mode", state.get("mode", default))
L50     return mode if mode in MODE_RANK else default
L51
L52
L53 def save_breadth_mode(mode: str):
L54     state = _load_state_dict()
L55     state["breadth_mode"] = mode
L56     _save_state_dict(state)
L57
L58
L59 def load_final_mode(default: str = "NORMAL") -> str:
L60     state = _load_state_dict()
L61     mode = state.get("final_mode", state.get("mode", default))
L62     return mode if mode in MODE_RANK else default
L63
L64
L65 def save_final_mode(mode: str):
L66     state = _load_state_dict()
L67     state["final_mode"] = mode
L68     state.setdefault("breadth_mode", state.get("breadth_mode", mode))
L69     state["mode"] = mode
L70     _save_state_dict(state)
L71
L72
L73 def _read_csv_list(fname):
L74     p = Path(__file__).with_name(fname)
L75     if not p.exists(): return []
L76     return pd.read_csv(p, header=None).iloc[:,0].astype(str).str.upper().tolist()
L77
L78
L79 # leaders.csv 読み込み（results/leaders.csv, 1列想定）
L80 def _read_leaders_symbols() -> list[str]:
L81     p = Path(__file__).with_name("results").joinpath("leaders.csv")
L82     df = pd.read_csv(p, header=None)
L83     return sorted(set(df.iloc[:,0].astype(str).str.strip().str.upper().tolist()))
L84
L85 def _load_universe():
L86     # exist + candidate を使用。candidate は価格上限で事前フィルタ
L87     exist = _read_csv_list("current_tickers.csv")
L88     cand  = _read_csv_list("candidate_tickers.csv")
L89     cand_info = yf.Tickers(" ".join(cand)) if cand else None
L90     cand_keep = []
L91     for t in cand:
L92         try:
L93             px = cand_info.tickers[t].fast_info.get("lastPrice", float("inf"))
L94         except Exception:
L95             px = float("inf")
L96         if pd.notna(px) and float(px) <= CAND_PRICE_MAX:
L97             cand_keep.append(t)
L98     tickers = sorted(set(exist + cand_keep))
L99     return exist, cand_keep, tickers
L100
L101
L102 def _fetch_prices_600d(tickers):
L103     data = yf.download(
L104         tickers + [BENCH],
L105         period="600d",
L106         auto_adjust=True,
L107         progress=False,
L108         threads=False,
L109     )
L110     close = data["Close"]
L111     px = close.dropna(how="all", axis=1).ffill(limit=2)
L112     spx = close[BENCH].reindex(px.index).ffill()
L113     return px, spx
L114
L115
L116 def trend_template_breadth_series(px: pd.DataFrame, spx: pd.Series, win_days: int | None = None) -> pd.Series:
L117     # scorer.py の実装をそのまま移植（ベクトル化版）
L118     import numpy as np, pandas as pd
L119     if px is None or px.empty:
L120         return pd.Series(dtype=int)
L121     px = px.dropna(how="all", axis=1)
L122     if win_days and win_days > 0:
L123         px = px.tail(win_days)
L124     if px.empty:
L125         return pd.Series(dtype=int)
L126     # 欠損吸収
L127     px = px.ffill(limit=2)
L128     spx = spx.reindex(px.index).ffill()
L129
L130     ma50  = px.rolling(50,  min_periods=50).mean()
L131     ma150 = px.rolling(150, min_periods=150).mean()
L132     ma200 = px.rolling(200, min_periods=200).mean()
L133
L134     tt = (px > ma150)
L135     tt &= (px > ma200)
L136     tt &= (ma150 > ma200)
L137     tt &= (ma200 - ma200.shift(21) > 0)
L138     tt &= (ma50  > ma150)
L139     tt &= (ma50  > ma200)
L140     tt &= (px    > ma50)
L141
L142     lo252 = px.rolling(252, min_periods=252).min()
L143     hi252 = px.rolling(252, min_periods=252).max()
L144     tt &= (px.divide(lo252).sub(1.0) >= 0.30)
L145     tt &= (px >= (0.75 * hi252))
L146
L147     r12  = px.divide(px.shift(252)).sub(1.0)
L148     br12 = spx.divide(spx.shift(252)).sub(1.0)
L149     r1   = px.divide(px.shift(22)).sub(1.0)
L150     br1  = spx.divide(spx.shift(22)).sub(1.0)
L151     rs   = 0.7*(r12.sub(br12, axis=0)) + 0.3*(r1.sub(br1, axis=0))
L152     tt &= (rs >= 0.10)
L153
L154     return tt.fillna(False).sum(axis=1).astype(int)
L155
L156
L157 def build_breadth_header():
L158     # factor._build_breadth_lead_lines と同一挙動
L159     exist, cand, tickers = _load_universe()
L160     if not tickers:
L161         return "", "NORMAL", 0
L162     px, spx = _fetch_prices_600d(tickers)
L163     win = int(os.getenv("BREADTH_CALIB_WIN_DAYS", "600"))
L164     C_ts = trend_template_breadth_series(px, spx, win_days=win)
L165     if C_ts.empty:
L166         return "", "NORMAL", 0
L167     warmup = int(os.getenv("BREADTH_WARMUP_DAYS","252"))
L168     base = C_ts.iloc[warmup:] if len(C_ts)>warmup else C_ts
L169     C_full = int(C_ts.iloc[-1])
L170
L171     q05 = int(np.nan_to_num(base.quantile(float(os.getenv("BREADTH_Q_EMERG_IN",  "0.05"))), nan=0.0))
L172     q20 = int(np.nan_to_num(base.quantile(float(os.getenv("BREADTH_Q_EMERG_OUT", "0.20"))), nan=0.0))
L173     q60 = int(np.nan_to_num(base.quantile(float(os.getenv("BREADTH_Q_WARN_OUT",  "0.60"))), nan=0.0))
L174
L175     # G枠サイズ（Breadth基準）
L176     N_G = config.N_G
L177     th_in_rec   = max(N_G, q05)
L178     th_out_rec  = max(int(np.ceil(1.5*N_G)), q20)
L179     th_norm_rec = max(3*N_G, q60)
L180
L181     use_calib = os.getenv("BREADTH_USE_CALIB", "true").strip().lower() == "true"
L182     if use_calib:
L183         th_in, th_out, th_norm, th_src = th_in_rec, th_out_rec, th_norm_rec, "自動"
L184     else:
L185         th_in   = int(os.getenv("GTT_EMERG_IN", str(N_G)))
L186         th_out  = int(os.getenv("GTT_EMERG_OUT", str(int(1.5*N_G))))
L187         th_norm = int(os.getenv("GTT_CAUTION_OUT", str(3*N_G)))
L188         th_src = "手動"
L189
L190     prev = load_breadth_mode("NORMAL")
L191     if   prev == "EMERG":
L192         mode = "EMERG"   if (C_full < th_out)  else ("CAUTION" if (C_full < th_norm) else "NORMAL")
L193     elif prev == "CAUTION":
L194         mode = "CAUTION" if (C_full < th_norm) else "NORMAL"
L195     else:
L196         mode = "EMERG"   if (C_full < th_in)   else ("CAUTION" if (C_full < th_norm) else "NORMAL")
L197     save_breadth_mode(mode)
L198
L199     mode_ja, emoji = MODE_LABELS_JA.get(mode, mode), MODE_EMOJIS.get(mode, "ℹ️")
L200     eff_days = len(base)
L201
L202     lead_lines = [
L203         f"{emoji} *現在モード: {mode_ja}*",
L204         f"テンプレ合格本数: *{C_full}本*",
L205         "しきい値（{0}）".format(th_src),
L206         f"  ・緊急入り: <{th_in}本",
L207         f"  ・緊急解除: ≥{th_out}本",
L208         f"  ・通常復帰: ≥{th_norm}本",
L209         f"参考指標（過去~{win}営業日, 有効={eff_days}日）",
L210         f"  ・下位5%: {q05}本",
L211         f"  ・下位20%: {q20}本",
L212         f"  ・60%分位: {q60}本",
L213     ]
L214     return "```" + "\n".join(lead_lines) + "```", mode, C_full
L215
L216
L217 def _format_mode(mode: str) -> str:
L218     upper = (mode or "NORMAL").upper()
L219     return f"{MODE_EMOJIS.get(upper, 'ℹ️')} {MODE_LABELS_JA.get(upper, upper)}"
L220
L221
L222 def _gcd_mode_today(g_syms: list[str]) -> tuple[str, float]:
L223     """
L224     現在のGrowth群について、Low_today / Peak60(High) の等加重平均から G-CD(%) を算出し、モードを返す。
L225     戻り値: (gcd_mode, gcd_pct)  ※gcd_pctは正の%（例 11.3 は -11.3%の下落）
L226     """
L227
L228     if not g_syms:
L229         print("📝 audit[G-CD details]: G銘柄が空のため算出対象がありません")
L230         print("📝 audit[G-CD summary]: avg_low/peak60=1.0000  drawdown=0.00%  => NORMAL")
L231         return "NORMAL", 0.0
L232
L233     try:
L234         df = yf.download(
L235             g_syms,
L236             period="100d",
L237             interval="1d",
L238             auto_adjust=False,
L239             progress=False,
L240         )
L241     except Exception as e:
L242         print(f"⚠️ audit[G-CD details]: 株価データ取得に失敗しました ({e})")
L243         print("📝 audit[G-CD summary]: avg_low/peak60=1.0000  drawdown=0.00%  => NORMAL")
L244         return "NORMAL", 0.0
L245
L246     if not isinstance(df, pd.DataFrame) or df.empty:
L247         print("⚠️ audit[G-CD details]: 株価データが空のため算出できません")
L248         print("📝 audit[G-CD summary]: avg_low/peak60=1.0000  drawdown=0.00%  => NORMAL")
L249         return "NORMAL", 0.0
L250
L251     hi_all = df.get("High") if isinstance(df, pd.DataFrame) else None
L252     lo_all = df.get("Low") if isinstance(df, pd.DataFrame) else None
L253     if hi_all is None or lo_all is None:
L254         print("⚠️ audit[G-CD details]: High/Low データが欠落しています")
L255         print("📝 audit[G-CD summary]: avg_low/peak60=1.0000  drawdown=0.00%  => NORMAL")
L256         return "NORMAL", 0.0
L257
L258     if isinstance(hi_all, pd.Series):
L259         hi_all = hi_all.to_frame(name=g_syms[0])
L260     if isinstance(lo_all, pd.Series):
L261         lo_all = lo_all.to_frame(name=g_syms[0])
L262
L263     if hi_all.empty or lo_all.empty:
L264         print("⚠️ audit[G-CD details]: High/Low データが空のため算出できません")
L265         print("📝 audit[G-CD summary]: avg_low/peak60=1.0000  drawdown=0.00%  => NORMAL")
L266         return "NORMAL", 0.0
L267
L268     peak60 = hi_all.rolling(60, min_periods=20).max().tail(1).iloc[0]
L269     low_today = lo_all.tail(1).iloc[0]
L270
L271     details: list[tuple[str, float, float, float, float]] = []
L272     for sym in g_syms:
L273         p = float(peak60.get(sym, float("nan"))) if hasattr(peak60, "get") else float("nan")
L274         lt = float(low_today.get(sym, float("nan"))) if hasattr(low_today, "get") else float("nan")
L275         if pd.notna(p) and p > 0 and pd.notna(lt) and lt > 0:
L276             ratio = lt / p
L277             ddpct = (1.0 - ratio) * 100.0
L278             details.append((sym, p, lt, ratio, ddpct))
L279
L280     if not details:
L281         print("⚠️ audit[G-CD details]: 有効な銘柄データがありません")
L282         print("📝 audit[G-CD summary]: avg_low/peak60=1.0000  drawdown=0.00%  => NORMAL")
L283         return "NORMAL", 0.0
L284
L285     details.sort(key=lambda x: x[4], reverse=True)
L286     today = pd.Timestamp.today(tz="America/New_York").date().isoformat()
L287     print(f"📝 audit[G-CD details] {today}  G={len(g_syms)}")
L288     print("  SYMBOL        Peak60(H)     Low(T)     ratio    DD%")
L289     for sym, peak, low, ratio, ddpct in details:
L290         print(f"  {sym:<8}  {peak:>12.6g}  {low:>10.6g}   {ratio:>6.3f}  {ddpct:>6.2f}")
L291
L292     avg_ratio = float(np.mean([r for _, _, _, r, _ in details]))
L293     gcd_pct = max(0.0, (1.0 - avg_ratio) * 100.0)
L294     mode = "EMERG" if gcd_pct >= CD_EMERG * 100 else "CAUTION" if gcd_pct >= CD_CAUTION * 100 else "NORMAL"
L295     print(
L296         f"📝 audit[G-CD summary]: avg_low/peak60={avg_ratio:.4f}  drawdown={gcd_pct:.2f}%  => {mode}"
L297     )
L298     return mode, gcd_pct
L299 # Debug flag
L300 debug_mode = False  # set to True for detailed output
L301
L302 # --- Finnhub settings & helper ---
L303 FINNHUB_API_KEY = os.environ.get("FINNHUB_API_KEY")
L304 if not FINNHUB_API_KEY:
L305     raise ValueError("FINNHUB_API_KEY not set (環境変数が未設定です)")
L306
L307 RATE_LIMIT = 55  # requests per minute (free tier is 60)
L308 call_times = []
L309
L310
L311 def finnhub_get(endpoint, params):
L312     """Call Finnhub API with basic rate limiting."""
L313     now = time.time()
L314     cutoff = now - 60
L315     while call_times and call_times[0] < cutoff:
L316         call_times.pop(0)
L317     if len(call_times) >= RATE_LIMIT:
L318         sleep_time = 60 - (now - call_times[0])
L319         time.sleep(sleep_time)
L320     params = {**params, "token": FINNHUB_API_KEY}
L321     try:
L322         resp = requests.get(f"https://finnhub.io/api/v1/{endpoint}", params=params)
L323         resp.raise_for_status()
L324         data = resp.json()
L325     except requests.exceptions.JSONDecodeError as e:
L326         print(f"⚠️ Finnhub API JSON decode error: {e}")
L327         return {}
L328     except Exception as e:
L329         print(f"⚠️ Finnhub API error: {e}")
L330         return {}
L331     call_times.append(time.time())
L332     return data
L333
L334
L335 def fetch_price(symbol):
L336     try:
L337         data = finnhub_get("quote", {"symbol": symbol})
L338         price = data.get("c")
L339         return float(price) if price not in (None, 0) else float("nan")
L340     except Exception:
L341         return float("nan")
L342
L343
L344 def fetch_vix_ma5():
L345     """Retrieve VIX 5-day moving average via yfinance."""
L346     try:
L347         vix = (
L348             yf.download("^VIX", period="7d", interval="1d", progress=False, auto_adjust=False)["Close"]
L349             .dropna()
L350             .tail(5)
L351         )
L352         if len(vix) < 5:
L353             return float("nan")
L354         return vix.mean().item()
L355     except Exception:
L356         return float("nan")
L357
L358
L359
L360 # === Minervini-like sell signals ===
L361 def _yf_df(sym, period="6mo"):
L362     """日足/MA/出来高平均を取得。欠損時は None。"""
L363     try:
L364         df = yf.download(sym, period=period, interval="1d", auto_adjust=False, progress=False)
L365         if df is None or df.empty:
L366             return None
L367         return df.dropna().assign(
L368             ma20=lambda d: d["Close"].rolling(20).mean(),
L369             ma50=lambda d: d["Close"].rolling(50).mean(),
L370             vol50=lambda d: d["Volume"].rolling(50).mean(),
L371         )
L372     except Exception:
L373         return None
L374
L375
L376 def _scalar(row, col):
L377     """Series/npスカラ→Pythonスカラ化（NaNはNaNのまま）"""
L378     try:
L379         v = row[col]
L380         if hasattr(v, "item"):
L381             try:
L382                 v = v.item()
L383             except Exception:
L384                 pass
L385         return v
L386     except Exception:
L387         return float("nan")
L388
L389
L390 def _is_strict_down(seq):
L391     """数列が厳密に連続で切り下がっているか（len>=4を想定）。NaN含みはFalse。"""
L392     try:
L393         xs = [float(x) for x in seq]
L394         if any(pd.isna(x) for x in xs) or len(xs) < 4:
L395             return False
L396         return all(b < a for a, b in zip(xs[:-1], xs[1:]))
L397     except Exception:
L398         return False
L399
L400
L401 def _signals_for_day(df, idx):
L402     """df.loc[idx] 1日分に対しシグナル配列を返す（値動き/出来高ベースのみ）。"""
L403     try:
L404         sig = []
L405         d = df.loc[idx]
L406         close = _scalar(d, "Close")
L407         ma20 = _scalar(d, "ma20")
L408         ma50 = _scalar(d, "ma50")
L409         vol = _scalar(d, "Volume")
L410         vol50 = _scalar(d, "vol50")
L411
L412         if pd.notna(close) and pd.notna(ma20) and close < ma20:
L413             sig.append("20DMA↓")
L414
L415         if all(pd.notna(x) for x in (close, ma50, vol, vol50)) and close < ma50 and vol > 1.5 * vol50:
L416             sig.append("50DMA↓(大商い)")
L417
L418         last4 = df.loc[:idx].tail(4)
L419         last10 = df.loc[:idx].tail(10)
L420
L421         lows_desc = _is_strict_down(last4["Low"].tolist()) if last4["Low"].notna().all() else False
L422         reds = int((last10["Close"] < last10["Open"]).sum()) if last10[["Close", "Open"]].notna().all().all() else 0
L423         if lows_desc or reds > 5:
L424             sig.append("連続安値/陰線優勢")
L425
L426         ups = int((last10["Close"] > last10["Open"]).sum()) if last10[["Close", "Open"]].notna().all().all() else 0
L427         if ups >= 7:
L428             sig.append("上げ偏重(>70%)")
L429
L430         last15 = df.loc[:idx].tail(15)
L431         base0 = _scalar(last15.iloc[0], "Close") if len(last15) > 0 else float("nan")
L432         if pd.notna(base0) and pd.notna(close) and base0 != 0 and (close / base0 - 1) >= 0.25:
L433             sig.append("+25%/15日内")
L434
L435         if len(df.loc[:idx]) >= 2:
L436             t1, t0 = df.loc[:idx].iloc[-2], df.loc[:idx].iloc[-1]
L437             t1_high = _scalar(t1, "High")
L438             t0_open = _scalar(t0, "Open")
L439             t0_close = _scalar(t0, "Close")
L440             if all(pd.notna(x) for x in (t1_high, t0_open, t0_close)):
L441                 if (t0_open > t1_high * 1.02) and (t0_close < t0_open):
L442                     sig.append("GU→陰線")
L443         return sig
L444     except Exception:
L445         return []
L446
L447
L448 def scan_sell_signals(symbols, lookback_days=5):
L449     """
L450     直近 lookback_days 日のうち一度でもシグナルが出たら {sym: [(date,[signals]),...]} を返す。
L451     日付は YYYY-MM-DD。Slackで列挙する。
L452     """
L453     out = {}
L454     for s in symbols:
L455         df = _yf_df(s)
L456         if df is None or len(df) < 60:
L457             continue
L458         alerts = []
L459         for idx in df.tail(lookback_days).index:
L460             tags = _signals_for_day(df, idx)
L461             if tags:
L462                 alerts.append((idx.strftime("%Y-%m-%d"), tags))
L463         if alerts:
L464             out[s] = alerts
L465     return out
L466
L467
L468 def load_portfolio():
L469     tickers_path = Path(__file__).with_name("current_tickers.csv")
L470     with tickers_path.open() as f:
L471         rows = [row for row in csv.reader(f) if row and row[0].strip()]
L472     n = len(rows)
L473     portfolio = []
L474     for row in rows:
L475         sym = row[0].strip().upper()
L476         qty = int(row[1]) if len(row) > 1 and row[1].strip() else 0
L477         bucket = row[2].strip().upper() if len(row) > 2 else ""
L478         entry = {
L479             "symbol": sym,
L480             "shares": qty,
L481             "target_ratio": 1 / n if n else 0.0,
L482             "bucket": bucket,
L483         }
L484         portfolio.append(entry)
L485     return portfolio
L486
L487
L488 def compute_threshold():
L489     vix_ma5 = fetch_vix_ma5()
L490     drift_threshold = 10 if vix_ma5 < 20 else 12 if vix_ma5 < 26 else float("inf")
L491     return vix_ma5, drift_threshold
L492
L493
L494 def compute_threshold_by_mode(mode: str):
L495     """モードに応じて現金保有率とドリフト閾値を返す（README準拠）"""
L496     m = (mode or "NORMAL").upper()
L497     cash_ratio = config.CASH_RATIO_BY_MODE.get(
L498         m, config.CASH_RATIO_BY_MODE.get("NORMAL", 0.10)
L499     )
L500     drift_threshold = config.DRIFT_THRESHOLD_BY_MODE.get(
L501         m, config.DRIFT_THRESHOLD_BY_MODE.get("NORMAL", 12)
L502     )
L503     return cash_ratio, drift_threshold
L504
L505
L506 def recommended_counts_by_mode(mode: str) -> tuple[int, int, int]:
L507     """
L508     モード別の推奨保有数 (G_count, D_count, cash_slots) を返す。
L509     cash_slotsは「外すG枠の数」（各枠=5%）。
L510     NORMAL: G12/D8/現金化0, CAUTION: G10/D8/現金化2, EMERG: G8/D8/現金化4
L511     """
L512     m = (mode or "NORMAL").upper()
L513     base = config.COUNTS_BY_MODE.get("NORMAL", config.COUNTS_BASE)
L514     now  = config.COUNTS_BY_MODE.get(m, base)
L515     cash_slots = max(0, base["G"] - now["G"])
L516     return now["G"], now["D"], cash_slots
L517
L518
L519 def _mode_tail_line(final_mode: str) -> str:
L520     fm = (final_mode or "NORMAL").upper()
L521     base_ts = config.TS_BASE_BY_MODE.get(fm, config.TS_BASE_BY_MODE.get("NORMAL", 0.15))
L522     ts_base_pct = int(round(base_ts * 100))
L523     d1, d2, d3 = config.TS_STEP_DELTAS_PT
L524     step30 = max(ts_base_pct - d1, 0)
L525     step60 = max(ts_base_pct - d2, 0)
L526     step100 = max(ts_base_pct - d3, 0)
L527     g_cnt, d_cnt, cash_slots = recommended_counts_by_mode(fm)
L528     cash_pct = config.CASH_RATIO_BY_MODE.get(
L529         fm, config.CASH_RATIO_BY_MODE.get("NORMAL", 0.10)
L530     ) * 100
L531     return (
L532         f"〔このモードの設定〕"
L533         f"TS基本: -{ts_base_pct}%（+30%→-{step30}%／+60%→-{step60}%／+100%→-{step100}%）／ "
L534         f"推奨保有: G{g_cnt}・D{d_cnt}（現金化枠 {cash_slots}）／ "
L535         f"推奨現金比率: {cash_pct:.0f}%"
L536     )
L537
L538
L539 def build_dataframe(portfolio):
L540     for stock in portfolio:
L541         price = fetch_price(stock["symbol"])
L542         stock["price"] = price
L543         stock["value"] = price * stock["shares"]
L544
L545     df = pd.DataFrame(portfolio)
L546     total_value = df["value"].sum()
L547     df["current_ratio"] = df["value"] / total_value
L548     df["drift"] = df["current_ratio"] - df["target_ratio"]
L549     df["drift_abs"] = df["drift"].abs()
L550     total_drift_abs = df["drift_abs"].sum()
L551     df["adjusted_ratio"] = df["current_ratio"] - df["drift"] / 2
L552     df["adjustable"] = (
L553         (df["adjusted_ratio"] * total_value) >= df["price"]
L554     ) & df["price"].notna() & df["price"].gt(0)
L555     return df, total_value, total_drift_abs
L556
L557
L558 def simulate(df, total_value, total_drift_abs, drift_threshold):
L559     alert = drift_threshold != float("inf") and total_drift_abs * 100 > drift_threshold
L560     if alert:
L561         df["trade_shares"] = df.apply(
L562             lambda r: int(round(((r["adjusted_ratio"] * total_value) - r["value"]) / r["price"]))
L563             if r["adjustable"] and r["price"] > 0 else 0,
L564             axis=1,
L565         )
L566         df["new_shares"] = df["shares"] + df["trade_shares"]
L567         df["new_value"] = df["new_shares"] * df["price"]
L568         new_total_value = df["new_value"].sum()
L569         df["simulated_ratio"] = df["new_value"] / new_total_value
L570         df["simulated_drift_abs"] = (df["simulated_ratio"] - df["target_ratio"]).abs()
L571         simulated_total_drift_abs = df["simulated_drift_abs"].sum()
L572     else:
L573         df["trade_shares"] = np.nan
L574         df["new_shares"] = np.nan
L575         df["new_value"] = np.nan
L576         new_total_value = np.nan
L577         df["simulated_ratio"] = np.nan
L578         df["simulated_drift_abs"] = np.nan
L579         simulated_total_drift_abs = np.nan
L580     return df, alert, new_total_value, simulated_total_drift_abs
L581
L582
L583 def prepare_summary(df, total_drift_abs, alert):
L584     summary = {
L585         "symbol": "合計",
L586         "shares": df["shares"].sum(),
L587         "value": df["value"].sum(),
L588         "current_ratio": np.nan,
L589         "drift_abs": total_drift_abs,
L590     }
L591     if alert:
L592         summary["trade_shares"] = np.nan
L593     # Sort details by evaluation value descending before appending summary
L594     df = df.sort_values(by="value", ascending=False)
L595     df = pd.concat([df, pd.DataFrame([summary])], ignore_index=True)
L596     if alert:
L597         cols = ["symbol", "shares", "value", "current_ratio", "drift_abs", "trade_shares"]
L598         df_small = df[cols].copy()
L599         df_small.columns = ["sym", "qty", "val", "now", "|d|", "Δqty"]
L600     else:
L601         cols = ["symbol", "shares", "value", "current_ratio", "drift_abs"]
L602         df_small = df[cols].copy()
L603         df_small.columns = ["sym", "qty", "val", "now", "|d|"]
L604     return df_small
L605
L606
L607 def currency(x):
L608     return f"${x:,.0f}" if pd.notnull(x) else ""
L609
L610
L611 def formatters_for(alert):
L612     formatters = {"val": currency, "now": "{:.2%}".format, "|d|": "{:.2%}".format}
L613     if alert:
L614         formatters["Δqty"] = "{:.0f}".format
L615     return formatters
L616
L617
L618 def build_header(mode, cash_ratio, drift_threshold, total_drift_abs, alert, simulated_total_drift_abs):
L619     mode_ratio = config.CASH_RATIO_BY_MODE.get(mode.upper(), cash_ratio)
L620     header = (
L621         f"*💼 推奨現金比率:* {mode_ratio*100:.1f}%（モード準拠）\n"
L622         f"*📊 ドリフト閾値:* {'🔴(停止)' if drift_threshold == float('inf') else str(drift_threshold)+'%'}\n"
L623         f"*📉 現在のドリフト合計:* {total_drift_abs * 100:.2f}%\n"
L624     )
L625     if alert:
L626         header += f"*🔁 半戻し後ドリフト合計(想定):* {simulated_total_drift_abs * 100:.2f}%\n"
L627         header += "🚨 *アラート: 発生！！ Δqtyのマイナス銘柄を売却、任意の銘柄を買い増してバランスを取りましょう！*\n"
L628     else:
L629         header += "✅ アラートなし\n"
L630     return header
L631
L632
L633 def send_slack(text):
L634     SLACK_WEBHOOK_URL = os.environ.get("SLACK_WEBHOOK_URL")
L635     if not SLACK_WEBHOOK_URL:
L636         raise ValueError("SLACK_WEBHOOK_URL not set (環境変数が未設定です)")
L637     payload = {"text": text}
L638     try:
L639         resp = requests.post(SLACK_WEBHOOK_URL, json=payload)
L640         resp.raise_for_status()
L641         print("✅ Slack（Webhook）へ送信しました")
L642     except Exception as e:
L643         print(f"⚠️ Slack通知エラー: {e}")
L644
L645
L646 def send_debug(debug_text):
L647     SLACK_WEBHOOK_URL = os.environ.get("SLACK_WEBHOOK_URL")
L648     if not SLACK_WEBHOOK_URL:
L649         raise ValueError("SLACK_WEBHOOK_URL not set (環境変数が未設定です)")
L650     debug_payload = {"text": "```" + debug_text + "```"}
L651     try:
L652         resp = requests.post(SLACK_WEBHOOK_URL, json=debug_payload)
L653         resp.raise_for_status()
L654         print("✅ Debug情報をSlackに送信しました")
L655     except Exception as e:
L656         print(f"⚠️ Slack通知エラー: {e}")
L657
L658
L659 def main():
L660     portfolio = load_portfolio()
L661     symbols = [r["symbol"] for r in portfolio]
L662     # G集合は leaders.csv を使用（存在前提）
L663     g_syms = _read_leaders_symbols()
L664     sell_alerts = scan_sell_signals(symbols, lookback_days=5)
L665
L666     breadth_block, breadth_mode, breadth_score = build_breadth_header()
L667     gcd_mode, gcd_pct = _gcd_mode_today(g_syms)
L668
L669     # モードは GコンポジットDD のみで決定（シンプル化）
L670     final_mode = gcd_mode
L671     save_final_mode(final_mode)
L672
L673     cash_ratio, drift_threshold = compute_threshold_by_mode(final_mode)
L674
L675     df, total_value, total_drift_abs = build_dataframe(portfolio)
L676     df, alert, new_total_value, simulated_total_drift_abs = simulate(
L677         df, total_value, total_drift_abs, drift_threshold
L678     )
L679     df_small = prepare_summary(df, total_drift_abs, alert)
L680     if 'df_small' in locals() and isinstance(df_small, pd.DataFrame) and not df_small.empty:
L681         col_sym = "sym" if "sym" in df_small.columns else ("symbol" if "symbol" in df_small.columns else None)
L682         if col_sym:
L683             alert_keys = {str(k) for k in sell_alerts.keys()}
L684             df_small[col_sym] = df_small[col_sym].astype(str)
L685             df_small.insert(0, "⚠", df_small[col_sym].map(lambda x: "🔴" if x in alert_keys else ""))
L686             latest_tag = {s: " / ".join(sell_alerts[s][-1][1]) for s in sell_alerts}
L687             df_small.insert(1, "sig", df_small[col_sym].map(latest_tag).fillna(""))
L688     formatters = formatters_for(alert)
L689     header_core = build_header(
L690         final_mode, cash_ratio, drift_threshold, total_drift_abs, alert, simulated_total_drift_abs
L691     )
L692
L693     # --- Slack 送信：①ブロック（判定＋このモードの設定〜推奨現金比率）を独立、②以降は別ブロック ---
L694     me_g = MODE_EMOJIS.get(gcd_mode, "")
L695     me_b = MODE_EMOJIS.get(breadth_mode, "")
L696     me_f = MODE_EMOJIS.get(final_mode, "")
L697     block_gcd = (
L698         f"① GコンポジットDD: -{gcd_pct:.1f}%"
L699         f"（基準: C={CD_CAUTION*100:.0f}% / E={CD_EMERG*100:.0f}%） 判定: {me_g} {gcd_mode}"
L700     )
L701     # ①ブロック：ここまで＋このモードの設定〜推奨現金比率まで
L702     first_block = "```\n" + block_gcd + "\n" + _mode_tail_line(final_mode) + "\n```"
L703
L704     # ②以降ブロック：Breadth と参考総合表示（※モードはGのみで決定）
L705     block_breadth = f"② Breadth: {me_b} {breadth_mode}（テンプレ合格本数: {breadth_score}）"
L706     block_final = f"総合（参考表示）: {me_f} {final_mode}"
L707     # breadth_block の中身（コードフェンス除去＋「現在モード」行は除去）
L708     breadth_details = ""
L709     if breadth_block:
L710         inner = breadth_block
L711         if inner.startswith("```"):
L712             inner = inner[len("```"):]
L713             if inner.startswith("\n"):
L714                 inner = inner[1:]
L715             if inner.endswith("```"):
L716                 inner = inner[:-3]
L717         inner_lines = [ln for ln in inner.splitlines() if "現在モード" not in ln]
L718         breadth_details = "\n".join(inner_lines).strip()
L719     second_body = block_breadth + "\n" + block_final + ("\n" + breadth_details if breadth_details else "")
L720     second_block = "```\n" + second_body.strip() + "\n```"
L721
L722     header = first_block + "\n" + second_block + "\n" + header_core
L723     if sell_alerts:
L724         def fmt_pair(date_tags):
L725             date, tags = date_tags
L726             return f"{date}:" + "・".join(tags)
L727         listed = []
L728         for t, arr in sell_alerts.items():
L729             listed.append(f"*{t}*（" + ", ".join(fmt_pair(x) for x in arr) + "）")
L730         hits = ", ".join(listed)
L731         if "✅ アラートなし" in header:
L732             header = header.replace(
L733                 "✅ アラートなし",
L734                 f"⚠️ 売りシグナルあり: {len(sell_alerts)}銘柄\n🟥 {hits}",
L735             )
L736         else:
L737             header += f"\n🟥 {hits}"
L738     table_text = df_small.to_string(formatters=formatters, index=False)
L739     send_slack(header + "\n```" + table_text + "```")
L740
L741     if debug_mode:
L742         debug_cols = [
L743             "symbol",
L744             "shares",
L745             "price",
L746             "value",
L747             "current_ratio",
L748             "drift",
L749             "drift_abs",
L750             "adjusted_ratio",
L751             "adjustable",
L752             "trade_shares",
L753             "new_shares",
L754             "new_value",
L755             "simulated_ratio",
L756             "simulated_drift_abs",
L757         ]
L758         debug_text = (
L759             "=== DEBUG: full dataframe ===\n"
L760             + df[debug_cols].to_string()
L761             + f"\n\ntotal_value={total_value}, new_total_value={new_total_value}\n"
L762             + f"total_drift_abs={total_drift_abs}, simulated_total_drift_abs={simulated_total_drift_abs}"
L763         )
L764         print("\n" + debug_text)
L765         send_debug(debug_text)
L766
L767
L768 if __name__ == "__main__":
L769     main()
L770
```

## <.github/workflows/daily-report.yml>
```text
L1 name: Daily Stock Report
L2
L3 on:
L4   push:
L5     branches: [ main ]
L6     paths-ignore:
L7       - 'CodeForChat/**'
L8   schedule:
L9     - cron: '30 23 * * 2-6'  # UTC 23:30 → JST 08:30（火〜土）
L10   workflow_dispatch:
L11
L12 jobs:
L13   build-and-report:
L14     runs-on: ubuntu-latest
L15
L16     steps:
L17       - name: Debug start
L18         run: echo '🚀 DEBUGstarted'
L19               
L20       - name: Checkout repository
L21         uses: actions/checkout@v3
L22
L23       - name: Setup Python
L24         uses: actions/setup-python@v4
L25         with:
L26           python-version: '3.x'
L27
L28       - name: Install dependencies
L29         run: pip install -r requirements.txt
L30
L31       - name: Prepare results directory
L32         run: mkdir -p results
L33
L34       - name: Run drift.py
L35         env:
L36           SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
L37           FINNHUB_API_KEY: ${{ secrets.FINNHUB_API_KEY }}
L38         run: python drift.py
L39
L40       - name: Persist breadth_state.json
L41         if: always()
L42         run: |
L43           git config user.name  "github-actions[bot]"
L44           git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
L45           git add results/breadth_state.json || true
L46           git commit -m "chore: update breadth_state [skip ci]" || echo "no changes"
L47           git push || true
```

## <documents/README.md>
```text
L1 # 運用ルール（改訂版）
L2
L3 ## 基本構成
L4 - 20銘柄を均等配分（現金を除き1銘柄あたり5%）  
L5 - moomoo証券で運用  
L6 - **Growth枠 12銘柄 / Defense枠 8銘柄**
L7
L8 ---
L9
L10 ## Barbell Growth-Defense方針
L11 - **Growth枠（12銘柄）**：トレンドを追う**スイングトレード**。高成長・高ボラ銘柄でリターン源泉を狙う。  
L12 - **Defense枠（8銘柄）**：安定重視の**ポジショントレード（やや長期）**。低ボラ・高品質でMDDを抑制。  
L13 - 「猛烈に伸びる攻め × 着実に稼ぐ盾」の組合せで乖離を生み、**半戻しリバランス**でプレミアムを獲得。
L14
L15 ---
L16
L17 ## モード判定（コンボ：GコンポジットDD × ブレッドス）
L18
L19 **考え方：** *悪化はゆるく（OR）、回復は厳しく（AND）。Gが先行して良化すれば1段階回復*
L20
L21 ### ① GコンポジットDD（Growthのみ）
L22 - 対象：ポートフォリオのうち `bucket = "G"` の銘柄を Growth 群として集計
L23 - 算出：各G銘柄の `Low_today / Peak60(High)` を等加重平均し、`1 - 平均` を%表示（正の値が下落幅）
L24 - しきい値：**CAUTION = 10% / EMERG = 15%**
L25 - ログ：Slackとは別に、標準出力へ銘柄別の Peak60・Low・比率・DD% を降順で記録
L26
L27 ### ② ブレッドス（trend_template 合格本数）
L28 - current+candidate 全体で trend_template 条件を満たした銘柄数（基準 N_G=12）
L29 - 閾値：過去600営業日の分布から自動採用（分位点と運用“床”のmax）
L30   - 緊急入り: max(q05, 12本)
L31   - 緊急解除: max(q20, 18本)
L32   - 通常復帰: max(q60, 36本)
L33 - ヒステリシス：前回モードに依存（EMERG→解除は23本以上、CAUTION→通常は45本以上）
L34
L35 ### コンボルール
L36 - **悪化（ダウングレード）**：①と②のうちランクが高い方（NORMAL < CAUTION < EMERG）を採用 = OR悪化
L37   - 例：①=CAUTION, ②=NORMAL → final=CAUTION
L38   - 例：①=EMERG, ②=CAUTION → final=EMERG
L39
L40 - **回復（アップグレード）**：基本は①②がともに現在より下位モードに揃ったときのみ1段階回復 = AND回復
L41   - 例：EMERG→CAUTION は ①=CAUTION **かつ** ②=CAUTION
L42   - 例：CAUTION→NORMAL は ①=NORMAL **かつ** ②=NORMAL
L43   - ただし GコンポジットDD が先行して下位モードに改善した場合は、1段階だけ先行回復を許容
L44
L45 > 直感フレーズ：**「悪化はどちらか赤で赤、回復は両方青で青。Gが先に青なら1段階戻す」**
L46
L47 ---
L48
L49 ## モード別設定（現金・ドリフト・保有数）
L50
L51 | モード       | 現金比率 | ドリフト閾値      | 基本TS幅 | Growth枠数 | Defense枠数 | 補足 |
L52 |--------------|----------|-------------------|----------|------------|-------------|------|
L53 | **NORMAL**   | 10%      | 12%               | -15%     | 12         | 8           | フル20銘柄（現金化枠なし） |
L54 | **CAUTION**  | 20%      | 14%               | -13%     | 10         | 8           | Gを2枠外し=現金化10% + 追加10% |
L55 | **EMERG**    | 30%      | ドリフト売買停止 | -10%     | 8          | 8           | Gを4枠外し=現金化20% + 追加10% |
L56
L57 - 含み益到達時のTSタイト化：+30% → -3pt、+60% → -6pt、+100% → -8pt
L58 - 含み益 +100% 達成時は50%を利確し、残りはフリーポジションとして -15%TS で保有継続
L59 - TS発動後のクールダウンは廃止（翌日以降すぐに再IN可）
L60
L61 > 定数管理：現金比率・ドリフト閾値・TS・段階TS・推奨保有数・総枠は `config.py`
L62 > の `CASH_RATIO_BY_MODE / DRIFT_THRESHOLD_BY_MODE / TS_BASE_BY_MODE / TS_STEP_DELTAS_PT / COUNTS_BY_MODE / TOTAL_TARGETS`
L63 > を参照する。
L64
L65 ---
L66
L67 ## 新規買付
L68 - **新規INは等分比率（=5%）の半分まで**を上限。  
L69 - 追加補充や半戻し買付も同じ上限に従う。
L70
L71 ---
L72
L73 ## 半戻し（リバランス）
L74 1. **現金比率 ≤ 閾値**：過重量銘柄を売却し、不足銘柄を補充。  
L75 2. **現金比率 > 閾値**：**売却は行わず**、現金でドリフト不足銘柄を買付（現金比率を閾値以下へ戻すことを優先）。  
L76 3. **共通**：リバランス後は全銘柄のTSを再設定。EMERGでは「ドリフト売買停止」、20銘柄×5%全戻しのみ許容。
L77
L78 ---
L79
L80 ## モード移行の実務手順
L81 - モードが変わったら、**MMF≒現金**として扱い、Growth枠数だけ調整：  
L82   1. **Gを削る**（CAUTION/EMERG）：⭐️低スコアのGから順に外し、`current_tickers.csv` から行削除（=現金化）。  
L83   2. **現金として保持**。  
L84   3. **NORMAL復帰時の補充**：`current_tickers.csv` に銘柄を追加（スコア上位から）。以降は日次ドリフト/TSルールに従う。  
L85 > driftは `target_ratio = 1/銘柄数` を自動適用。行数に応じて均等比率を再計算。
L86
L87 ---
L88
L89 ## 入替銘柄選定
L90 - **ファクター分散最適化手法を用いて日次でスコア集計**し、**スコア上位からIN/OUT**を決定。  
L91 - 参考：Oxfordキャピタル、Alpha Investor、Motley Fool、moomooスクリーニング等。  
L92 - 年間NISA枠はGrowth群から低ボラ銘柄を選定し利用（長期保持に固執しない）。
L93
L94 ---
L95
L96 ## 実行タイミング
L97 - 判定：米国市場終値直後  
L98 - 執行：翌営業日の米国寄付き成行
```

## <documents/drift_design.md>
```text
L1 # drift.py 詳細設計書
L2
L3 ## 概要
L4 - 20銘柄ポートフォリオのドリフトを日次監視し、閾値超過時に半戻し案をSlack通知するスクリプト。
L5 - Finnhubとyfinanceから価格を取得（レジームは trend_template 本数に基づく（基準 N_G=12））。
L6   - 緊急入り: `max(q05, 12本)`
L7   - 緊急解除: `max(q20, 18本)` （ceil(1.5*12)）
L8   - 通常復帰: `max(q60, 36本)` （3*12）
L9
L10 ## 定数・設定
L11 - `FINNHUB_API_KEY` / `SLACK_WEBHOOK_URL` を環境変数から取得。
L12 - 無料枠を考慮したAPIレート制限: `RATE_LIMIT = 55`。
L13 - デバッグ出力用フラグ `debug_mode`。
L14
L15 ## 主な関数
L16 ### finnhub_get
L17 - 基本的なレート制限付きでFinnhub APIを呼び出し、JSONレスポンスを辞書で返す。
L18
L19 ### fetch_price
L20 - `quote` エンドポイントで株価を取得し、失敗時は `NaN` を返す。
L21
L22 ### fetch_vix_ma5
L23 - yfinanceでVIX終値を取得する関数。将来再利用のため残置。
L24
L25 ### load_portfolio
L26 - `current_tickers.csv` から銘柄と保有株数を読み込み、目標比率4%を付与したリストを生成。
L27
L28 ### compute_threshold_by_mode
L29 - モード(NORMAL/CAUTION/EMERG) に応じて **12% / 14% / 停止(∞)** を返す（`config.py` を参照）。
L30
L31 ### build_dataframe
L32 - 各銘柄の評価額や現在比率、ドリフト、半戻し後比率(`adjusted_ratio`)を計算しDataFrame化。
L33
L34 ### simulate
L35 - ドリフト合計が閾値を超えた場合、半戻し後の売買株数と新比率を試算し、シミュレート後ドリフトを返す。
L36
L37 ### prepare_summary
L38 - 評価額順に並べ替えた後、合計行を付与してSlack表示用テーブルを作成。
L39
L40 ### formatters_for / currency
L41 - 通貨・比率・株数の表示フォーマットを定義。
L42
L43 ### build_header
L44 - 現金保有率・閾値・ドリフト値およびアラート有無をSlackメッセージ用ヘッダに整形。TS(基本)はモード別に `config.py` から動的表示し、段階TSは base から -3/-6/-8 pt。
L45
L46 ### send_slack / send_debug
L47 - 通常通知およびデバッグ詳細をSlack Webhookへ送信。
L48
L49 ### main
L50 - 上記関数を順に呼び出し、日次ドリフトチェックの一連処理を実行。
L51
L52 ## 実行フロー
L53 1. `load_portfolio` で現ポートフォリオを読み込む。
L54 2. `build_breadth_header` でモードを取得し、`compute_threshold_by_mode` で現金保有率とドリフト閾値を決定。
L55 3. `build_dataframe` で現在比率とドリフトを計算。
L56 4. `simulate` で閾値超過時の半戻し案を試算。
L57 5. `prepare_summary` と `build_header` で通知本文とテーブルを構築。
L58 6. `send_slack` で結果を送信。`debug_mode` がTrueなら `send_debug` も併用。
```
