# === Chat Paste Pack ===
# Repo: dakara32/GPT_Code @ main
# Files: config.py, drift.py, .github/workflows/daily-report.yml, documents/README.md, documents/drift_design.md
# 作成日時: 2025-09-27 11:38:42 (JST)
# 使い方: 下のチャンクを順に貼ればこのチャットで全体把握できます。
# 注記: 各ファイルは個別に L1.. で行番号付与。
---

## <config.py>
```text
L1 # 共通設定（factor / drift から参照）
L2 TOTAL_TARGETS = 20
L3
L4 # 基準のバケット数（NORMAL）
L5 COUNTS_BASE = {"G": 12, "D": 8}
L6
L7 # モード別の推奨バケット数
L8 COUNTS_BY_MODE = {
L9     "NORMAL": {"G": 12, "D": 8},
L10     "CAUTION": {"G": 10, "D": 8},
L11     "EMERG": {"G": 8,  "D": 8},
L12 }
L13
L14 # モード別のドリフト閾値（%）
L15 DRIFT_THRESHOLD_BY_MODE = {"NORMAL": 12, "CAUTION": 14, "EMERG": float("inf")}
L16
L17 # モード別の推奨現金比率
L18 CASH_RATIO_BY_MODE = {
L19     "NORMAL": 0.10,  # 10%
L20     "CAUTION": 0.20,  # 20%
L21     "EMERG": 0.30,  # 30%
L22 }
L23
L24 # モード別のTS（基本幅, 小数=割合）
L25 TS_BASE_BY_MODE = {"NORMAL": 0.15, "CAUTION": 0.13, "EMERG": 0.10}
L26 # 利益到達(+30/+60/+100%)時の段階タイト化（ポイント差）
L27 TS_STEP_DELTAS_PT = (3, 6, 8)
L28
L29 # Breadthの校正は N_G に連動（緊急解除=ceil(1.5*N_G), 通常復帰=3*N_G）
L30 N_G = COUNTS_BASE["G"]
L31 N_D = COUNTS_BASE["D"]
L32
```

## <drift.py>
```text
L1 import pandas as pd, yfinance as yf
L2 import numpy as np
L3 import requests
L4 import os
L5 import json
L6 import time
L7 from pathlib import Path
L8 import csv
L9 import config
L10
L11 # --- GコンポジットDDのしきい値（Growthの平均DD基準）---
L12 CD_CAUTION = 0.10   # -10% で警戒
L13 CD_EMERG = 0.15   # -15% で緊急
L14
L15 MODE_LABELS_JA = {"NORMAL": "通常", "CAUTION": "警戒", "EMERG": "緊急"}
L16 # Slack通知用のモードアイコン
L17 MODE_EMOJIS = {"NORMAL": "🟢", "CAUTION": "⚠️", "EMERG": "🔴"}
L18 MODE_RANK = {"NORMAL": 0, "CAUTION": 1, "EMERG": 2}
L19
L20 # --- breadth utilities (factor parity) ---
L21 BENCH = "^GSPC"
L22 CAND_PRICE_MAX = 450.0
L23 RESULTS_DIR = "results"
L24 os.makedirs(RESULTS_DIR, exist_ok=True)
L25
L26
L27 def _state_file():
L28     """Return path to JSON storing the latest breadth/final mode state."""
L29
L30     return str(Path(RESULTS_DIR) / "current_mode.json")
L31
L32
L33 def _load_state_dict() -> dict:
L34     p = Path(_state_file())
L35     if not p.exists():
L36         return {}
L37     try:
L38         data = json.loads(p.read_text(encoding="utf-8") or "{}")
L39         return data if isinstance(data, dict) else {}
L40     except Exception:
L41         return {}
L42
L43
L44 def _save_state_dict(state: dict):
L45     try:
L46         Path(_state_file()).write_text(
L47             json.dumps(state, ensure_ascii=False, indent=2), encoding="utf-8"
L48         )
L49     except Exception:
L50         pass
L51
L52
L53 def load_breadth_mode(default: str = "NORMAL") -> str:
L54     state = _load_state_dict()
L55     mode = state.get("breadth_mode", state.get("mode", default))
L56     return mode if mode in MODE_RANK else default
L57
L58
L59 def save_breadth_mode(mode: str):
L60     return  # 参考値のため保存しない（no-op）
L61
L62
L63 def load_final_mode(default: str = "NORMAL") -> str:
L64     state = _load_state_dict()
L65     mode = state.get("final_mode", state.get("mode", default))
L66     return mode if mode in MODE_RANK else default
L67
L68
L69 def save_final_mode(mode: str):
L70     """状態ファイルは mode のみを保存（G-CDで決定）"""
L71     m = (mode or "NORMAL").upper().strip()
L72     Path(_state_file()).write_text(
L73         json.dumps({"mode": m}, ensure_ascii=False, indent=2),
L74         encoding="utf-8",
L75     )
L76
L77
L78 def _read_csv_list(fname):
L79     p = Path(__file__).with_name(fname)
L80     if not p.exists(): return []
L81     return pd.read_csv(p, header=None).iloc[:,0].astype(str).str.upper().tolist()
L82
L83
L84 # leaders.csv 読み込み（results/leaders.csv, 1列想定）
L85 def _read_leaders_symbols() -> list[str]:
L86     p = Path(__file__).with_name("results").joinpath("leaders.csv")
L87     df = pd.read_csv(p, header=None)
L88     return sorted(set(df.iloc[:,0].astype(str).str.strip().str.upper().tolist()))
L89
L90 def _load_universe():
L91     # exist + candidate を使用。candidate は価格上限で事前フィルタ
L92     exist = _read_csv_list("current_tickers.csv")
L93     cand  = _read_csv_list("candidate_tickers.csv")
L94     cand_info = yf.Tickers(" ".join(cand)) if cand else None
L95     cand_keep = []
L96     for t in cand:
L97         try:
L98             px = cand_info.tickers[t].fast_info.get("lastPrice", float("inf"))
L99         except Exception:
L100             px = float("inf")
L101         if pd.notna(px) and float(px) <= CAND_PRICE_MAX:
L102             cand_keep.append(t)
L103     tickers = sorted(set(exist + cand_keep))
L104     return exist, cand_keep, tickers
L105
L106
L107 def _fetch_prices_600d(tickers):
L108     data = yf.download(
L109         tickers + [BENCH],
L110         period="600d",
L111         auto_adjust=True,
L112         progress=False,
L113         threads=False,
L114     )
L115     close = data["Close"]
L116     px = close.dropna(how="all", axis=1).ffill(limit=2)
L117     spx = close[BENCH].reindex(px.index).ffill()
L118     return px, spx
L119
L120
L121 def trend_template_breadth_series(px: pd.DataFrame, spx: pd.Series, win_days: int | None = None) -> pd.Series:
L122     # scorer.py の実装をそのまま移植（ベクトル化版）
L123     import numpy as np, pandas as pd
L124     if px is None or px.empty:
L125         return pd.Series(dtype=int)
L126     px = px.dropna(how="all", axis=1)
L127     if win_days and win_days > 0:
L128         px = px.tail(win_days)
L129     if px.empty:
L130         return pd.Series(dtype=int)
L131     # 欠損吸収
L132     px = px.ffill(limit=2)
L133     spx = spx.reindex(px.index).ffill()
L134
L135     ma50  = px.rolling(50,  min_periods=50).mean()
L136     ma150 = px.rolling(150, min_periods=150).mean()
L137     ma200 = px.rolling(200, min_periods=200).mean()
L138
L139     tt = (px > ma150)
L140     tt &= (px > ma200)
L141     tt &= (ma150 > ma200)
L142     tt &= (ma200 - ma200.shift(21) > 0)
L143     tt &= (ma50  > ma150)
L144     tt &= (ma50  > ma200)
L145     tt &= (px    > ma50)
L146
L147     lo252 = px.rolling(252, min_periods=252).min()
L148     hi252 = px.rolling(252, min_periods=252).max()
L149     tt &= (px.divide(lo252).sub(1.0) >= 0.30)
L150     tt &= (px >= (0.75 * hi252))
L151
L152     r12  = px.divide(px.shift(252)).sub(1.0)
L153     br12 = spx.divide(spx.shift(252)).sub(1.0)
L154     r1   = px.divide(px.shift(22)).sub(1.0)
L155     br1  = spx.divide(spx.shift(22)).sub(1.0)
L156     rs   = 0.7*(r12.sub(br12, axis=0)) + 0.3*(r1.sub(br1, axis=0))
L157     tt &= (rs >= 0.10)
L158
L159     return tt.fillna(False).sum(axis=1).astype(int)
L160
L161
L162 def build_breadth_header():
L163     # factor._build_breadth_lead_lines と同一挙動
L164     exist, cand, tickers = _load_universe()
L165     if not tickers:
L166         return "", "NORMAL", 0
L167     px, spx = _fetch_prices_600d(tickers)
L168     win = int(os.getenv("BREADTH_CALIB_WIN_DAYS", "600"))
L169     C_ts = trend_template_breadth_series(px, spx, win_days=win)
L170     if C_ts.empty:
L171         return "", "NORMAL", 0
L172     warmup = int(os.getenv("BREADTH_WARMUP_DAYS","252"))
L173     base = C_ts.iloc[warmup:] if len(C_ts)>warmup else C_ts
L174     C_full = int(C_ts.iloc[-1])
L175
L176     q05 = int(np.nan_to_num(base.quantile(float(os.getenv("BREADTH_Q_EMERG_IN",  "0.05"))), nan=0.0))
L177     q20 = int(np.nan_to_num(base.quantile(float(os.getenv("BREADTH_Q_EMERG_OUT", "0.20"))), nan=0.0))
L178     q60 = int(np.nan_to_num(base.quantile(float(os.getenv("BREADTH_Q_WARN_OUT",  "0.60"))), nan=0.0))
L179
L180     # G枠サイズ（Breadth基準）
L181     N_G = config.N_G
L182     th_in_rec   = max(N_G, q05)
L183     th_out_rec  = max(int(np.ceil(1.5*N_G)), q20)
L184     th_norm_rec = max(3*N_G, q60)
L185
L186     use_calib = os.getenv("BREADTH_USE_CALIB", "true").strip().lower() == "true"
L187     if use_calib:
L188         th_in, th_out, th_norm, th_src = th_in_rec, th_out_rec, th_norm_rec, "自動"
L189     else:
L190         th_in   = int(os.getenv("GTT_EMERG_IN", str(N_G)))
L191         th_out  = int(os.getenv("GTT_EMERG_OUT", str(int(1.5*N_G))))
L192         th_norm = int(os.getenv("GTT_CAUTION_OUT", str(3*N_G)))
L193         th_src = "手動"
L194
L195     prev = load_breadth_mode("NORMAL")
L196     if   prev == "EMERG":
L197         mode = "EMERG"   if (C_full < th_out)  else ("CAUTION" if (C_full < th_norm) else "NORMAL")
L198     elif prev == "CAUTION":
L199         mode = "CAUTION" if (C_full < th_norm) else "NORMAL"
L200     else:
L201         mode = "EMERG"   if (C_full < th_in)   else ("CAUTION" if (C_full < th_norm) else "NORMAL")
L202     save_breadth_mode(mode)
L203
L204     mode_ja, emoji = MODE_LABELS_JA.get(mode, mode), MODE_EMOJIS.get(mode, "ℹ️")
L205     eff_days = len(base)
L206
L207     lead_lines = [
L208         f"{emoji} *現在モード: {mode_ja}*",
L209         f"テンプレ合格本数: *{C_full}本*",
L210         "しきい値（{0}）".format(th_src),
L211         f"  ・緊急入り: <{th_in}本",
L212         f"  ・緊急解除: ≥{th_out}本",
L213         f"  ・通常復帰: ≥{th_norm}本",
L214         f"参考指標（過去~{win}営業日, 有効={eff_days}日）",
L215         f"  ・下位5%: {q05}本",
L216         f"  ・下位20%: {q20}本",
L217         f"  ・60%分位: {q60}本",
L218     ]
L219     return "```" + "\n".join(lead_lines) + "```", mode, C_full
L220
L221
L222 def _format_mode(mode: str) -> str:
L223     upper = (mode or "NORMAL").upper()
L224     return f"{MODE_EMOJIS.get(upper, 'ℹ️')} {MODE_LABELS_JA.get(upper, upper)}"
L225
L226
L227 def _gcd_mode_today(g_syms: list[str]) -> tuple[str, float]:
L228     """
L229     現在のGrowth群について、Low_today / Peak60(High) の等加重平均から G-CD(%) を算出し、モードを返す。
L230     戻り値: (gcd_mode, gcd_pct)  ※gcd_pctは正の%（例 11.3 は -11.3%の下落）
L231     """
L232
L233     if not g_syms:
L234         print("📝 audit[G-CD details]: G銘柄が空のため算出対象がありません")
L235         print("📝 audit[G-CD summary]: avg_low/peak60=1.0000  drawdown=0.00%  => NORMAL")
L236         return "NORMAL", 0.0
L237
L238     try:
L239         df = yf.download(
L240             g_syms,
L241             period="100d",
L242             interval="1d",
L243             auto_adjust=False,
L244             progress=False,
L245         )
L246     except Exception as e:
L247         print(f"⚠️ audit[G-CD details]: 株価データ取得に失敗しました ({e})")
L248         print("📝 audit[G-CD summary]: avg_low/peak60=1.0000  drawdown=0.00%  => NORMAL")
L249         return "NORMAL", 0.0
L250
L251     if not isinstance(df, pd.DataFrame) or df.empty:
L252         print("⚠️ audit[G-CD details]: 株価データが空のため算出できません")
L253         print("📝 audit[G-CD summary]: avg_low/peak60=1.0000  drawdown=0.00%  => NORMAL")
L254         return "NORMAL", 0.0
L255
L256     hi_all = df.get("High") if isinstance(df, pd.DataFrame) else None
L257     lo_all = df.get("Low") if isinstance(df, pd.DataFrame) else None
L258     if hi_all is None or lo_all is None:
L259         print("⚠️ audit[G-CD details]: High/Low データが欠落しています")
L260         print("📝 audit[G-CD summary]: avg_low/peak60=1.0000  drawdown=0.00%  => NORMAL")
L261         return "NORMAL", 0.0
L262
L263     if isinstance(hi_all, pd.Series):
L264         hi_all = hi_all.to_frame(name=g_syms[0])
L265     if isinstance(lo_all, pd.Series):
L266         lo_all = lo_all.to_frame(name=g_syms[0])
L267
L268     if hi_all.empty or lo_all.empty:
L269         print("⚠️ audit[G-CD details]: High/Low データが空のため算出できません")
L270         print("📝 audit[G-CD summary]: avg_low/peak60=1.0000  drawdown=0.00%  => NORMAL")
L271         return "NORMAL", 0.0
L272
L273     peak60 = hi_all.rolling(60, min_periods=20).max().tail(1).iloc[0]
L274     low_today = lo_all.tail(1).iloc[0]
L275
L276     details: list[tuple[str, float, float, float, float]] = []
L277     for sym in g_syms:
L278         p = float(peak60.get(sym, float("nan"))) if hasattr(peak60, "get") else float("nan")
L279         lt = float(low_today.get(sym, float("nan"))) if hasattr(low_today, "get") else float("nan")
L280         if pd.notna(p) and p > 0 and pd.notna(lt) and lt > 0:
L281             ratio = lt / p
L282             ddpct = (1.0 - ratio) * 100.0
L283             details.append((sym, p, lt, ratio, ddpct))
L284
L285     if not details:
L286         print("⚠️ audit[G-CD details]: 有効な銘柄データがありません")
L287         print("📝 audit[G-CD summary]: avg_low/peak60=1.0000  drawdown=0.00%  => NORMAL")
L288         return "NORMAL", 0.0
L289
L290     details.sort(key=lambda x: x[4], reverse=True)
L291     today = pd.Timestamp.today(tz="America/New_York").date().isoformat()
L292     print(f"📝 audit[G-CD details] {today}  G={len(g_syms)}")
L293     print("  SYMBOL        Peak60(H)     Low(T)     ratio    DD%")
L294     for sym, peak, low, ratio, ddpct in details:
L295         print(f"  {sym:<8}  {peak:>12.6g}  {low:>10.6g}   {ratio:>6.3f}  {ddpct:>6.2f}")
L296
L297     avg_ratio = float(np.mean([r for _, _, _, r, _ in details]))
L298     gcd_pct = max(0.0, (1.0 - avg_ratio) * 100.0)
L299     mode = "EMERG" if gcd_pct >= CD_EMERG * 100 else "CAUTION" if gcd_pct >= CD_CAUTION * 100 else "NORMAL"
L300     print(
L301         f"📝 audit[G-CD summary]: avg_low/peak60={avg_ratio:.4f}  drawdown={gcd_pct:.2f}%  => {mode}"
L302     )
L303     return mode, gcd_pct
L304 # Debug flag
L305 debug_mode = False  # set to True for detailed output
L306
L307 # --- Finnhub settings & helper ---
L308 FINNHUB_API_KEY = os.environ.get("FINNHUB_API_KEY")
L309 if not FINNHUB_API_KEY:
L310     raise ValueError("FINNHUB_API_KEY not set (環境変数が未設定です)")
L311
L312 RATE_LIMIT = 55  # requests per minute (free tier is 60)
L313 call_times = []
L314
L315
L316 def finnhub_get(endpoint, params):
L317     """Call Finnhub API with basic rate limiting."""
L318     now = time.time()
L319     cutoff = now - 60
L320     while call_times and call_times[0] < cutoff:
L321         call_times.pop(0)
L322     if len(call_times) >= RATE_LIMIT:
L323         sleep_time = 60 - (now - call_times[0])
L324         time.sleep(sleep_time)
L325     params = {**params, "token": FINNHUB_API_KEY}
L326     try:
L327         resp = requests.get(f"https://finnhub.io/api/v1/{endpoint}", params=params)
L328         resp.raise_for_status()
L329         data = resp.json()
L330     except requests.exceptions.JSONDecodeError as e:
L331         print(f"⚠️ Finnhub API JSON decode error: {e}")
L332         return {}
L333     except Exception as e:
L334         print(f"⚠️ Finnhub API error: {e}")
L335         return {}
L336     call_times.append(time.time())
L337     return data
L338
L339
L340 def fetch_price(symbol):
L341     try:
L342         data = finnhub_get("quote", {"symbol": symbol})
L343         price = data.get("c")
L344         return float(price) if price not in (None, 0) else float("nan")
L345     except Exception:
L346         return float("nan")
L347
L348
L349 def fetch_vix_ma5():
L350     """Retrieve VIX 5-day moving average via yfinance."""
L351     try:
L352         vix = (
L353             yf.download("^VIX", period="7d", interval="1d", progress=False, auto_adjust=False)["Close"]
L354             .dropna()
L355             .tail(5)
L356         )
L357         if len(vix) < 5:
L358             return float("nan")
L359         return vix.mean().item()
L360     except Exception:
L361         return float("nan")
L362
L363
L364
L365 # === Minervini-like sell signals ===
L366 def _yf_df(sym, period="6mo"):
L367     """日足/MA/出来高平均を取得。欠損時は None。"""
L368     try:
L369         df = yf.download(sym, period=period, interval="1d", auto_adjust=False, progress=False)
L370         if df is None or df.empty:
L371             return None
L372         return df.dropna().assign(
L373             ma20=lambda d: d["Close"].rolling(20).mean(),
L374             ma50=lambda d: d["Close"].rolling(50).mean(),
L375             vol50=lambda d: d["Volume"].rolling(50).mean(),
L376         )
L377     except Exception:
L378         return None
L379
L380
L381 def _scalar(row, col):
L382     """Series/npスカラ→Pythonスカラ化（NaNはNaNのまま）"""
L383     try:
L384         v = row[col]
L385         if hasattr(v, "item"):
L386             try:
L387                 v = v.item()
L388             except Exception:
L389                 pass
L390         return v
L391     except Exception:
L392         return float("nan")
L393
L394
L395 def _is_strict_down(seq):
L396     """数列が厳密に連続で切り下がっているか（len>=4を想定）。NaN含みはFalse。"""
L397     try:
L398         xs = [float(x) for x in seq]
L399         if any(pd.isna(x) for x in xs) or len(xs) < 4:
L400             return False
L401         return all(b < a for a, b in zip(xs[:-1], xs[1:]))
L402     except Exception:
L403         return False
L404
L405
L406 def _signals_for_day(df, idx):
L407     """df.loc[idx] 1日分に対しシグナル配列を返す（値動き/出来高ベースのみ）。"""
L408     try:
L409         sig = []
L410         d = df.loc[idx]
L411         close = _scalar(d, "Close")
L412         ma20 = _scalar(d, "ma20")
L413         ma50 = _scalar(d, "ma50")
L414         vol = _scalar(d, "Volume")
L415         vol50 = _scalar(d, "vol50")
L416
L417         if pd.notna(close) and pd.notna(ma20) and close < ma20:
L418             sig.append("20DMA↓")
L419
L420         if all(pd.notna(x) for x in (close, ma50, vol, vol50)) and close < ma50 and vol > 1.5 * vol50:
L421             sig.append("50DMA↓(大商い)")
L422
L423         last4 = df.loc[:idx].tail(4)
L424         last10 = df.loc[:idx].tail(10)
L425
L426         lows_desc = _is_strict_down(last4["Low"].tolist()) if last4["Low"].notna().all() else False
L427         reds = int((last10["Close"] < last10["Open"]).sum()) if last10[["Close", "Open"]].notna().all().all() else 0
L428         if lows_desc or reds > 5:
L429             sig.append("連続安値/陰線優勢")
L430
L431         ups = int((last10["Close"] > last10["Open"]).sum()) if last10[["Close", "Open"]].notna().all().all() else 0
L432         if ups >= 7:
L433             sig.append("上げ偏重(>70%)")
L434
L435         last15 = df.loc[:idx].tail(15)
L436         base0 = _scalar(last15.iloc[0], "Close") if len(last15) > 0 else float("nan")
L437         if pd.notna(base0) and pd.notna(close) and base0 != 0 and (close / base0 - 1) >= 0.25:
L438             sig.append("+25%/15日内")
L439
L440         if len(df.loc[:idx]) >= 2:
L441             t1, t0 = df.loc[:idx].iloc[-2], df.loc[:idx].iloc[-1]
L442             t1_high = _scalar(t1, "High")
L443             t0_open = _scalar(t0, "Open")
L444             t0_close = _scalar(t0, "Close")
L445             if all(pd.notna(x) for x in (t1_high, t0_open, t0_close)):
L446                 if (t0_open > t1_high * 1.02) and (t0_close < t0_open):
L447                     sig.append("GU→陰線")
L448         return sig
L449     except Exception:
L450         return []
L451
L452
L453 def scan_sell_signals(symbols, lookback_days=5):
L454     """
L455     直近 lookback_days 日のうち一度でもシグナルが出たら {sym: [(date,[signals]),...]} を返す。
L456     日付は YYYY-MM-DD。Slackで列挙する。
L457     """
L458     out = {}
L459     for s in symbols:
L460         df = _yf_df(s)
L461         if df is None or len(df) < 60:
L462             continue
L463         alerts = []
L464         for idx in df.tail(lookback_days).index:
L465             tags = _signals_for_day(df, idx)
L466             if tags:
L467                 alerts.append((idx.strftime("%Y-%m-%d"), tags))
L468         if alerts:
L469             out[s] = alerts
L470     return out
L471
L472
L473 def load_portfolio():
L474     tickers_path = Path(__file__).with_name("current_tickers.csv")
L475     with tickers_path.open() as f:
L476         rows = [row for row in csv.reader(f) if row and row[0].strip()]
L477     n = len(rows)
L478     portfolio = []
L479     for row in rows:
L480         sym = row[0].strip().upper()
L481         qty = int(row[1]) if len(row) > 1 and row[1].strip() else 0
L482         bucket = row[2].strip().upper() if len(row) > 2 else ""
L483         entry = {
L484             "symbol": sym,
L485             "shares": qty,
L486             "target_ratio": 1 / n if n else 0.0,
L487             "bucket": bucket,
L488         }
L489         portfolio.append(entry)
L490     return portfolio
L491
L492
L493 def compute_threshold():
L494     vix_ma5 = fetch_vix_ma5()
L495     drift_threshold = 10 if vix_ma5 < 20 else 12 if vix_ma5 < 26 else float("inf")
L496     return vix_ma5, drift_threshold
L497
L498
L499 def compute_threshold_by_mode(mode: str):
L500     """モードに応じて現金保有率とドリフト閾値を返す（README準拠）"""
L501     m = (mode or "NORMAL").upper()
L502     cash_ratio = config.CASH_RATIO_BY_MODE.get(
L503         m, config.CASH_RATIO_BY_MODE.get("NORMAL", 0.10)
L504     )
L505     drift_threshold = config.DRIFT_THRESHOLD_BY_MODE.get(
L506         m, config.DRIFT_THRESHOLD_BY_MODE.get("NORMAL", 12)
L507     )
L508     return cash_ratio, drift_threshold
L509
L510
L511 def recommended_counts_by_mode(mode: str) -> tuple[int, int, int]:
L512     """
L513     モード別の推奨保有数 (G_count, D_count, cash_slots) を返す。
L514     cash_slotsは「外すG枠の数」（各枠=5%）。
L515     NORMAL: G12/D8/現金化0, CAUTION: G10/D8/現金化2, EMERG: G8/D8/現金化4
L516     """
L517     m = (mode or "NORMAL").upper()
L518     base = config.COUNTS_BY_MODE.get("NORMAL", config.COUNTS_BASE)
L519     now  = config.COUNTS_BY_MODE.get(m, base)
L520     cash_slots = max(0, base["G"] - now["G"])
L521     return now["G"], now["D"], cash_slots
L522
L523
L524 def _mode_tail_line(final_mode: str) -> str:
L525     """①ブロック内の“このモードの設定”を改行＋アイコンで整形（📊は表示しない）"""
L526     fm = (final_mode or "NORMAL").upper()
L527     base_ts = config.TS_BASE_BY_MODE.get(fm, config.TS_BASE_BY_MODE.get("NORMAL", 0.15))
L528     ts_base_pct = int(round(base_ts * 100))
L529     d1, d2, d3 = config.TS_STEP_DELTAS_PT
L530     step30 = max(ts_base_pct - d1, 0)
L531     step60 = max(ts_base_pct - d2, 0)
L532     step100 = max(ts_base_pct - d3, 0)
L533     g_cnt, d_cnt, cash_slots = recommended_counts_by_mode(fm)
L534     cash_pct = config.CASH_RATIO_BY_MODE.get(fm, config.CASH_RATIO_BY_MODE.get("NORMAL", 0.10)) * 100
L535     return "\n".join([
L536         "〔このモードの設定〕",
L537         f"🎯 TS基本: -{ts_base_pct}％（+30%→-{step30}％／+60%→-{step60}％／+100%→-{step100}％）",
L538         f"🧩 推奨保有: G{g_cnt}・D{d_cnt}（現金化枠 {cash_slots}）",
L539         f"💼 推奨現金比率: {cash_pct:.0f}％",
L540     ])
L541
L542
L543 def build_dataframe(portfolio):
L544     for stock in portfolio:
L545         price = fetch_price(stock["symbol"])
L546         stock["price"] = price
L547         stock["value"] = price * stock["shares"]
L548
L549     df = pd.DataFrame(portfolio)
L550     total_value = df["value"].sum()
L551     df["current_ratio"] = df["value"] / total_value
L552     df["drift"] = df["current_ratio"] - df["target_ratio"]
L553     df["drift_abs"] = df["drift"].abs()
L554     total_drift_abs = df["drift_abs"].sum()
L555     df["adjusted_ratio"] = df["current_ratio"] - df["drift"] / 2
L556     df["adjustable"] = (
L557         (df["adjusted_ratio"] * total_value) >= df["price"]
L558     ) & df["price"].notna() & df["price"].gt(0)
L559     return df, total_value, total_drift_abs
L560
L561
L562 def simulate(df, total_value, total_drift_abs, drift_threshold):
L563     alert = drift_threshold != float("inf") and total_drift_abs * 100 > drift_threshold
L564     if alert:
L565         df["trade_shares"] = df.apply(
L566             lambda r: int(round(((r["adjusted_ratio"] * total_value) - r["value"]) / r["price"]))
L567             if r["adjustable"] and r["price"] > 0 else 0,
L568             axis=1,
L569         )
L570         df["new_shares"] = df["shares"] + df["trade_shares"]
L571         df["new_value"] = df["new_shares"] * df["price"]
L572         new_total_value = df["new_value"].sum()
L573         df["simulated_ratio"] = df["new_value"] / new_total_value
L574         df["simulated_drift_abs"] = (df["simulated_ratio"] - df["target_ratio"]).abs()
L575         simulated_total_drift_abs = df["simulated_drift_abs"].sum()
L576     else:
L577         df["trade_shares"] = np.nan
L578         df["new_shares"] = np.nan
L579         df["new_value"] = np.nan
L580         new_total_value = np.nan
L581         df["simulated_ratio"] = np.nan
L582         df["simulated_drift_abs"] = np.nan
L583         simulated_total_drift_abs = np.nan
L584     return df, alert, new_total_value, simulated_total_drift_abs
L585
L586
L587 def prepare_summary(df, total_drift_abs, alert):
L588     summary = {
L589         "symbol": "合計",
L590         "shares": df["shares"].sum(),
L591         "value": df["value"].sum(),
L592         "current_ratio": np.nan,
L593         "drift_abs": total_drift_abs,
L594     }
L595     if alert:
L596         summary["trade_shares"] = np.nan
L597     # Sort details by evaluation value descending before appending summary
L598     df = df.sort_values(by="value", ascending=False)
L599     df = pd.concat([df, pd.DataFrame([summary])], ignore_index=True)
L600     if alert:
L601         cols = ["symbol", "shares", "value", "current_ratio", "drift_abs", "trade_shares"]
L602         df_small = df[cols].copy()
L603         df_small.columns = ["sym", "qty", "val", "now", "|d|", "Δqty"]
L604     else:
L605         cols = ["symbol", "shares", "value", "current_ratio", "drift_abs"]
L606         df_small = df[cols].copy()
L607         df_small.columns = ["sym", "qty", "val", "now", "|d|"]
L608     return df_small
L609
L610
L611 def currency(x):
L612     return f"${x:,.0f}" if pd.notnull(x) else ""
L613
L614
L615 def formatters_for(alert):
L616     formatters = {"val": currency, "now": "{:.2%}".format, "|d|": "{:.2%}".format}
L617     if alert:
L618         formatters["Δqty"] = "{:.0f}".format
L619     return formatters
L620
L621
L622 def build_header(mode, cash_ratio, drift_threshold, total_drift_abs, alert, simulated_total_drift_abs):
L623     # 下段ヘッダ：📊と📉のみ（💼は①へ集約済み）
L624     header  = f"*📊 ドリフト閾値:* {'🔴(停止)' if drift_threshold == float('inf') else str(int(drift_threshold)) + '%'}\n"
L625     header += f"*📉 現在のドリフト合計:* {total_drift_abs * 100:.2f}%\n"
L626     if alert:
L627         header += f"*🔁 半戻し後ドリフト合計(想定):* {simulated_total_drift_abs * 100:.2f}%\n"
L628         header += "🚨 *アラート: 発生！！ Δqtyのマイナス銘柄を売却、任意の銘柄を買い増してバランスを取りましょう！*\n"
L629     else:
L630         header += "✅ アラートなし\n"
L631     return header
L632
L633
L634 def send_slack(text):
L635     SLACK_WEBHOOK_URL = os.environ.get("SLACK_WEBHOOK_URL")
L636     if not SLACK_WEBHOOK_URL:
L637         raise ValueError("SLACK_WEBHOOK_URL not set (環境変数が未設定です)")
L638     payload = {"text": text}
L639     try:
L640         resp = requests.post(SLACK_WEBHOOK_URL, json=payload)
L641         resp.raise_for_status()
L642         print("✅ Slack（Webhook）へ送信しました")
L643     except Exception as e:
L644         print(f"⚠️ Slack通知エラー: {e}")
L645
L646
L647 def send_debug(debug_text):
L648     SLACK_WEBHOOK_URL = os.environ.get("SLACK_WEBHOOK_URL")
L649     if not SLACK_WEBHOOK_URL:
L650         raise ValueError("SLACK_WEBHOOK_URL not set (環境変数が未設定です)")
L651     debug_payload = {"text": "```" + debug_text + "```"}
L652     try:
L653         resp = requests.post(SLACK_WEBHOOK_URL, json=debug_payload)
L654         resp.raise_for_status()
L655         print("✅ Debug情報をSlackに送信しました")
L656     except Exception as e:
L657         print(f"⚠️ Slack通知エラー: {e}")
L658
L659
L660 def main():
L661     portfolio = load_portfolio()
L662     symbols = [r["symbol"] for r in portfolio]
L663     # G集合は leaders.csv を使用（存在前提）
L664     g_syms = _read_leaders_symbols()
L665     sell_alerts = scan_sell_signals(symbols, lookback_days=5)
L666
L667     breadth_block, breadth_mode, breadth_score = build_breadth_header()
L668     gcd_mode, gcd_pct = _gcd_mode_today(g_syms)
L669
L670     # モードは GコンポジットDD のみで決定（シンプル化）
L671     final_mode = gcd_mode
L672     save_final_mode(final_mode)
L673
L674     cash_ratio, drift_threshold = compute_threshold_by_mode(final_mode)
L675
L676     df, total_value, total_drift_abs = build_dataframe(portfolio)
L677     df, alert, new_total_value, simulated_total_drift_abs = simulate(
L678         df, total_value, total_drift_abs, drift_threshold
L679     )
L680     df_small = prepare_summary(df, total_drift_abs, alert)
L681     if 'df_small' in locals() and isinstance(df_small, pd.DataFrame) and not df_small.empty:
L682         col_sym = "sym" if "sym" in df_small.columns else ("symbol" if "symbol" in df_small.columns else None)
L683         if col_sym:
L684             alert_keys = {str(k) for k in sell_alerts.keys()}
L685             df_small[col_sym] = df_small[col_sym].astype(str)
L686             df_small.insert(0, "⚠", df_small[col_sym].map(lambda x: "🔴" if x in alert_keys else ""))
L687             latest_tag = {s: " / ".join(sell_alerts[s][-1][1]) for s in sell_alerts}
L688             df_small.insert(1, "sig", df_small[col_sym].map(latest_tag).fillna(""))
L689     formatters = formatters_for(alert)
L690     header_core = build_header(
L691         final_mode, cash_ratio, drift_threshold, total_drift_abs, alert, simulated_total_drift_abs
L692     )
L693
L694     # --- Slack送信：①（判定＋このモードの設定）と②（Breadth詳細）を確実に二分割 ---
L695     me_g = MODE_EMOJIS.get(gcd_mode, "")
L696     me_b = MODE_EMOJIS.get(breadth_mode, "")
L697     block_gcd = (
L698         f"① GコンポジットDD: -{gcd_pct:.1f}%"
L699         f"（基準: C={CD_CAUTION*100:.0f}% / E={CD_EMERG*100:.0f}%） 判定: {me_g} {gcd_mode}"
L700     )
L701     # ①ブロック：ここまで＋このモードの設定（📊はここに出さない）
L702     first_block = "```\n" + block_gcd + "\n" + _mode_tail_line(final_mode) + "\n```"
L703
L704     # ②ブロック：Breadthのみ（“総合（参考表示）”は廃止）
L705     block_breadth = f"② Breadth: {me_b} {breadth_mode}（テンプレ合格本数: {breadth_score}）"
L706     # breadth_block の中身（コードフェンス除去＋重複行を除去）
L707     breadth_details = ""
L708     if breadth_block:
L709         inner = breadth_block
L710         if inner.startswith("```"):
L711             inner = inner[len("```"):]
L712             if inner.startswith("\n"):
L713                 inner = inner[1:]
L714             if inner.endswith("```"):
L715                 inner = inner[:-3]
L716         # ②タイトルで既出の行は削除
L717         inner_lines = [ln for ln in inner.splitlines() if ("現在モード" not in ln and "テンプレ合格本数" not in ln)]
L718         breadth_details = "\n".join(inner_lines).strip()
L719     second_body = block_breadth + ("\n" + breadth_details if breadth_details else "")
L720     second_block = "```\n" + second_body.strip() + "\n```"
L721
L722     # 連続コードブロックが結合されないよう空行を1行追加
L723     header = first_block + "\n\n" + second_block + "\n" + header_core
L724     if sell_alerts:
L725         def fmt_pair(date_tags):
L726             date, tags = date_tags
L727             return f"{date}:" + "・".join(tags)
L728         listed = []
L729         for t, arr in sell_alerts.items():
L730             listed.append(f"*{t}*（" + ", ".join(fmt_pair(x) for x in arr) + "）")
L731         hits = ", ".join(listed)
L732         if "✅ アラートなし" in header:
L733             header = header.replace(
L734                 "✅ アラートなし",
L735                 f"⚠️ 売りシグナルあり: {len(sell_alerts)}銘柄\n🟥 {hits}",
L736             )
L737         else:
L738             header += f"\n🟥 {hits}"
L739     table_text = df_small.to_string(formatters=formatters, index=False)
L740     send_slack(header + "\n```" + table_text + "```")
L741
L742     if debug_mode:
L743         debug_cols = [
L744             "symbol",
L745             "shares",
L746             "price",
L747             "value",
L748             "current_ratio",
L749             "drift",
L750             "drift_abs",
L751             "adjusted_ratio",
L752             "adjustable",
L753             "trade_shares",
L754             "new_shares",
L755             "new_value",
L756             "simulated_ratio",
L757             "simulated_drift_abs",
L758         ]
L759         debug_text = (
L760             "=== DEBUG: full dataframe ===\n"
L761             + df[debug_cols].to_string()
L762             + f"\n\ntotal_value={total_value}, new_total_value={new_total_value}\n"
L763             + f"total_drift_abs={total_drift_abs}, simulated_total_drift_abs={simulated_total_drift_abs}"
L764         )
L765         print("\n" + debug_text)
L766         send_debug(debug_text)
L767
L768
L769 if __name__ == "__main__":
L770     main()
L771
```

## <.github/workflows/daily-report.yml>
```text
L1 name: Daily Stock Report
L2
L3 on:
L4   push:
L5     branches: [ main ]
L6     paths-ignore:
L7       - 'CodeForChat/**'
L8   schedule:
L9     - cron: '30 23 * * 2-6'  # UTC 23:30 → JST 08:30（火〜土）
L10   workflow_dispatch:
L11
L12 permissions:
L13   contents: write
L14
L15 jobs:
L16   build-and-report:
L17     runs-on: ubuntu-latest
L18
L19     steps:
L20       - name: Debug start
L21         run: echo '🚀 DEBUGstarted'
L22               
L23       - name: Checkout repository
L24         uses: actions/checkout@v4
L25         with:
L26           fetch-depth: 0
L27
L28       - name: Setup Python
L29         uses: actions/setup-python@v4
L30         with:
L31           python-version: '3.x'
L32
L33       - name: Install dependencies
L34         run: pip install -r requirements.txt
L35
L36       - name: Prepare results directory
L37         run: mkdir -p results
L38
L39       - name: Run drift.py
L40         env:
L41           SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
L42           FINNHUB_API_KEY: ${{ secrets.FINNHUB_API_KEY }}
L43         run: python drift.py
L44
L45       - name: Commit results if changed
L46         if: ${{ github.event_name != 'pull_request' }}
L47         run: |
L48           git config user.name  "github-actions[bot]"
L49           git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
L50           git add results/ || true
L51           if git diff --cached --quiet; then
L52             echo "No changes to commit."
L53             exit 0
L54           fi
L55           git pull --rebase --autostash origin "${GITHUB_REF_NAME:-$GITHUB_REF}" || true
L56           git commit -m "ci: update results [skip ci]"
L57           git push origin HEAD:${GITHUB_REF_NAME:-$GITHUB_REF}
```

## <documents/README.md>
```text
L1 # 運用ルール（改訂版）
L2
L3 ## 基本構成
L4 - 20銘柄を均等配分（現金を除き1銘柄あたり5%）  
L5 - moomoo証券で運用  
L6 - **Growth枠 12銘柄 / Defense枠 8銘柄**
L7
L8 ---
L9
L10 ## Barbell Growth-Defense方針
L11 - **Growth枠（12銘柄）**：トレンドを追う**スイングトレード**。高成長・高ボラ銘柄でリターン源泉を狙う。  
L12 - **Defense枠（8銘柄）**：安定重視の**ポジショントレード（やや長期）**。低ボラ・高品質でMDDを抑制。  
L13 - 「猛烈に伸びる攻め × 着実に稼ぐ盾」の組合せで乖離を生み、**半戻しリバランス**でプレミアムを獲得。
L14
L15 ---
L16
L17 ## モード判定（GコンポジットDDのみ／Breadthは参考指標）
L18
L19 **考え方：** *悪化はゆるく（OR）、回復は厳しく（AND）。Gが先行して良化すれば1段階回復*
L20
L21 ### ① GコンポジットDD（Growthのみ・**最終モードはこれで決定**）
L22 - 対象：ポートフォリオのうち `bucket = "G"` の銘柄を Growth 群として集計
L23 - 算出：各G銘柄の `Low_today / Peak60(High)` を等加重平均し、`1 - 平均` を%表示（正の値が下落幅）
L24 - しきい値：**CAUTION = 10% / EMERG = 15%**
L25 - ログ：Slackとは別に、標準出力へ銘柄別の Peak60・Low・比率・DD% を降順で記録
L26
L27 ### ② ブレッドス（trend_template 合格本数）※**参考表示のみ**
L28 - current+candidate 全体で trend_template 条件を満たした銘柄数（基準 N_G=12）
L29 - 閾値：過去600営業日の分布から自動採用（分位点と運用“床”のmax）
L30   - 緊急入り: max(q05, 12本)
L31   - 緊急解除: max(q20, 18本)
L32   - 通常復帰: max(q60, 36本)
L33 - ヒステリシス：前回モードに依存（EMERG→解除は23本以上、CAUTION→通常は45本以上）
L34
L35 > メモ：Breadthは市場の体温計として併記するが、**モードの決定はGコンポジットDDのみ**。
L36
L37 ---
L38
L39 ## モード別設定（現金・ドリフト・保有数）
L40
L41 | モード       | 現金比率 | ドリフト閾値      | 基本TS幅 | Growth枠数 | Defense枠数 | 補足 |
L42 |--------------|----------|-------------------|----------|------------|-------------|------|
L43 | **NORMAL**   | 10%      | 12%               | -15%     | 12         | 8           | フル20銘柄（現金化枠なし） |
L44 | **CAUTION**  | 20%      | 14%               | -13%     | 10         | 8           | Gを2枠外し=現金化10% + 追加10% |
L45 | **EMERG**    | 30%      | ドリフト売買停止 | -10%     | 8          | 8           | Gを4枠外し=現金化20% + 追加10% |
L46
L47 - 含み益到達時のTSタイト化：+30% → -3pt、+60% → -6pt、+100% → -8pt
L48 - 含み益 +100% 達成時は50%を利確し、残りはフリーポジションとして -15%TS で保有継続
L49 - TS発動後のクールダウンは廃止（翌日以降すぐに再IN可）
L50
L51 <!-- 冗長な定数管理の注記は削除。実装は config.py に準拠。 -->
L52
L53 ---
L54
L55 ## 新規買付
L56 - **新規INは等分比率（=5%）の半分まで**を上限。  
L57 - 追加補充や半戻し買付も同じ上限に従う。
L58
L59 ---
L60
L61 ## 半戻し（リバランス）
L62 1. **現金比率 ≤ 閾値**：過重量銘柄を売却し、不足銘柄を補充。  
L63 2. **現金比率 > 閾値**：**売却は行わず**、現金でドリフト不足銘柄を買付（現金比率を閾値以下へ戻すことを優先）。  
L64 3. **共通**：リバランス後は全銘柄のTSを再設定。EMERGでは「ドリフト売買停止」、20銘柄×5%全戻しのみ許容。
L65
L66 ---
L67
L68 ## モード移行の実務手順
L69 - モードが変わったら、**MMF≒現金**として扱い、Growth枠数だけ調整：  
L70   1. **Gを削る**（CAUTION/EMERG）：⭐️低スコアのGから順に外し、`current_tickers.csv` から行削除（=現金化）。  
L71   2. **現金として保持**。  
L72   3. **NORMAL復帰時の補充**：`current_tickers.csv` に銘柄を追加（スコア上位から）。以降は日次ドリフト/TSルールに従う。  
L73 > driftは `target_ratio = 1/銘柄数` を自動適用。行数に応じて均等比率を再計算。
L74
L75 ---
L76
L77 ## 入替銘柄選定
L78 - **ファクター分散最適化手法を用いて日次でスコア集計**し、**スコア上位からIN/OUT**を決定。  
L79 - 参考：Oxfordキャピタル、Alpha Investor、Motley Fool、moomooスクリーニング等。  
L80 - 年間NISA枠はGrowth群から低ボラ銘柄を選定し利用（長期保持に固執しない）。
L81
L82 ---
L83
L84 ## 実行タイミング
L85 - 判定：米国市場終値直後  
L86 - 執行：翌営業日の米国寄付き成行
```

## <documents/drift_design.md>
```text
L1 # drift.py 詳細設計書
L2
L3 ## 概要
L4 - 20銘柄ポートフォリオのドリフトを日次監視し、閾値超過時に半戻し案をSlack通知するスクリプト。
L5 - Finnhubとyfinanceから価格を取得（レジームは trend_template 本数に基づく（基準 N_G=12））。
L6   - 緊急入り: `max(q05, 12本)`
L7   - 緊急解除: `max(q20, 18本)` （ceil(1.5*12)）
L8   - 通常復帰: `max(q60, 36本)` （3*12）
L9
L10 ## 定数・設定
L11 - `FINNHUB_API_KEY` / `SLACK_WEBHOOK_URL` を環境変数から取得。
L12 - 無料枠を考慮したAPIレート制限: `RATE_LIMIT = 55`。
L13 - デバッグ出力用フラグ `debug_mode`。
L14
L15 ## 主な関数
L16 ### finnhub_get
L17 - 基本的なレート制限付きでFinnhub APIを呼び出し、JSONレスポンスを辞書で返す。
L18
L19 ### fetch_price
L20 - `quote` エンドポイントで株価を取得し、失敗時は `NaN` を返す。
L21
L22 ### fetch_vix_ma5
L23 - yfinanceでVIX終値を取得する関数。将来再利用のため残置。
L24
L25 ### load_portfolio
L26 - `current_tickers.csv` から銘柄と保有株数を読み込み、目標比率4%を付与したリストを生成。
L27
L28 ### compute_threshold_by_mode
L29 - モード(NORMAL/CAUTION/EMERG) に応じて **12% / 14% / 停止(∞)** を返す（`config.py` を参照）。
L30
L31 ### build_dataframe
L32 - 各銘柄の評価額や現在比率、ドリフト、半戻し後比率(`adjusted_ratio`)を計算しDataFrame化。
L33
L34 ### simulate
L35 - ドリフト合計が閾値を超えた場合、半戻し後の売買株数と新比率を試算し、シミュレート後ドリフトを返す。
L36
L37 ### prepare_summary
L38 - 評価額順に並べ替えた後、合計行を付与してSlack表示用テーブルを作成。
L39
L40 ### formatters_for / currency
L41 - 通貨・比率・株数の表示フォーマットを定義。
L42
L43 ### build_header
L44 - 現金保有率・閾値・ドリフト値およびアラート有無をSlackメッセージ用ヘッダに整形。TS(基本)はモード別に `config.py` から動的表示し、段階TSは base から -3/-6/-8 pt。
L45
L46 ### send_slack / send_debug
L47 - 通常通知およびデバッグ詳細をSlack Webhookへ送信。
L48
L49 ### main
L50 - 上記関数を順に呼び出し、日次ドリフトチェックの一連処理を実行。
L51
L52 ## 実行フロー
L53 1. `load_portfolio` で現ポートフォリオを読み込む。
L54 2. `build_breadth_header` でモードを取得し、`compute_threshold_by_mode` で現金保有率とドリフト閾値を決定。
L55 3. `build_dataframe` で現在比率とドリフトを計算。
L56 4. `simulate` で閾値超過時の半戻し案を試算。
L57 5. `prepare_summary` と `build_header` で通知本文とテーブルを構築。
L58 6. `send_slack` で結果を送信。`debug_mode` がTrueなら `send_debug` も併用。
```
