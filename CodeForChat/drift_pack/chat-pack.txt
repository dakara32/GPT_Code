# === Chat Paste Pack ===
# Repo: dakara32/GPT_Code @ main
# Files: config.py, drift.py, .github/workflows/daily-report.yml, documents/README.md, documents/drift_design.md
# 作成日時: 2025-09-26 17:01:10 (JST)
# 使い方: 下のチャンクを順に貼ればこのチャットで全体把握できます。
# 注記: 各ファイルは個別に L1.. で行番号付与。
---

## <config.py>
```text
L1 # 共通設定（factor / drift から参照）
L2 TOTAL_TARGETS = 20
L3
L4 # 基準のバケット数（NORMAL）
L5 COUNTS_BASE = {"G": 12, "D": 8}
L6
L7 # モード別の推奨バケット数
L8 COUNTS_BY_MODE = {
L9     "NORMAL": {"G": 12, "D": 8},
L10     "CAUTION": {"G": 10, "D": 8},
L11     "EMERG": {"G": 8,  "D": 8},
L12 }
L13
L14 # モード別のドリフト閾値（%）
L15 DRIFT_THRESHOLD_BY_MODE = {"NORMAL": 12, "CAUTION": 14, "EMERG": float("inf")}
L16
L17 # モード別のTS（基本幅, 小数=割合）
L18 TS_BASE_BY_MODE = {"NORMAL": 0.15, "CAUTION": 0.13, "EMERG": 0.10}
L19 # 利益到達(+30/+60/+100%)時の段階タイト化（ポイント差）
L20 TS_STEP_DELTAS_PT = (3, 6, 8)
L21
L22 # Breadthの校正は N_G に連動（緊急解除=ceil(1.5*N_G), 通常復帰=3*N_G）
L23 N_G = COUNTS_BASE["G"]
L24 N_D = COUNTS_BASE["D"]
L25
```

## <drift.py>
```text
L1 import pandas as pd, yfinance as yf
L2 import numpy as np
L3 import requests
L4 import os
L5 import csv
L6 import json
L7 import time
L8 from pathlib import Path
L9 import config
L10
L11 MODE_LABELS_JA = {"NORMAL": "通常", "CAUTION": "警戒", "EMERG": "緊急"}
L12 MODE_EMOJIS = {"NORMAL": "🟢", "CAUTION": "⚠️", "EMERG": "🚨"}
L13 MODE_RANK = {"NORMAL": 0, "CAUTION": 1, "EMERG": 2}
L14
L15 # --- breadth utilities (factor parity) ---
L16 BENCH = "^GSPC"
L17 CAND_PRICE_MAX = 450.0
L18 RESULTS_DIR = "results"
L19 os.makedirs(RESULTS_DIR, exist_ok=True)
L20
L21
L22 def _state_file():
L23     return str(Path(RESULTS_DIR) / "breadth_state.json")
L24
L25
L26 def load_mode(default="NORMAL"):
L27     try:
L28         m = json.loads(open(_state_file()).read()).get("mode", default)
L29         return m if m in ("EMERG","CAUTION","NORMAL") else default
L30     except Exception:
L31         return default
L32
L33
L34 def save_mode(mode: str):
L35     try:
L36         open(_state_file(),"w").write(json.dumps({"mode": mode}))
L37     except Exception:
L38         pass
L39
L40
L41 def _read_csv_list(fname):
L42     p = Path(__file__).with_name(fname)
L43     if not p.exists(): return []
L44     return pd.read_csv(p, header=None).iloc[:,0].astype(str).str.upper().tolist()
L45
L46
L47 def _load_universe():
L48     # exist + candidate を使用。candidate は価格上限で事前フィルタ
L49     exist = _read_csv_list("current_tickers.csv")
L50     cand  = _read_csv_list("candidate_tickers.csv")
L51     cand_info = yf.Tickers(" ".join(cand)) if cand else None
L52     cand_keep = []
L53     for t in cand:
L54         try:
L55             px = cand_info.tickers[t].fast_info.get("lastPrice", float("inf"))
L56         except Exception:
L57             px = float("inf")
L58         if pd.notna(px) and float(px) <= CAND_PRICE_MAX:
L59             cand_keep.append(t)
L60     tickers = sorted(set(exist + cand_keep))
L61     return exist, cand_keep, tickers
L62
L63
L64 def _fetch_prices_600d(tickers):
L65     data = yf.download(
L66         tickers + [BENCH],
L67         period="600d",
L68         auto_adjust=True,
L69         progress=False,
L70         threads=False,
L71     )
L72     close = data["Close"]
L73     px = close.dropna(how="all", axis=1).ffill(limit=2)
L74     spx = close[BENCH].reindex(px.index).ffill()
L75     return px, spx
L76
L77
L78 def trend_template_breadth_series(px: pd.DataFrame, spx: pd.Series, win_days: int | None = None) -> pd.Series:
L79     # scorer.py の実装をそのまま移植（ベクトル化版）
L80     import numpy as np, pandas as pd
L81     if px is None or px.empty:
L82         return pd.Series(dtype=int)
L83     px = px.dropna(how="all", axis=1)
L84     if win_days and win_days > 0:
L85         px = px.tail(win_days)
L86     if px.empty:
L87         return pd.Series(dtype=int)
L88     # 欠損吸収
L89     px = px.ffill(limit=2)
L90     spx = spx.reindex(px.index).ffill()
L91
L92     ma50  = px.rolling(50,  min_periods=50).mean()
L93     ma150 = px.rolling(150, min_periods=150).mean()
L94     ma200 = px.rolling(200, min_periods=200).mean()
L95
L96     tt = (px > ma150)
L97     tt &= (px > ma200)
L98     tt &= (ma150 > ma200)
L99     tt &= (ma200 - ma200.shift(21) > 0)
L100     tt &= (ma50  > ma150)
L101     tt &= (ma50  > ma200)
L102     tt &= (px    > ma50)
L103
L104     lo252 = px.rolling(252, min_periods=252).min()
L105     hi252 = px.rolling(252, min_periods=252).max()
L106     tt &= (px.divide(lo252).sub(1.0) >= 0.30)
L107     tt &= (px >= (0.75 * hi252))
L108
L109     r12  = px.divide(px.shift(252)).sub(1.0)
L110     br12 = spx.divide(spx.shift(252)).sub(1.0)
L111     r1   = px.divide(px.shift(22)).sub(1.0)
L112     br1  = spx.divide(spx.shift(22)).sub(1.0)
L113     rs   = 0.7*(r12.sub(br12, axis=0)) + 0.3*(r1.sub(br1, axis=0))
L114     tt &= (rs >= 0.10)
L115
L116     return tt.fillna(False).sum(axis=1).astype(int)
L117
L118
L119 def build_breadth_header():
L120     # factor._build_breadth_lead_lines と同一挙動
L121     exist, cand, tickers = _load_universe()
L122     if not tickers:
L123         return "", "NORMAL", 0
L124     px, spx = _fetch_prices_600d(tickers)
L125     win = int(os.getenv("BREADTH_CALIB_WIN_DAYS", "600"))
L126     C_ts = trend_template_breadth_series(px, spx, win_days=win)
L127     if C_ts.empty:
L128         return "", "NORMAL", 0
L129     warmup = int(os.getenv("BREADTH_WARMUP_DAYS","252"))
L130     base = C_ts.iloc[warmup:] if len(C_ts)>warmup else C_ts
L131     C_full = int(C_ts.iloc[-1])
L132
L133     q05 = int(np.nan_to_num(base.quantile(float(os.getenv("BREADTH_Q_EMERG_IN",  "0.05"))), nan=0.0))
L134     q20 = int(np.nan_to_num(base.quantile(float(os.getenv("BREADTH_Q_EMERG_OUT", "0.20"))), nan=0.0))
L135     q60 = int(np.nan_to_num(base.quantile(float(os.getenv("BREADTH_Q_WARN_OUT",  "0.60"))), nan=0.0))
L136
L137     # G枠サイズ（Breadth基準）
L138     N_G = config.N_G
L139     th_in_rec   = max(N_G, q05)
L140     th_out_rec  = max(int(np.ceil(1.5*N_G)), q20)
L141     th_norm_rec = max(3*N_G, q60)
L142
L143     use_calib = os.getenv("BREADTH_USE_CALIB", "true").strip().lower() == "true"
L144     if use_calib:
L145         th_in, th_out, th_norm, th_src = th_in_rec, th_out_rec, th_norm_rec, "自動"
L146     else:
L147         th_in   = int(os.getenv("GTT_EMERG_IN", str(N_G)))
L148         th_out  = int(os.getenv("GTT_EMERG_OUT", str(int(1.5*N_G))))
L149         th_norm = int(os.getenv("GTT_CAUTION_OUT", str(3*N_G)))
L150         th_src = "手動"
L151
L152     prev = load_mode("NORMAL")
L153     if   prev == "EMERG":
L154         mode = "EMERG"   if (C_full < th_out)  else ("CAUTION" if (C_full < th_norm) else "NORMAL")
L155     elif prev == "CAUTION":
L156         mode = "CAUTION" if (C_full < th_norm) else "NORMAL"
L157     else:
L158         mode = "EMERG"   if (C_full < th_in)   else ("CAUTION" if (C_full < th_norm) else "NORMAL")
L159     save_mode(mode)
L160
L161     mode_ja, emoji = MODE_LABELS_JA.get(mode, mode), MODE_EMOJIS.get(mode, "ℹ️")
L162     eff_days = len(base)
L163
L164     lead_lines = [
L165         f"{emoji} *現在モード: {mode_ja}*",
L166         f"テンプレ合格本数: *{C_full}本*",
L167         "しきい値（{0}）".format(th_src),
L168         f"  ・緊急入り: <{th_in}本",
L169         f"  ・緊急解除: ≥{th_out}本",
L170         f"  ・通常復帰: ≥{th_norm}本",
L171         f"参考指標（過去~{win}営業日, 有効={eff_days}日）",
L172         f"  ・下位5%: {q05}本",
L173         f"  ・下位20%: {q20}本",
L174         f"  ・60%分位: {q60}本",
L175     ]
L176     return "```" + "\n".join(lead_lines) + "```", mode, C_full
L177
L178
L179 TS_LOG_FILE = Path(RESULTS_DIR) / "ts_signal_log.csv"
L180
L181
L182 def _load_growth_symbols(portfolio: list[dict]) -> list[str]:
L183     growth = []
L184     for row in portfolio:
L185         bucket = str(row.get("bucket", "")).strip().upper()
L186         if bucket == "G":
L187             sym = str(row.get("symbol", "")).strip().upper()
L188             if sym:
L189                 growth.append(sym)
L190     return sorted(set(growth))
L191
L192
L193 def _upsert_ts_hits(date_str: str, hits: set[str]):
L194     df = None
L195     if TS_LOG_FILE.exists():
L196         try:
L197             df = pd.read_csv(TS_LOG_FILE)
L198         except Exception:
L199             df = None
L200     if df is None or not isinstance(df, pd.DataFrame):
L201         df = pd.DataFrame(columns=["date", "symbol"])
L202     df = df[df["date"] != date_str]
L203     if hits:
L204         add = pd.DataFrame({"date": date_str, "symbol": sorted({h.upper() for h in hits})})
L205         df = pd.concat([df, add], ignore_index=True)
L206     df = df.sort_values(["date", "symbol"])
L207     df.to_csv(TS_LOG_FILE, index=False)
L208
L209
L210 def _count_unique_hits_5d(today_utc: pd.Timestamp) -> int:
L211     if not TS_LOG_FILE.exists():
L212         return 0
L213     try:
L214         df = pd.read_csv(TS_LOG_FILE)
L215     except Exception:
L216         return 0
L217     if df.empty or "date" not in df.columns or "symbol" not in df.columns:
L218         return 0
L219     try:
L220         df["date"] = pd.to_datetime(df["date"], utc=True)
L221     except Exception:
L222         return 0
L223     today = today_utc.normalize()
L224     start = today - pd.offsets.BDay(4)
L225     mask = (df["date"] >= start) & (df["date"] <= today)
L226     if not mask.any():
L227         return 0
L228     return int(df.loc[mask, "symbol"].str.upper().nunique())
L229
L230
L231 def _combine_modes(mode_a: str, mode_b: str) -> str:
L232     a = MODE_RANK.get((mode_a or "NORMAL").upper(), 0)
L233     b = MODE_RANK.get((mode_b or "NORMAL").upper(), 0)
L234     for mode, rank in MODE_RANK.items():
L235         if rank == max(a, b):
L236             return mode
L237     return "NORMAL"
L238
L239
L240 def _format_mode(mode: str) -> str:
L241     upper = (mode or "NORMAL").upper()
L242     return f"{MODE_EMOJIS.get(upper, 'ℹ️')} {MODE_LABELS_JA.get(upper, upper)}"
L243
L244
L245 def _build_status_block(ts_mode: str, k5: int, ts_hits: list[str], breadth_mode: str, breadth_score: int, combo_mode: str) -> str:
L246     hits_line = "なし" if not ts_hits else ", ".join(sorted(ts_hits))
L247     lines = [
L248         f"*① Growth TS:* {_format_mode(ts_mode)}（5Dユニーク: {k5}銘柄）",
L249         f"  ・当日ヒット: {hits_line}",
L250         f"*② Breadth:* {_format_mode(breadth_mode)}（テンプレ合格本数: {breadth_score}本）",
L251         f"*総合（OR悪化/AND回復）:* {_format_mode(combo_mode)}",
L252     ]
L253     return "\n".join(lines)
L254
L255
L256 def _ts_mode_growth_eod(g_syms: list[str], ref_mode: str) -> tuple[str, int, list[str]]:
L257     now_utc = pd.Timestamp.today(tz="UTC")
L258     if not g_syms:
L259         k = _count_unique_hits_5d(now_utc)
L260         mode1 = "EMERG" if k >= 8 else "CAUTION" if k >= 6 else "NORMAL"
L261         return mode1, k, []
L262     try:
L263         df = yf.download(
L264             g_syms,
L265             period="90d",
L266             interval="1d",
L267             auto_adjust=False,
L268             progress=False,
L269             group_by="column",
L270         )
L271     except Exception:
L272         df = None
L273     if not isinstance(df, pd.DataFrame) or df.empty:
L274         k = _count_unique_hits_5d(now_utc)
L275         mode1 = "EMERG" if k >= 8 else "CAUTION" if k >= 6 else "NORMAL"
L276         return mode1, k, []
L277     try:
L278         hi = df["High"] if "High" in df.columns else None
L279         lo = df["Low"] if "Low" in df.columns else None
L280     except Exception:
L281         hi = lo = None
L282     if hi is None or lo is None:
L283         k = _count_unique_hits_5d(now_utc)
L284         mode1 = "EMERG" if k >= 8 else "CAUTION" if k >= 6 else "NORMAL"
L285         return mode1, k, []
L286     if isinstance(hi, pd.Series):
L287         hi = hi.to_frame(name=g_syms[0])
L288     if isinstance(lo, pd.Series):
L289         lo = lo.to_frame(name=g_syms[0])
L290     try:
L291         roll_hi = hi.rolling(60, min_periods=20).max().tail(1).iloc[0]
L292         low_today = lo.tail(1).iloc[0]
L293     except Exception:
L294         k = _count_unique_hits_5d(now_utc)
L295         mode1 = "EMERG" if k >= 8 else "CAUTION" if k >= 6 else "NORMAL"
L296         return mode1, k, []
L297     base = float(config.TS_BASE_BY_MODE.get((ref_mode or "NORMAL").upper(), 0.15))
L298     hits = set()
L299     for s in g_syms:
L300         rh = float(roll_hi.get(s, float("nan")))
L301         lt = float(low_today.get(s, float("nan")))
L302         if pd.notna(rh) and rh > 0 and pd.notna(lt) and lt > 0:
L303             if lt <= rh * (1.0 - base):
L304                 hits.add(s)
L305     today = now_utc.date().isoformat()
L306     _upsert_ts_hits(today, hits)
L307     k = _count_unique_hits_5d(now_utc)
L308     mode1 = "EMERG" if k >= 8 else "CAUTION" if k >= 6 else "NORMAL"
L309     return mode1, k, sorted(hits)
L310 # Debug flag
L311 debug_mode = False  # set to True for detailed output
L312
L313 # --- Finnhub settings & helper ---
L314 FINNHUB_API_KEY = os.environ.get("FINNHUB_API_KEY")
L315 if not FINNHUB_API_KEY:
L316     raise ValueError("FINNHUB_API_KEY not set (環境変数が未設定です)")
L317
L318 RATE_LIMIT = 55  # requests per minute (free tier is 60)
L319 call_times = []
L320
L321
L322 def finnhub_get(endpoint, params):
L323     """Call Finnhub API with basic rate limiting."""
L324     now = time.time()
L325     cutoff = now - 60
L326     while call_times and call_times[0] < cutoff:
L327         call_times.pop(0)
L328     if len(call_times) >= RATE_LIMIT:
L329         sleep_time = 60 - (now - call_times[0])
L330         time.sleep(sleep_time)
L331     params = {**params, "token": FINNHUB_API_KEY}
L332     try:
L333         resp = requests.get(f"https://finnhub.io/api/v1/{endpoint}", params=params)
L334         resp.raise_for_status()
L335         data = resp.json()
L336     except requests.exceptions.JSONDecodeError as e:
L337         print(f"⚠️ Finnhub API JSON decode error: {e}")
L338         return {}
L339     except Exception as e:
L340         print(f"⚠️ Finnhub API error: {e}")
L341         return {}
L342     call_times.append(time.time())
L343     return data
L344
L345
L346 def fetch_price(symbol):
L347     try:
L348         data = finnhub_get("quote", {"symbol": symbol})
L349         price = data.get("c")
L350         return float(price) if price not in (None, 0) else float("nan")
L351     except Exception:
L352         return float("nan")
L353
L354
L355 def fetch_vix_ma5():
L356     """Retrieve VIX 5-day moving average via yfinance."""
L357     try:
L358         vix = (
L359             yf.download("^VIX", period="7d", interval="1d", progress=False, auto_adjust=False)["Close"]
L360             .dropna()
L361             .tail(5)
L362         )
L363         if len(vix) < 5:
L364             return float("nan")
L365         return vix.mean().item()
L366     except Exception:
L367         return float("nan")
L368
L369
L370
L371 # === Minervini-like sell signals ===
L372 def _yf_df(sym, period="6mo"):
L373     """日足/MA/出来高平均を取得。欠損時は None。"""
L374     try:
L375         df = yf.download(sym, period=period, interval="1d", auto_adjust=False, progress=False)
L376         if df is None or df.empty:
L377             return None
L378         return df.dropna().assign(
L379             ma20=lambda d: d["Close"].rolling(20).mean(),
L380             ma50=lambda d: d["Close"].rolling(50).mean(),
L381             vol50=lambda d: d["Volume"].rolling(50).mean(),
L382         )
L383     except Exception:
L384         return None
L385
L386
L387 def _scalar(row, col):
L388     """Series/npスカラ→Pythonスカラ化（NaNはNaNのまま）"""
L389     try:
L390         v = row[col]
L391         if hasattr(v, "item"):
L392             try:
L393                 v = v.item()
L394             except Exception:
L395                 pass
L396         return v
L397     except Exception:
L398         return float("nan")
L399
L400
L401 def _is_strict_down(seq):
L402     """数列が厳密に連続で切り下がっているか（len>=4を想定）。NaN含みはFalse。"""
L403     try:
L404         xs = [float(x) for x in seq]
L405         if any(pd.isna(x) for x in xs) or len(xs) < 4:
L406             return False
L407         return all(b < a for a, b in zip(xs[:-1], xs[1:]))
L408     except Exception:
L409         return False
L410
L411
L412 def _signals_for_day(df, idx):
L413     """df.loc[idx] 1日分に対しシグナル配列を返す（値動き/出来高ベースのみ）。"""
L414     try:
L415         sig = []
L416         d = df.loc[idx]
L417         close = _scalar(d, "Close")
L418         ma20 = _scalar(d, "ma20")
L419         ma50 = _scalar(d, "ma50")
L420         vol = _scalar(d, "Volume")
L421         vol50 = _scalar(d, "vol50")
L422
L423         if pd.notna(close) and pd.notna(ma20) and close < ma20:
L424             sig.append("20DMA↓")
L425
L426         if all(pd.notna(x) for x in (close, ma50, vol, vol50)) and close < ma50 and vol > 1.5 * vol50:
L427             sig.append("50DMA↓(大商い)")
L428
L429         last4 = df.loc[:idx].tail(4)
L430         last10 = df.loc[:idx].tail(10)
L431
L432         lows_desc = _is_strict_down(last4["Low"].tolist()) if last4["Low"].notna().all() else False
L433         reds = int((last10["Close"] < last10["Open"]).sum()) if last10[["Close", "Open"]].notna().all().all() else 0
L434         if lows_desc or reds > 5:
L435             sig.append("連続安値/陰線優勢")
L436
L437         ups = int((last10["Close"] > last10["Open"]).sum()) if last10[["Close", "Open"]].notna().all().all() else 0
L438         if ups >= 7:
L439             sig.append("上げ偏重(>70%)")
L440
L441         last15 = df.loc[:idx].tail(15)
L442         base0 = _scalar(last15.iloc[0], "Close") if len(last15) > 0 else float("nan")
L443         if pd.notna(base0) and pd.notna(close) and base0 != 0 and (close / base0 - 1) >= 0.25:
L444             sig.append("+25%/15日内")
L445
L446         if len(df.loc[:idx]) >= 2:
L447             t1, t0 = df.loc[:idx].iloc[-2], df.loc[:idx].iloc[-1]
L448             t1_high = _scalar(t1, "High")
L449             t0_open = _scalar(t0, "Open")
L450             t0_close = _scalar(t0, "Close")
L451             if all(pd.notna(x) for x in (t1_high, t0_open, t0_close)):
L452                 if (t0_open > t1_high * 1.02) and (t0_close < t0_open):
L453                     sig.append("GU→陰線")
L454         return sig
L455     except Exception:
L456         return []
L457
L458
L459 def scan_sell_signals(symbols, lookback_days=5):
L460     """
L461     直近 lookback_days 日のうち一度でもシグナルが出たら {sym: [(date,[signals]),...]} を返す。
L462     日付は YYYY-MM-DD。Slackで列挙する。
L463     """
L464     out = {}
L465     for s in symbols:
L466         df = _yf_df(s)
L467         if df is None or len(df) < 60:
L468             continue
L469         alerts = []
L470         for idx in df.tail(lookback_days).index:
L471             tags = _signals_for_day(df, idx)
L472             if tags:
L473                 alerts.append((idx.strftime("%Y-%m-%d"), tags))
L474         if alerts:
L475             out[s] = alerts
L476     return out
L477
L478
L479 def load_portfolio():
L480     tickers_path = Path(__file__).with_name("current_tickers.csv")
L481     with tickers_path.open() as f:
L482         rows = [row for row in csv.reader(f) if row and row[0].strip()]
L483     n = len(rows)
L484     portfolio = []
L485     for row in rows:
L486         sym = row[0].strip().upper()
L487         qty = int(row[1]) if len(row) > 1 and row[1].strip() else 0
L488         bucket = row[2].strip().upper() if len(row) > 2 else ""
L489         entry = {
L490             "symbol": sym,
L491             "shares": qty,
L492             "target_ratio": 1 / n if n else 0.0,
L493             "bucket": bucket,
L494         }
L495         portfolio.append(entry)
L496     return portfolio
L497
L498
L499 def compute_threshold():
L500     vix_ma5 = fetch_vix_ma5()
L501     drift_threshold = 10 if vix_ma5 < 20 else 12 if vix_ma5 < 26 else float("inf")
L502     return vix_ma5, drift_threshold
L503
L504
L505 def compute_threshold_by_mode(mode: str):
L506     """モードに応じて現金保有率とドリフト閾値を返す（README準拠）"""
L507     m = (mode or "NORMAL").upper()
L508     cash_map = {"NORMAL": 0.10, "CAUTION": 0.125, "EMERG": 0.20}
L509     drift_map = config.DRIFT_THRESHOLD_BY_MODE
L510     return cash_map.get(m, 0.10), drift_map.get(m, 12)
L511
L512
L513 def recommended_counts_by_mode(mode: str) -> tuple[int, int, int]:
L514     """
L515     モード別の推奨保有数 (G_count, D_count, cash_slots) を返す。
L516     cash_slotsは「外すG枠の数」（各枠=5%）。
L517     NORMAL: G12/D8/現金化0, CAUTION: G10/D8/現金化2, EMERG: G8/D8/現金化4
L518     """
L519     m = (mode or "NORMAL").upper()
L520     base = config.COUNTS_BY_MODE.get("NORMAL", config.COUNTS_BASE)
L521     now  = config.COUNTS_BY_MODE.get(m, base)
L522     cash_slots = max(0, base["G"] - now["G"])
L523     return now["G"], now["D"], cash_slots
L524
L525
L526 def build_dataframe(portfolio):
L527     for stock in portfolio:
L528         price = fetch_price(stock["symbol"])
L529         stock["price"] = price
L530         stock["value"] = price * stock["shares"]
L531
L532     df = pd.DataFrame(portfolio)
L533     total_value = df["value"].sum()
L534     df["current_ratio"] = df["value"] / total_value
L535     df["drift"] = df["current_ratio"] - df["target_ratio"]
L536     df["drift_abs"] = df["drift"].abs()
L537     total_drift_abs = df["drift_abs"].sum()
L538     df["adjusted_ratio"] = df["current_ratio"] - df["drift"] / 2
L539     df["adjustable"] = (
L540         (df["adjusted_ratio"] * total_value) >= df["price"]
L541     ) & df["price"].notna() & df["price"].gt(0)
L542     return df, total_value, total_drift_abs
L543
L544
L545 def simulate(df, total_value, total_drift_abs, drift_threshold):
L546     alert = drift_threshold != float("inf") and total_drift_abs * 100 > drift_threshold
L547     if alert:
L548         df["trade_shares"] = df.apply(
L549             lambda r: int(round(((r["adjusted_ratio"] * total_value) - r["value"]) / r["price"]))
L550             if r["adjustable"] and r["price"] > 0 else 0,
L551             axis=1,
L552         )
L553         df["new_shares"] = df["shares"] + df["trade_shares"]
L554         df["new_value"] = df["new_shares"] * df["price"]
L555         new_total_value = df["new_value"].sum()
L556         df["simulated_ratio"] = df["new_value"] / new_total_value
L557         df["simulated_drift_abs"] = (df["simulated_ratio"] - df["target_ratio"]).abs()
L558         simulated_total_drift_abs = df["simulated_drift_abs"].sum()
L559     else:
L560         df["trade_shares"] = np.nan
L561         df["new_shares"] = np.nan
L562         df["new_value"] = np.nan
L563         new_total_value = np.nan
L564         df["simulated_ratio"] = np.nan
L565         df["simulated_drift_abs"] = np.nan
L566         simulated_total_drift_abs = np.nan
L567     return df, alert, new_total_value, simulated_total_drift_abs
L568
L569
L570 def prepare_summary(df, total_drift_abs, alert):
L571     summary = {
L572         "symbol": "合計",
L573         "shares": df["shares"].sum(),
L574         "value": df["value"].sum(),
L575         "current_ratio": np.nan,
L576         "drift_abs": total_drift_abs,
L577     }
L578     if alert:
L579         summary["trade_shares"] = np.nan
L580     # Sort details by evaluation value descending before appending summary
L581     df = df.sort_values(by="value", ascending=False)
L582     df = pd.concat([df, pd.DataFrame([summary])], ignore_index=True)
L583     if alert:
L584         cols = ["symbol", "shares", "value", "current_ratio", "drift_abs", "trade_shares"]
L585         df_small = df[cols].copy()
L586         df_small.columns = ["sym", "qty", "val", "now", "|d|", "Δqty"]
L587     else:
L588         cols = ["symbol", "shares", "value", "current_ratio", "drift_abs"]
L589         df_small = df[cols].copy()
L590         df_small.columns = ["sym", "qty", "val", "now", "|d|"]
L591     return df_small
L592
L593
L594 def currency(x):
L595     return f"${x:,.0f}" if pd.notnull(x) else ""
L596
L597
L598 def formatters_for(alert):
L599     formatters = {"val": currency, "now": "{:.2%}".format, "|d|": "{:.2%}".format}
L600     if alert:
L601         formatters["Δqty"] = "{:.0f}".format
L602     return formatters
L603
L604
L605 def build_header(mode, cash_ratio, drift_threshold, total_drift_abs, alert, simulated_total_drift_abs):
L606     header = (
L607         f"*💼 現金保有率:* {cash_ratio*100:.1f}%\n"
L608         f"*📊 ドリフト閾値:* {'🔴(停止)' if drift_threshold == float('inf') else str(drift_threshold)+'%'}\n"
L609         f"*📉 現在のドリフト合計:* {total_drift_abs * 100:.2f}%\n"
L610     )
L611     if alert:
L612         header += f"*🔁 半戻し後ドリフト合計(想定):* {simulated_total_drift_abs * 100:.2f}%\n"
L613         header += "🚨 *アラート: 発生！！ Δqtyのマイナス銘柄を売却、任意の銘柄を買い増してバランスを取りましょう！*\n"
L614     else:
L615         header += "✅ アラートなし\n"
L616     # ★ 追記: TSルール（G/D共通）と推奨保有数
L617     # TS(基本)をモードで動的表示。段階TSは「基本から -3/-6/-8 pt」固定。
L618     base_ts = config.TS_BASE_BY_MODE.get(mode.upper(), config.TS_BASE_BY_MODE["NORMAL"])
L619     d1, d2, d3 = config.TS_STEP_DELTAS_PT
L620     ts_line = f"*🛡 TS:* 基本 -{base_ts*100:.0f}% / +30%→-{max(base_ts*100 - d1, 0):.0f}% / +60%→-{max(base_ts*100 - d2, 0):.0f}% / +100%→-{max(base_ts*100 - d3, 0):.0f}%\n"
L621     header += ts_line
L622     g_cnt, d_cnt, cash_slots = recommended_counts_by_mode(mode)
L623     cash_pct = cash_slots * (100 / (config.TOTAL_TARGETS))  # 1枠=総数分割の%（20銘柄なら5%）
L624     header += f"*📋 推奨保有数:* G {g_cnt} / D {d_cnt}（現金化枠 {cash_slots}枠 ≒ {cash_pct:.0f}%）\n"
L625     return header
L626
L627
L628 def send_slack(text):
L629     SLACK_WEBHOOK_URL = os.environ.get("SLACK_WEBHOOK_URL")
L630     if not SLACK_WEBHOOK_URL:
L631         raise ValueError("SLACK_WEBHOOK_URL not set (環境変数が未設定です)")
L632     payload = {"text": text}
L633     try:
L634         resp = requests.post(SLACK_WEBHOOK_URL, json=payload)
L635         resp.raise_for_status()
L636         print("✅ Slack（Webhook）へ送信しました")
L637     except Exception as e:
L638         print(f"⚠️ Slack通知エラー: {e}")
L639
L640
L641 def send_debug(debug_text):
L642     SLACK_WEBHOOK_URL = os.environ.get("SLACK_WEBHOOK_URL")
L643     if not SLACK_WEBHOOK_URL:
L644         raise ValueError("SLACK_WEBHOOK_URL not set (環境変数が未設定です)")
L645     debug_payload = {"text": "```" + debug_text + "```"}
L646     try:
L647         resp = requests.post(SLACK_WEBHOOK_URL, json=debug_payload)
L648         resp.raise_for_status()
L649         print("✅ Debug情報をSlackに送信しました")
L650     except Exception as e:
L651         print(f"⚠️ Slack通知エラー: {e}")
L652
L653
L654 def main():
L655     portfolio = load_portfolio()
L656     symbols = [r["symbol"] for r in portfolio]
L657     g_syms = _load_growth_symbols(portfolio)
L658     sell_alerts = scan_sell_signals(symbols, lookback_days=5)
L659
L660     breadth_block, breadth_mode, breadth_score = build_breadth_header()
L661     ts_mode, k5, ts_hits = _ts_mode_growth_eod(g_syms, breadth_mode)
L662     combo_mode = _combine_modes(ts_mode, breadth_mode)
L663
L664     cash_ratio, drift_threshold = compute_threshold_by_mode(breadth_mode)
L665
L666     df, total_value, total_drift_abs = build_dataframe(portfolio)
L667     df, alert, new_total_value, simulated_total_drift_abs = simulate(
L668         df, total_value, total_drift_abs, drift_threshold
L669     )
L670     df_small = prepare_summary(df, total_drift_abs, alert)
L671     if 'df_small' in locals() and isinstance(df_small, pd.DataFrame) and not df_small.empty:
L672         col_sym = "sym" if "sym" in df_small.columns else ("symbol" if "symbol" in df_small.columns else None)
L673         if col_sym:
L674             alert_keys = {str(k) for k in sell_alerts.keys()}
L675             df_small[col_sym] = df_small[col_sym].astype(str)
L676             df_small.insert(0, "⚠", df_small[col_sym].map(lambda x: "🔴" if x in alert_keys else ""))
L677             latest_tag = {s: " / ".join(sell_alerts[s][-1][1]) for s in sell_alerts}
L678             df_small.insert(1, "sig", df_small[col_sym].map(latest_tag).fillna(""))
L679     formatters = formatters_for(alert)
L680     header_core = build_header(
L681         breadth_mode, cash_ratio, drift_threshold, total_drift_abs, alert, simulated_total_drift_abs
L682     )
L683     status_block = _build_status_block(ts_mode, k5, ts_hits, breadth_mode, breadth_score, combo_mode)
L684     header = header_core + "\n" + status_block
L685     if breadth_block:
L686         header = breadth_block + "\n" + header
L687     if sell_alerts:
L688         def fmt_pair(date_tags):
L689             date, tags = date_tags
L690             return f"{date}:" + "・".join(tags)
L691         listed = []
L692         for t, arr in sell_alerts.items():
L693             listed.append(f"*{t}*（" + ", ".join(fmt_pair(x) for x in arr) + "）")
L694         hits = ", ".join(listed)
L695         if "✅ アラートなし" in header:
L696             header = header.replace(
L697                 "✅ アラートなし",
L698                 f"⚠️ 売りシグナルあり: {len(sell_alerts)}銘柄\n🟥 {hits}",
L699             )
L700         else:
L701             header += f"\n🟥 {hits}"
L702     table_text = df_small.to_string(formatters=formatters, index=False)
L703     send_slack(header + "\n```" + table_text + "```")
L704
L705     if debug_mode:
L706         debug_cols = [
L707             "symbol",
L708             "shares",
L709             "price",
L710             "value",
L711             "current_ratio",
L712             "drift",
L713             "drift_abs",
L714             "adjusted_ratio",
L715             "adjustable",
L716             "trade_shares",
L717             "new_shares",
L718             "new_value",
L719             "simulated_ratio",
L720             "simulated_drift_abs",
L721         ]
L722         debug_text = (
L723             "=== DEBUG: full dataframe ===\n"
L724             + df[debug_cols].to_string()
L725             + f"\n\ntotal_value={total_value}, new_total_value={new_total_value}\n"
L726             + f"total_drift_abs={total_drift_abs}, simulated_total_drift_abs={simulated_total_drift_abs}"
L727         )
L728         print("\n" + debug_text)
L729         send_debug(debug_text)
L730
L731
L732 if __name__ == "__main__":
L733     main()
L734
```

## <.github/workflows/daily-report.yml>
```text
L1 name: Daily Stock Report
L2
L3 on:
L4   push:
L5     branches: [ main ]
L6     paths-ignore:
L7       - 'CodeForChat/**'
L8   schedule:
L9     - cron: '30 23 * * 2-6'  # UTC 23:30 → JST 08:30（火〜土）
L10   workflow_dispatch:
L11
L12 jobs:
L13   build-and-report:
L14     runs-on: ubuntu-latest
L15
L16     steps:
L17       - name: Debug start
L18         run: echo '🚀 DEBUGstarted'
L19               
L20       - name: Checkout repository
L21         uses: actions/checkout@v3
L22
L23       - name: Setup Python
L24         uses: actions/setup-python@v4
L25         with:
L26           python-version: '3.x'
L27
L28       - name: Install dependencies
L29         run: pip install -r requirements.txt
L30
L31       - name: Prepare results directory
L32         run: mkdir -p results
L33
L34       - name: Run drift.py
L35         env:
L36           SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
L37           FINNHUB_API_KEY: ${{ secrets.FINNHUB_API_KEY }}
L38         run: python drift.py
L39
L40       - name: Persist breadth_state.json
L41         if: always()
L42         run: |
L43           git config user.name  "github-actions[bot]"
L44           git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
L45           git add results/breadth_state.json || true
L46           git commit -m "chore: update breadth_state [skip ci]" || echo "no changes"
L47           git push || true
```

## <documents/README.md>
```text
L1 # 運用ルール（改訂版）
L2
L3 ## 基本構成
L4 - 20銘柄を均等配分（現金を除き1銘柄あたり5%）  
L5 - moomoo証券で運用  
L6 - **Growth枠 12銘柄 / Defense枠 8銘柄**
L7
L8 ---
L9
L10 ## Barbell Growth-Defense方針
L11 - **Growth枠（12銘柄）**：トレンドを追う**スイングトレード**。高成長・高ボラ銘柄でリターン源泉を狙う。  
L12 - **Defense枠（8銘柄）**：安定重視の**ポジショントレード（やや長期）**。低ボラ・高品質でMDDを抑制。  
L13 - 「猛烈に伸びる攻め × 着実に稼ぐ盾」の組合せで乖離を生み、**半戻しリバランス**でプレミアムを獲得。
L14
L15 ---
L16
L17 ## モード判定（コンボ：先導株TS × ブレッドス）
L18
L19 **考え方：** *悪化はゆるく（OR）、回復は厳しく（AND）*
L20
L21 ### ① 先導株TSシグナル（Growthのみ）
L22 - 対象（Growthの定義）：当日保有銘柄のうち **β ≥ -0.6** を Growth とみなす（Defenseは無視）
L23 - 判定：直近60日高値からモード別基本TS幅（NORMAL:-15% / CAUTION:-13% / EMERG:-10%）以上の下落を「TS抵触」とみなす
L24 - 集計：直近5営業日のユニーク抵触銘柄数
L25   - 8銘柄以上 → ①=EMERG
L26   - 6銘柄以上 → ①=CAUTION
L27   - それ未満 → ①=NORMAL
L28 - 補足：同一日に複数回実行した場合は、**同日上書き**で管理
L29
L30 ### ② ブレッドス（trend_template 合格本数）
L31 - current+candidate 全体で trend_template 条件を満たした銘柄数（基準 N_G=12）
L32 - 閾値：過去600営業日の分布から自動採用（分位点と運用“床”のmax）
L33   - 緊急入り: max(q05, 12本)
L34   - 緊急解除: max(q20, 18本)
L35   - 通常復帰: max(q60, 36本)
L36 - ヒステリシス：前回モードに依存（EMERG→解除は23本以上、CAUTION→通常は45本以上）
L37
L38 ### コンボルール
L39 - **悪化（ダウングレード）**：
L40   final_mode = max(mode①, mode②)
L41   - 例：①=CAUTION, ②=NORMAL → final=CAUTION
L42   - 例：①=EMERG, ②=CAUTION → final=EMERG
L43
L44 - **回復（アップグレード）**：
L45   final_mode を1段階下げるには、mode① と mode② がともに下位モードに揃った場合のみ
L46   - 例：EMERG→CAUTION は ①=CAUTION **かつ** ②=CAUTION
L47   - 例：CAUTION→NORMAL は ①=NORMAL **かつ** ②=NORMAL
L48
L49 > 直感フレーズ：**「悪化はどちらか赤で赤、回復は両方青で青」**
L50
L51 ---
L52
L53 ## モード別設定（現金・ドリフト・保有数）
L54
L55 | モード       | 現金比率 | ドリフト閾値      | 基本TS幅 | Growth枠数 | Defense枠数 | 補足 |
L56 |--------------|----------|-------------------|----------|------------|-------------|------|
L57 | **NORMAL**   | 10%      | 12%               | -15%     | 12         | 8           | フル20銘柄（現金化枠なし） |
L58 | **CAUTION**  | 20%      | 14%               | -13%     | 10         | 8           | Gを2枠外し=現金化10% |
L59 | **EMERG**    | 30%      | ドリフト売買停止 | -10%     | 8          | 8           | Gを4枠外し=現金化20% |
L60
L61 - 含み益到達時のTSタイト化：+30% → -3pt、+60% → -6pt、+100% → -8pt
L62 - 含み益 +100% 達成時は50%を利確し、残りはフリーポジションとして -15%TS で保有継続
L63 - TS発動後のクールダウンは廃止（翌日以降すぐに再IN可）
L64
L65 ---
L66
L67 ## 新規買付
L68 - **新規INは等分比率（=5%）の半分まで**を上限。  
L69 - 追加補充や半戻し買付も同じ上限に従う。
L70
L71 ---
L72
L73 ## 半戻し（リバランス）
L74 1. **現金比率 ≤ 閾値**：過重量銘柄を売却し、不足銘柄を補充。  
L75 2. **現金比率 > 閾値**：**売却は行わず**、現金でドリフト不足銘柄を買付（現金比率を閾値以下へ戻すことを優先）。  
L76 3. **共通**：リバランス後は全銘柄のTSを再設定。EMERGでは「ドリフト売買停止」、20銘柄×5%全戻しのみ許容。
L77
L78 ---
L79
L80 ## モード移行の実務手順
L81 - モードが変わったら、**MMF≒現金**として扱い、Growth枠数だけ調整：  
L82   1. **Gを削る**（CAUTION/EMERG）：⭐️低スコアのGから順に外し、`current_tickers.csv` から行削除（=現金化）。  
L83   2. **現金として保持**。  
L84   3. **NORMAL復帰時の補充**：`current_tickers.csv` に銘柄を追加（スコア上位から）。以降は日次ドリフト/TSルールに従う。  
L85 > driftは `target_ratio = 1/銘柄数` を自動適用。行数に応じて均等比率を再計算。
L86
L87 ---
L88
L89 ## 入替銘柄選定
L90 - **ファクター分散最適化手法を用いて日次でスコア集計**し、**スコア上位からIN/OUT**を決定。  
L91 - 参考：Oxfordキャピタル、Alpha Investor、Motley Fool、moomooスクリーニング等。  
L92 - 年間NISA枠はGrowth群から低ボラ銘柄を選定し利用（長期保持に固執しない）。
L93
L94 ---
L95
L96 ## 実行タイミング
L97 - 判定：米国市場終値直後  
L98 - 執行：翌営業日の米国寄付き成行
```

## <documents/drift_design.md>
```text
L1 # drift.py 詳細設計書
L2
L3 ## 概要
L4 - 20銘柄ポートフォリオのドリフトを日次監視し、閾値超過時に半戻し案をSlack通知するスクリプト。
L5 - Finnhubとyfinanceから価格を取得（レジームは trend_template 本数に基づく（基準 N_G=12））。
L6   - 緊急入り: `max(q05, 12本)`
L7   - 緊急解除: `max(q20, 18本)` （ceil(1.5*12)）
L8   - 通常復帰: `max(q60, 36本)` （3*12）
L9
L10 ## 定数・設定
L11 - `FINNHUB_API_KEY` / `SLACK_WEBHOOK_URL` を環境変数から取得。
L12 - 無料枠を考慮したAPIレート制限: `RATE_LIMIT = 55`。
L13 - デバッグ出力用フラグ `debug_mode`。
L14
L15 ## 主な関数
L16 ### finnhub_get
L17 - 基本的なレート制限付きでFinnhub APIを呼び出し、JSONレスポンスを辞書で返す。
L18
L19 ### fetch_price
L20 - `quote` エンドポイントで株価を取得し、失敗時は `NaN` を返す。
L21
L22 ### fetch_vix_ma5
L23 - yfinanceでVIX終値を取得する関数。将来再利用のため残置。
L24
L25 ### load_portfolio
L26 - `current_tickers.csv` から銘柄と保有株数を読み込み、目標比率4%を付与したリストを生成。
L27
L28 ### compute_threshold_by_mode
L29 - モード(NORMAL/CAUTION/EMERG) に応じて **12% / 14% / 停止(∞)** を返す（`config.py` を参照）。
L30
L31 ### build_dataframe
L32 - 各銘柄の評価額や現在比率、ドリフト、半戻し後比率(`adjusted_ratio`)を計算しDataFrame化。
L33
L34 ### simulate
L35 - ドリフト合計が閾値を超えた場合、半戻し後の売買株数と新比率を試算し、シミュレート後ドリフトを返す。
L36
L37 ### prepare_summary
L38 - 評価額順に並べ替えた後、合計行を付与してSlack表示用テーブルを作成。
L39
L40 ### formatters_for / currency
L41 - 通貨・比率・株数の表示フォーマットを定義。
L42
L43 ### build_header
L44 - 現金保有率・閾値・ドリフト値およびアラート有無をSlackメッセージ用ヘッダに整形。TS(基本)はモード別に `config.py` から動的表示し、段階TSは base から -3/-6/-8 pt。
L45
L46 ### send_slack / send_debug
L47 - 通常通知およびデバッグ詳細をSlack Webhookへ送信。
L48
L49 ### main
L50 - 上記関数を順に呼び出し、日次ドリフトチェックの一連処理を実行。
L51
L52 ## 実行フロー
L53 1. `load_portfolio` で現ポートフォリオを読み込む。
L54 2. `build_breadth_header` でモードを取得し、`compute_threshold_by_mode` で現金保有率とドリフト閾値を決定。
L55 3. `build_dataframe` で現在比率とドリフトを計算。
L56 4. `simulate` で閾値超過時の半戻し案を試算。
L57 5. `prepare_summary` と `build_header` で通知本文とテーブルを構築。
L58 6. `send_slack` で結果を送信。`debug_mode` がTrueなら `send_debug` も併用。
```
