# === Chat Paste Pack ===
# Repo: dakara32/GPT_Code @ main
# Files: config.py, drift.py, .github/workflows/daily-report.yml, documents/README.md, documents/drift_design.md
# 作成日時: 2025-09-26 18:24:45 (JST)
# 使い方: 下のチャンクを順に貼ればこのチャットで全体把握できます。
# 注記: 各ファイルは個別に L1.. で行番号付与。
---

## <config.py>
```text
L1 # 共通設定（factor / drift から参照）
L2 TOTAL_TARGETS = 20
L3
L4 # 基準のバケット数（NORMAL）
L5 COUNTS_BASE = {"G": 12, "D": 8}
L6
L7 # モード別の推奨バケット数
L8 COUNTS_BY_MODE = {
L9     "NORMAL": {"G": 12, "D": 8},
L10     "CAUTION": {"G": 10, "D": 8},
L11     "EMERG": {"G": 8,  "D": 8},
L12 }
L13
L14 # モード別のドリフト閾値（%）
L15 DRIFT_THRESHOLD_BY_MODE = {"NORMAL": 12, "CAUTION": 14, "EMERG": float("inf")}
L16
L17 # モード別のTS（基本幅, 小数=割合）
L18 TS_BASE_BY_MODE = {"NORMAL": 0.15, "CAUTION": 0.13, "EMERG": 0.10}
L19 # 利益到達(+30/+60/+100%)時の段階タイト化（ポイント差）
L20 TS_STEP_DELTAS_PT = (3, 6, 8)
L21
L22 # Breadthの校正は N_G に連動（緊急解除=ceil(1.5*N_G), 通常復帰=3*N_G）
L23 N_G = COUNTS_BASE["G"]
L24 N_D = COUNTS_BASE["D"]
L25
```

## <drift.py>
```text
L1 import pandas as pd, yfinance as yf
L2 import numpy as np
L3 import requests
L4 import os
L5 import json
L6 import time
L7 from pathlib import Path
L8 import config
L9
L10 MODE_LABELS_JA = {"NORMAL": "通常", "CAUTION": "警戒", "EMERG": "緊急"}
L11 MODE_EMOJIS = {"NORMAL": "🟢", "CAUTION": "⚠️", "EMERG": "🚨"}
L12 MODE_RANK = {"NORMAL": 0, "CAUTION": 1, "EMERG": 2}
L13
L14 # --- breadth utilities (factor parity) ---
L15 BENCH = "^GSPC"
L16 CAND_PRICE_MAX = 450.0
L17 RESULTS_DIR = "results"
L18 os.makedirs(RESULTS_DIR, exist_ok=True)
L19
L20 AUDIT_PRINT_MAX = int(os.environ.get("AUDIT_PRINT_MAX", "20"))  # stdout に流す本日の明細の最大行数
L21
L22
L23 def _state_file():
L24     return str(Path(RESULTS_DIR) / "breadth_state.json")
L25
L26
L27 def load_mode(default="NORMAL"):
L28     try:
L29         m = json.loads(open(_state_file()).read()).get("mode", default)
L30         return m if m in ("EMERG","CAUTION","NORMAL") else default
L31     except Exception:
L32         return default
L33
L34
L35 def save_mode(mode: str):
L36     try:
L37         open(_state_file(),"w").write(json.dumps({"mode": mode}))
L38     except Exception:
L39         pass
L40
L41
L42 def _read_csv_list(fname):
L43     p = Path(__file__).with_name(fname)
L44     if not p.exists(): return []
L45     return pd.read_csv(p, header=None).iloc[:,0].astype(str).str.upper().tolist()
L46
L47
L48 def _load_universe():
L49     # exist + candidate を使用。candidate は価格上限で事前フィルタ
L50     exist = _read_csv_list("current_tickers.csv")
L51     cand  = _read_csv_list("candidate_tickers.csv")
L52     cand_info = yf.Tickers(" ".join(cand)) if cand else None
L53     cand_keep = []
L54     for t in cand:
L55         try:
L56             px = cand_info.tickers[t].fast_info.get("lastPrice", float("inf"))
L57         except Exception:
L58             px = float("inf")
L59         if pd.notna(px) and float(px) <= CAND_PRICE_MAX:
L60             cand_keep.append(t)
L61     tickers = sorted(set(exist + cand_keep))
L62     return exist, cand_keep, tickers
L63
L64
L65 def _fetch_prices_600d(tickers):
L66     data = yf.download(
L67         tickers + [BENCH],
L68         period="600d",
L69         auto_adjust=True,
L70         progress=False,
L71         threads=False,
L72     )
L73     close = data["Close"]
L74     px = close.dropna(how="all", axis=1).ffill(limit=2)
L75     spx = close[BENCH].reindex(px.index).ffill()
L76     return px, spx
L77
L78
L79 def trend_template_breadth_series(px: pd.DataFrame, spx: pd.Series, win_days: int | None = None) -> pd.Series:
L80     # scorer.py の実装をそのまま移植（ベクトル化版）
L81     import numpy as np, pandas as pd
L82     if px is None or px.empty:
L83         return pd.Series(dtype=int)
L84     px = px.dropna(how="all", axis=1)
L85     if win_days and win_days > 0:
L86         px = px.tail(win_days)
L87     if px.empty:
L88         return pd.Series(dtype=int)
L89     # 欠損吸収
L90     px = px.ffill(limit=2)
L91     spx = spx.reindex(px.index).ffill()
L92
L93     ma50  = px.rolling(50,  min_periods=50).mean()
L94     ma150 = px.rolling(150, min_periods=150).mean()
L95     ma200 = px.rolling(200, min_periods=200).mean()
L96
L97     tt = (px > ma150)
L98     tt &= (px > ma200)
L99     tt &= (ma150 > ma200)
L100     tt &= (ma200 - ma200.shift(21) > 0)
L101     tt &= (ma50  > ma150)
L102     tt &= (ma50  > ma200)
L103     tt &= (px    > ma50)
L104
L105     lo252 = px.rolling(252, min_periods=252).min()
L106     hi252 = px.rolling(252, min_periods=252).max()
L107     tt &= (px.divide(lo252).sub(1.0) >= 0.30)
L108     tt &= (px >= (0.75 * hi252))
L109
L110     r12  = px.divide(px.shift(252)).sub(1.0)
L111     br12 = spx.divide(spx.shift(252)).sub(1.0)
L112     r1   = px.divide(px.shift(22)).sub(1.0)
L113     br1  = spx.divide(spx.shift(22)).sub(1.0)
L114     rs   = 0.7*(r12.sub(br12, axis=0)) + 0.3*(r1.sub(br1, axis=0))
L115     tt &= (rs >= 0.10)
L116
L117     return tt.fillna(False).sum(axis=1).astype(int)
L118
L119
L120 def build_breadth_header():
L121     # factor._build_breadth_lead_lines と同一挙動
L122     exist, cand, tickers = _load_universe()
L123     if not tickers:
L124         return "", "NORMAL", 0
L125     px, spx = _fetch_prices_600d(tickers)
L126     win = int(os.getenv("BREADTH_CALIB_WIN_DAYS", "600"))
L127     C_ts = trend_template_breadth_series(px, spx, win_days=win)
L128     if C_ts.empty:
L129         return "", "NORMAL", 0
L130     warmup = int(os.getenv("BREADTH_WARMUP_DAYS","252"))
L131     base = C_ts.iloc[warmup:] if len(C_ts)>warmup else C_ts
L132     C_full = int(C_ts.iloc[-1])
L133
L134     q05 = int(np.nan_to_num(base.quantile(float(os.getenv("BREADTH_Q_EMERG_IN",  "0.05"))), nan=0.0))
L135     q20 = int(np.nan_to_num(base.quantile(float(os.getenv("BREADTH_Q_EMERG_OUT", "0.20"))), nan=0.0))
L136     q60 = int(np.nan_to_num(base.quantile(float(os.getenv("BREADTH_Q_WARN_OUT",  "0.60"))), nan=0.0))
L137
L138     # G枠サイズ（Breadth基準）
L139     N_G = config.N_G
L140     th_in_rec   = max(N_G, q05)
L141     th_out_rec  = max(int(np.ceil(1.5*N_G)), q20)
L142     th_norm_rec = max(3*N_G, q60)
L143
L144     use_calib = os.getenv("BREADTH_USE_CALIB", "true").strip().lower() == "true"
L145     if use_calib:
L146         th_in, th_out, th_norm, th_src = th_in_rec, th_out_rec, th_norm_rec, "自動"
L147     else:
L148         th_in   = int(os.getenv("GTT_EMERG_IN", str(N_G)))
L149         th_out  = int(os.getenv("GTT_EMERG_OUT", str(int(1.5*N_G))))
L150         th_norm = int(os.getenv("GTT_CAUTION_OUT", str(3*N_G)))
L151         th_src = "手動"
L152
L153     prev = load_mode("NORMAL")
L154     if   prev == "EMERG":
L155         mode = "EMERG"   if (C_full < th_out)  else ("CAUTION" if (C_full < th_norm) else "NORMAL")
L156     elif prev == "CAUTION":
L157         mode = "CAUTION" if (C_full < th_norm) else "NORMAL"
L158     else:
L159         mode = "EMERG"   if (C_full < th_in)   else ("CAUTION" if (C_full < th_norm) else "NORMAL")
L160     save_mode(mode)
L161
L162     mode_ja, emoji = MODE_LABELS_JA.get(mode, mode), MODE_EMOJIS.get(mode, "ℹ️")
L163     eff_days = len(base)
L164
L165     lead_lines = [
L166         f"{emoji} *現在モード: {mode_ja}*",
L167         f"テンプレ合格本数: *{C_full}本*",
L168         "しきい値（{0}）".format(th_src),
L169         f"  ・緊急入り: <{th_in}本",
L170         f"  ・緊急解除: ≥{th_out}本",
L171         f"  ・通常復帰: ≥{th_norm}本",
L172         f"参考指標（過去~{win}営業日, 有効={eff_days}日）",
L173         f"  ・下位5%: {q05}本",
L174         f"  ・下位20%: {q20}本",
L175         f"  ・60%分位: {q60}本",
L176     ]
L177     return "```" + "\n".join(lead_lines) + "```", mode, C_full
L178
L179
L180 def _load_growth_symbols(portfolio: list[dict]) -> list[str]:
L181     growth = []
L182     for row in portfolio:
L183         bucket = str(row.get("bucket", "")).strip().upper()
L184         if bucket == "G":
L185             sym = str(row.get("symbol", "")).strip().upper()
L186             if sym:
L187                 growth.append(sym)
L188     return sorted(set(growth))
L189
L190
L191 def _combine_modes(mode_a: str, mode_b: str) -> str:
L192     a = MODE_RANK.get((mode_a or "NORMAL").upper(), 0)
L193     b = MODE_RANK.get((mode_b or "NORMAL").upper(), 0)
L194     for mode, rank in MODE_RANK.items():
L195         if rank == max(a, b):
L196             return mode
L197     return "NORMAL"
L198
L199
L200 def _format_mode(mode: str) -> str:
L201     upper = (mode or "NORMAL").upper()
L202     return f"{MODE_EMOJIS.get(upper, 'ℹ️')} {MODE_LABELS_JA.get(upper, upper)}"
L203
L204
L205 def _ts_mode_growth_5d(g_syms: list[str], ref_mode: str) -> tuple[str, int, set[str]]:
L206     """直近5営業日を株価直接方式で一括判定（Low vs 60D High）。"""
L207
L208     if not g_syms:
L209         print("⚠️ audit: G銘柄リストが空のため、今日の明細を出力できません")
L210         return "NORMAL", 0, set()
L211
L212     try:
L213         df = yf.download(
L214             g_syms,
L215             period="100d",
L216             interval="1d",
L217             auto_adjust=False,
L218             progress=False,
L219         )
L220     except Exception as e:
L221         print(f"⚠️ audit: 株価データ取得に失敗しました ({e})")
L222         return "NORMAL", 0, set()
L223
L224     if not isinstance(df, pd.DataFrame) or df.empty:
L225         print("⚠️ audit: 株価データが空のため、今日の明細を出力できません")
L226         return "NORMAL", 0, set()
L227
L228     try:
L229         hi_all = df["High"] if "High" in df.columns else None
L230         lo_all = df["Low"] if "Low" in df.columns else None
L231     except Exception as e:
L232         print(f"⚠️ audit: High/Low データ取得に失敗しました ({e})")
L233         hi_all = lo_all = None
L234
L235     if hi_all is None or lo_all is None:
L236         print("⚠️ audit: High/Low データが欠落しているため、今日の明細を出力できません")
L237         return "NORMAL", 0, set()
L238
L239     if isinstance(hi_all, pd.Series):
L240         hi_all = hi_all.to_frame(name=g_syms[0])
L241     if isinstance(lo_all, pd.Series):
L242         lo_all = lo_all.to_frame(name=g_syms[0])
L243
L244     if hi_all.empty or lo_all.empty:
L245         print("⚠️ audit: High/Low データが空のため、今日の明細を出力できません")
L246         return "NORMAL", 0, set()
L247
L248     roll_hi = hi_all.rolling(60, min_periods=20).max()
L249     last5_hi = roll_hi.tail(5)
L250     last5_lo = lo_all.tail(5).reindex(last5_hi.index)
L251
L252     if last5_hi.empty or last5_lo.empty:
L253         print("⚠️ audit: 直近5営業日のデータが揃わず、今日の明細を出力できません")
L254         return "NORMAL", 0, set()
L255
L256     base = float(config.TS_BASE_BY_MODE.get((ref_mode or "NORMAL").upper(), 0.15))
L257     uniq_hits: set[str] = set()
L258     today_hits: set[str] = set()
L259
L260     rows_today_printed = 0
L261     today_reason_flags: list[str] = []
L262     last_day = last5_hi.index[-1]
L263
L264     for dt in last5_hi.index:
L265         hi_row = last5_hi.loc[dt]
L266         lo_row = last5_lo.loc[dt]
L267         for sym in g_syms:
L268             rh = float(hi_row.get(sym, float("nan"))) if hasattr(hi_row, "get") else float("nan")
L269             lt = float(lo_row.get(sym, float("nan"))) if hasattr(lo_row, "get") else float("nan")
L270
L271             if not (pd.notna(rh) and rh > 0):
L272                 if dt == last_day:
L273                     today_reason_flags.append("H60欠損")
L274                 continue
L275             if not (pd.notna(lt) and lt > 0):
L276                 if dt == last_day:
L277                     today_reason_flags.append("Low欠損")
L278                 continue
L279
L280             threshold = rh * (1.0 - base)
L281             breach = int(lt <= threshold)
L282             if breach:
L283                 uniq_hits.add(sym)
L284                 if dt == last_day:
L285                     today_hits.add(sym)
L286
L287             if dt == last_day and rows_today_printed < AUDIT_PRINT_MAX:
L288                 print(
L289                     "📝 audit: 今日の明細 "
L290                     f"{dt.date().isoformat()} {sym} High60={rh:.6g} Low={lt:.6g} "
L291                     f"baseTS={base:.3f} 阈値={threshold:.6g} 判定={breach}"
L292                 )
L293                 rows_today_printed += 1
L294
L295     print(
L296         "📝 audit: 5Dユニーク数={0} / 今日ヒット一覧={1}".format(
L297             len(uniq_hits), sorted(today_hits) if today_hits else []
L298         )
L299     )
L300
L301     if rows_today_printed == 0:
L302         reason = "、".join(sorted(set(today_reason_flags))) or "データ欠損または銘柄なし"
L303         print(f"⚠️ audit: 今日の明細が空です（理由のヒント: {reason}）")
L304
L305     k5 = len(uniq_hits)
L306     mode1 = "EMERG" if k5 >= 8 else "CAUTION" if k5 >= 6 else "NORMAL"
L307     return mode1, k5, today_hits
L308 # Debug flag
L309 debug_mode = False  # set to True for detailed output
L310
L311 # --- Finnhub settings & helper ---
L312 FINNHUB_API_KEY = os.environ.get("FINNHUB_API_KEY")
L313 if not FINNHUB_API_KEY:
L314     raise ValueError("FINNHUB_API_KEY not set (環境変数が未設定です)")
L315
L316 RATE_LIMIT = 55  # requests per minute (free tier is 60)
L317 call_times = []
L318
L319
L320 def finnhub_get(endpoint, params):
L321     """Call Finnhub API with basic rate limiting."""
L322     now = time.time()
L323     cutoff = now - 60
L324     while call_times and call_times[0] < cutoff:
L325         call_times.pop(0)
L326     if len(call_times) >= RATE_LIMIT:
L327         sleep_time = 60 - (now - call_times[0])
L328         time.sleep(sleep_time)
L329     params = {**params, "token": FINNHUB_API_KEY}
L330     try:
L331         resp = requests.get(f"https://finnhub.io/api/v1/{endpoint}", params=params)
L332         resp.raise_for_status()
L333         data = resp.json()
L334     except requests.exceptions.JSONDecodeError as e:
L335         print(f"⚠️ Finnhub API JSON decode error: {e}")
L336         return {}
L337     except Exception as e:
L338         print(f"⚠️ Finnhub API error: {e}")
L339         return {}
L340     call_times.append(time.time())
L341     return data
L342
L343
L344 def fetch_price(symbol):
L345     try:
L346         data = finnhub_get("quote", {"symbol": symbol})
L347         price = data.get("c")
L348         return float(price) if price not in (None, 0) else float("nan")
L349     except Exception:
L350         return float("nan")
L351
L352
L353 def fetch_vix_ma5():
L354     """Retrieve VIX 5-day moving average via yfinance."""
L355     try:
L356         vix = (
L357             yf.download("^VIX", period="7d", interval="1d", progress=False, auto_adjust=False)["Close"]
L358             .dropna()
L359             .tail(5)
L360         )
L361         if len(vix) < 5:
L362             return float("nan")
L363         return vix.mean().item()
L364     except Exception:
L365         return float("nan")
L366
L367
L368
L369 # === Minervini-like sell signals ===
L370 def _yf_df(sym, period="6mo"):
L371     """日足/MA/出来高平均を取得。欠損時は None。"""
L372     try:
L373         df = yf.download(sym, period=period, interval="1d", auto_adjust=False, progress=False)
L374         if df is None or df.empty:
L375             return None
L376         return df.dropna().assign(
L377             ma20=lambda d: d["Close"].rolling(20).mean(),
L378             ma50=lambda d: d["Close"].rolling(50).mean(),
L379             vol50=lambda d: d["Volume"].rolling(50).mean(),
L380         )
L381     except Exception:
L382         return None
L383
L384
L385 def _scalar(row, col):
L386     """Series/npスカラ→Pythonスカラ化（NaNはNaNのまま）"""
L387     try:
L388         v = row[col]
L389         if hasattr(v, "item"):
L390             try:
L391                 v = v.item()
L392             except Exception:
L393                 pass
L394         return v
L395     except Exception:
L396         return float("nan")
L397
L398
L399 def _is_strict_down(seq):
L400     """数列が厳密に連続で切り下がっているか（len>=4を想定）。NaN含みはFalse。"""
L401     try:
L402         xs = [float(x) for x in seq]
L403         if any(pd.isna(x) for x in xs) or len(xs) < 4:
L404             return False
L405         return all(b < a for a, b in zip(xs[:-1], xs[1:]))
L406     except Exception:
L407         return False
L408
L409
L410 def _signals_for_day(df, idx):
L411     """df.loc[idx] 1日分に対しシグナル配列を返す（値動き/出来高ベースのみ）。"""
L412     try:
L413         sig = []
L414         d = df.loc[idx]
L415         close = _scalar(d, "Close")
L416         ma20 = _scalar(d, "ma20")
L417         ma50 = _scalar(d, "ma50")
L418         vol = _scalar(d, "Volume")
L419         vol50 = _scalar(d, "vol50")
L420
L421         if pd.notna(close) and pd.notna(ma20) and close < ma20:
L422             sig.append("20DMA↓")
L423
L424         if all(pd.notna(x) for x in (close, ma50, vol, vol50)) and close < ma50 and vol > 1.5 * vol50:
L425             sig.append("50DMA↓(大商い)")
L426
L427         last4 = df.loc[:idx].tail(4)
L428         last10 = df.loc[:idx].tail(10)
L429
L430         lows_desc = _is_strict_down(last4["Low"].tolist()) if last4["Low"].notna().all() else False
L431         reds = int((last10["Close"] < last10["Open"]).sum()) if last10[["Close", "Open"]].notna().all().all() else 0
L432         if lows_desc or reds > 5:
L433             sig.append("連続安値/陰線優勢")
L434
L435         ups = int((last10["Close"] > last10["Open"]).sum()) if last10[["Close", "Open"]].notna().all().all() else 0
L436         if ups >= 7:
L437             sig.append("上げ偏重(>70%)")
L438
L439         last15 = df.loc[:idx].tail(15)
L440         base0 = _scalar(last15.iloc[0], "Close") if len(last15) > 0 else float("nan")
L441         if pd.notna(base0) and pd.notna(close) and base0 != 0 and (close / base0 - 1) >= 0.25:
L442             sig.append("+25%/15日内")
L443
L444         if len(df.loc[:idx]) >= 2:
L445             t1, t0 = df.loc[:idx].iloc[-2], df.loc[:idx].iloc[-1]
L446             t1_high = _scalar(t1, "High")
L447             t0_open = _scalar(t0, "Open")
L448             t0_close = _scalar(t0, "Close")
L449             if all(pd.notna(x) for x in (t1_high, t0_open, t0_close)):
L450                 if (t0_open > t1_high * 1.02) and (t0_close < t0_open):
L451                     sig.append("GU→陰線")
L452         return sig
L453     except Exception:
L454         return []
L455
L456
L457 def scan_sell_signals(symbols, lookback_days=5):
L458     """
L459     直近 lookback_days 日のうち一度でもシグナルが出たら {sym: [(date,[signals]),...]} を返す。
L460     日付は YYYY-MM-DD。Slackで列挙する。
L461     """
L462     out = {}
L463     for s in symbols:
L464         df = _yf_df(s)
L465         if df is None or len(df) < 60:
L466             continue
L467         alerts = []
L468         for idx in df.tail(lookback_days).index:
L469             tags = _signals_for_day(df, idx)
L470             if tags:
L471                 alerts.append((idx.strftime("%Y-%m-%d"), tags))
L472         if alerts:
L473             out[s] = alerts
L474     return out
L475
L476
L477 def load_portfolio():
L478     tickers_path = Path(__file__).with_name("current_tickers.csv")
L479     with tickers_path.open() as f:
L480         rows = [row for row in csv.reader(f) if row and row[0].strip()]
L481     n = len(rows)
L482     portfolio = []
L483     for row in rows:
L484         sym = row[0].strip().upper()
L485         qty = int(row[1]) if len(row) > 1 and row[1].strip() else 0
L486         bucket = row[2].strip().upper() if len(row) > 2 else ""
L487         entry = {
L488             "symbol": sym,
L489             "shares": qty,
L490             "target_ratio": 1 / n if n else 0.0,
L491             "bucket": bucket,
L492         }
L493         portfolio.append(entry)
L494     return portfolio
L495
L496
L497 def compute_threshold():
L498     vix_ma5 = fetch_vix_ma5()
L499     drift_threshold = 10 if vix_ma5 < 20 else 12 if vix_ma5 < 26 else float("inf")
L500     return vix_ma5, drift_threshold
L501
L502
L503 def compute_threshold_by_mode(mode: str):
L504     """モードに応じて現金保有率とドリフト閾値を返す（README準拠）"""
L505     m = (mode or "NORMAL").upper()
L506     cash_map = {"NORMAL": 0.10, "CAUTION": 0.125, "EMERG": 0.20}
L507     drift_map = config.DRIFT_THRESHOLD_BY_MODE
L508     return cash_map.get(m, 0.10), drift_map.get(m, 12)
L509
L510
L511 def recommended_counts_by_mode(mode: str) -> tuple[int, int, int]:
L512     """
L513     モード別の推奨保有数 (G_count, D_count, cash_slots) を返す。
L514     cash_slotsは「外すG枠の数」（各枠=5%）。
L515     NORMAL: G12/D8/現金化0, CAUTION: G10/D8/現金化2, EMERG: G8/D8/現金化4
L516     """
L517     m = (mode or "NORMAL").upper()
L518     base = config.COUNTS_BY_MODE.get("NORMAL", config.COUNTS_BASE)
L519     now  = config.COUNTS_BY_MODE.get(m, base)
L520     cash_slots = max(0, base["G"] - now["G"])
L521     return now["G"], now["D"], cash_slots
L522
L523
L524 def build_dataframe(portfolio):
L525     for stock in portfolio:
L526         price = fetch_price(stock["symbol"])
L527         stock["price"] = price
L528         stock["value"] = price * stock["shares"]
L529
L530     df = pd.DataFrame(portfolio)
L531     total_value = df["value"].sum()
L532     df["current_ratio"] = df["value"] / total_value
L533     df["drift"] = df["current_ratio"] - df["target_ratio"]
L534     df["drift_abs"] = df["drift"].abs()
L535     total_drift_abs = df["drift_abs"].sum()
L536     df["adjusted_ratio"] = df["current_ratio"] - df["drift"] / 2
L537     df["adjustable"] = (
L538         (df["adjusted_ratio"] * total_value) >= df["price"]
L539     ) & df["price"].notna() & df["price"].gt(0)
L540     return df, total_value, total_drift_abs
L541
L542
L543 def simulate(df, total_value, total_drift_abs, drift_threshold):
L544     alert = drift_threshold != float("inf") and total_drift_abs * 100 > drift_threshold
L545     if alert:
L546         df["trade_shares"] = df.apply(
L547             lambda r: int(round(((r["adjusted_ratio"] * total_value) - r["value"]) / r["price"]))
L548             if r["adjustable"] and r["price"] > 0 else 0,
L549             axis=1,
L550         )
L551         df["new_shares"] = df["shares"] + df["trade_shares"]
L552         df["new_value"] = df["new_shares"] * df["price"]
L553         new_total_value = df["new_value"].sum()
L554         df["simulated_ratio"] = df["new_value"] / new_total_value
L555         df["simulated_drift_abs"] = (df["simulated_ratio"] - df["target_ratio"]).abs()
L556         simulated_total_drift_abs = df["simulated_drift_abs"].sum()
L557     else:
L558         df["trade_shares"] = np.nan
L559         df["new_shares"] = np.nan
L560         df["new_value"] = np.nan
L561         new_total_value = np.nan
L562         df["simulated_ratio"] = np.nan
L563         df["simulated_drift_abs"] = np.nan
L564         simulated_total_drift_abs = np.nan
L565     return df, alert, new_total_value, simulated_total_drift_abs
L566
L567
L568 def prepare_summary(df, total_drift_abs, alert):
L569     summary = {
L570         "symbol": "合計",
L571         "shares": df["shares"].sum(),
L572         "value": df["value"].sum(),
L573         "current_ratio": np.nan,
L574         "drift_abs": total_drift_abs,
L575     }
L576     if alert:
L577         summary["trade_shares"] = np.nan
L578     # Sort details by evaluation value descending before appending summary
L579     df = df.sort_values(by="value", ascending=False)
L580     df = pd.concat([df, pd.DataFrame([summary])], ignore_index=True)
L581     if alert:
L582         cols = ["symbol", "shares", "value", "current_ratio", "drift_abs", "trade_shares"]
L583         df_small = df[cols].copy()
L584         df_small.columns = ["sym", "qty", "val", "now", "|d|", "Δqty"]
L585     else:
L586         cols = ["symbol", "shares", "value", "current_ratio", "drift_abs"]
L587         df_small = df[cols].copy()
L588         df_small.columns = ["sym", "qty", "val", "now", "|d|"]
L589     return df_small
L590
L591
L592 def currency(x):
L593     return f"${x:,.0f}" if pd.notnull(x) else ""
L594
L595
L596 def formatters_for(alert):
L597     formatters = {"val": currency, "now": "{:.2%}".format, "|d|": "{:.2%}".format}
L598     if alert:
L599         formatters["Δqty"] = "{:.0f}".format
L600     return formatters
L601
L602
L603 def build_header(mode, cash_ratio, drift_threshold, total_drift_abs, alert, simulated_total_drift_abs):
L604     header = (
L605         f"*💼 現金保有率:* {cash_ratio*100:.1f}%\n"
L606         f"*📊 ドリフト閾値:* {'🔴(停止)' if drift_threshold == float('inf') else str(drift_threshold)+'%'}\n"
L607         f"*📉 現在のドリフト合計:* {total_drift_abs * 100:.2f}%\n"
L608     )
L609     if alert:
L610         header += f"*🔁 半戻し後ドリフト合計(想定):* {simulated_total_drift_abs * 100:.2f}%\n"
L611         header += "🚨 *アラート: 発生！！ Δqtyのマイナス銘柄を売却、任意の銘柄を買い増してバランスを取りましょう！*\n"
L612     else:
L613         header += "✅ アラートなし\n"
L614     # ★ 追記: TSルール（G/D共通）と推奨保有数
L615     # TS(基本)をモードで動的表示。段階TSは「基本から -3/-6/-8 pt」固定。
L616     base_ts = config.TS_BASE_BY_MODE.get(mode.upper(), config.TS_BASE_BY_MODE["NORMAL"])
L617     d1, d2, d3 = config.TS_STEP_DELTAS_PT
L618     ts_line = f"*🛡 TS:* 基本 -{base_ts*100:.0f}% / +30%→-{max(base_ts*100 - d1, 0):.0f}% / +60%→-{max(base_ts*100 - d2, 0):.0f}% / +100%→-{max(base_ts*100 - d3, 0):.0f}%\n"
L619     header += ts_line
L620     g_cnt, d_cnt, cash_slots = recommended_counts_by_mode(mode)
L621     cash_pct = cash_slots * (100 / (config.TOTAL_TARGETS))  # 1枠=総数分割の%（20銘柄なら5%）
L622     header += f"*📋 推奨保有数:* G {g_cnt} / D {d_cnt}（現金化枠 {cash_slots}枠 ≒ {cash_pct:.0f}%）\n"
L623     return header
L624
L625
L626 def send_slack(text):
L627     SLACK_WEBHOOK_URL = os.environ.get("SLACK_WEBHOOK_URL")
L628     if not SLACK_WEBHOOK_URL:
L629         raise ValueError("SLACK_WEBHOOK_URL not set (環境変数が未設定です)")
L630     payload = {"text": text}
L631     try:
L632         resp = requests.post(SLACK_WEBHOOK_URL, json=payload)
L633         resp.raise_for_status()
L634         print("✅ Slack（Webhook）へ送信しました")
L635     except Exception as e:
L636         print(f"⚠️ Slack通知エラー: {e}")
L637
L638
L639 def send_debug(debug_text):
L640     SLACK_WEBHOOK_URL = os.environ.get("SLACK_WEBHOOK_URL")
L641     if not SLACK_WEBHOOK_URL:
L642         raise ValueError("SLACK_WEBHOOK_URL not set (環境変数が未設定です)")
L643     debug_payload = {"text": "```" + debug_text + "```"}
L644     try:
L645         resp = requests.post(SLACK_WEBHOOK_URL, json=debug_payload)
L646         resp.raise_for_status()
L647         print("✅ Debug情報をSlackに送信しました")
L648     except Exception as e:
L649         print(f"⚠️ Slack通知エラー: {e}")
L650
L651
L652 def main():
L653     portfolio = load_portfolio()
L654     symbols = [r["symbol"] for r in portfolio]
L655     g_syms = _load_growth_symbols(portfolio)
L656     sell_alerts = scan_sell_signals(symbols, lookback_days=5)
L657
L658     breadth_block, breadth_mode, breadth_score = build_breadth_header()
L659     ts_mode, k5, today_hits = _ts_mode_growth_5d(g_syms, breadth_mode)
L660     combo_mode = _combine_modes(ts_mode, breadth_mode)
L661
L662     cash_ratio, drift_threshold = compute_threshold_by_mode(breadth_mode)
L663
L664     df, total_value, total_drift_abs = build_dataframe(portfolio)
L665     df, alert, new_total_value, simulated_total_drift_abs = simulate(
L666         df, total_value, total_drift_abs, drift_threshold
L667     )
L668     df_small = prepare_summary(df, total_drift_abs, alert)
L669     if 'df_small' in locals() and isinstance(df_small, pd.DataFrame) and not df_small.empty:
L670         col_sym = "sym" if "sym" in df_small.columns else ("symbol" if "symbol" in df_small.columns else None)
L671         if col_sym:
L672             alert_keys = {str(k) for k in sell_alerts.keys()}
L673             df_small[col_sym] = df_small[col_sym].astype(str)
L674             df_small.insert(0, "⚠", df_small[col_sym].map(lambda x: "🔴" if x in alert_keys else ""))
L675             latest_tag = {s: " / ".join(sell_alerts[s][-1][1]) for s in sell_alerts}
L676             df_small.insert(1, "sig", df_small[col_sym].map(latest_tag).fillna(""))
L677     formatters = formatters_for(alert)
L678     header_core = build_header(
L679         breadth_mode, cash_ratio, drift_threshold, total_drift_abs, alert, simulated_total_drift_abs
L680     )
L681
L682     g_count = len(g_syms)
L683     hits_line = "なし" if not today_hits else ", ".join(sorted(today_hits))
L684     summary_lines = [
L685         f"① Growth TS: {_format_mode(ts_mode)} （5Dユニーク: {k5} / G={g_count}）",
L686         f"・当日ヒット: {hits_line}",
L687         f"② Breadth: {_format_mode(breadth_mode)} （テンプレ合格本数: {breadth_score}）",
L688         f"総合（OR悪化/AND回復）: {_format_mode(combo_mode)}",
L689     ]
L690     prepend_block = "\n".join(summary_lines)
L691
L692     if breadth_block:
L693         if breadth_block.startswith("```"):
L694             inner = breadth_block[len("```") :]
L695             if inner.startswith("\n"):
L696                 inner = inner[1:]
L697             if inner.endswith("```"):
L698                 inner = inner[: -len("```")]
L699             inner = inner.strip("\n")
L700             inner_lines = [line for line in inner.splitlines() if "現在モード" not in line]
L701             cleaned_inner = "\n".join(inner_lines)
L702             if cleaned_inner:
L703                 new_inner = prepend_block + "\n" + cleaned_inner
L704             else:
L705                 new_inner = prepend_block
L706             breadth_block = "```\n" + new_inner + "\n```"
L707         else:
L708             lines = [line for line in breadth_block.splitlines() if "現在モード" not in line]
L709             cleaned_block = "\n".join(lines)
L710             breadth_block = prepend_block + ("\n" + cleaned_block if cleaned_block else "")
L711         header = breadth_block + "\n" + header_core
L712     else:
L713         header = prepend_block + "\n" + header_core
L714     if sell_alerts:
L715         def fmt_pair(date_tags):
L716             date, tags = date_tags
L717             return f"{date}:" + "・".join(tags)
L718         listed = []
L719         for t, arr in sell_alerts.items():
L720             listed.append(f"*{t}*（" + ", ".join(fmt_pair(x) for x in arr) + "）")
L721         hits = ", ".join(listed)
L722         if "✅ アラートなし" in header:
L723             header = header.replace(
L724                 "✅ アラートなし",
L725                 f"⚠️ 売りシグナルあり: {len(sell_alerts)}銘柄\n🟥 {hits}",
L726             )
L727         else:
L728             header += f"\n🟥 {hits}"
L729     table_text = df_small.to_string(formatters=formatters, index=False)
L730     send_slack(header + "\n```" + table_text + "```")
L731
L732     if debug_mode:
L733         debug_cols = [
L734             "symbol",
L735             "shares",
L736             "price",
L737             "value",
L738             "current_ratio",
L739             "drift",
L740             "drift_abs",
L741             "adjusted_ratio",
L742             "adjustable",
L743             "trade_shares",
L744             "new_shares",
L745             "new_value",
L746             "simulated_ratio",
L747             "simulated_drift_abs",
L748         ]
L749         debug_text = (
L750             "=== DEBUG: full dataframe ===\n"
L751             + df[debug_cols].to_string()
L752             + f"\n\ntotal_value={total_value}, new_total_value={new_total_value}\n"
L753             + f"total_drift_abs={total_drift_abs}, simulated_total_drift_abs={simulated_total_drift_abs}"
L754         )
L755         print("\n" + debug_text)
L756         send_debug(debug_text)
L757
L758
L759 if __name__ == "__main__":
L760     main()
L761
```

## <.github/workflows/daily-report.yml>
```text
L1 name: Daily Stock Report
L2
L3 on:
L4   push:
L5     branches: [ main ]
L6     paths-ignore:
L7       - 'CodeForChat/**'
L8   schedule:
L9     - cron: '30 23 * * 2-6'  # UTC 23:30 → JST 08:30（火〜土）
L10   workflow_dispatch:
L11
L12 jobs:
L13   build-and-report:
L14     runs-on: ubuntu-latest
L15
L16     steps:
L17       - name: Debug start
L18         run: echo '🚀 DEBUGstarted'
L19               
L20       - name: Checkout repository
L21         uses: actions/checkout@v3
L22
L23       - name: Setup Python
L24         uses: actions/setup-python@v4
L25         with:
L26           python-version: '3.x'
L27
L28       - name: Install dependencies
L29         run: pip install -r requirements.txt
L30
L31       - name: Prepare results directory
L32         run: mkdir -p results
L33
L34       - name: Run drift.py
L35         env:
L36           SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
L37           FINNHUB_API_KEY: ${{ secrets.FINNHUB_API_KEY }}
L38         run: python drift.py
L39
L40       - name: Persist breadth_state.json
L41         if: always()
L42         run: |
L43           git config user.name  "github-actions[bot]"
L44           git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
L45           git add results/breadth_state.json || true
L46           git commit -m "chore: update breadth_state [skip ci]" || echo "no changes"
L47           git push || true
```

## <documents/README.md>
```text
L1 # 運用ルール（改訂版）
L2
L3 ## 基本構成
L4 - 20銘柄を均等配分（現金を除き1銘柄あたり5%）  
L5 - moomoo証券で運用  
L6 - **Growth枠 12銘柄 / Defense枠 8銘柄**
L7
L8 ---
L9
L10 ## Barbell Growth-Defense方針
L11 - **Growth枠（12銘柄）**：トレンドを追う**スイングトレード**。高成長・高ボラ銘柄でリターン源泉を狙う。  
L12 - **Defense枠（8銘柄）**：安定重視の**ポジショントレード（やや長期）**。低ボラ・高品質でMDDを抑制。  
L13 - 「猛烈に伸びる攻め × 着実に稼ぐ盾」の組合せで乖離を生み、**半戻しリバランス**でプレミアムを獲得。
L14
L15 ---
L16
L17 ## モード判定（コンボ：先導株TS × ブレッドス）
L18
L19 **考え方：** *悪化はゆるく（OR）、回復は厳しく（AND）*
L20
L21 ### ① 先導株TSシグナル（Growthのみ）
L22 - 対象（Growthの定義）：当日保有銘柄のうち **β ≥ -0.6** を Growth とみなす（Defenseは無視）
L23 - 判定：直近60日高値からモード別基本TS幅（NORMAL:-15% / CAUTION:-13% / EMERG:-10%）以上の下落を「TS抵触」とみなす
L24 - 集計：直近5営業日のユニーク抵触銘柄数
L25   - 8銘柄以上 → ①=EMERG
L26   - 6銘柄以上 → ①=CAUTION
L27   - それ未満 → ①=NORMAL
L28 - 補足：同一日に複数回実行した場合は、**同日上書き**で管理
L29
L30 ### ② ブレッドス（trend_template 合格本数）
L31 - current+candidate 全体で trend_template 条件を満たした銘柄数（基準 N_G=12）
L32 - 閾値：過去600営業日の分布から自動採用（分位点と運用“床”のmax）
L33   - 緊急入り: max(q05, 12本)
L34   - 緊急解除: max(q20, 18本)
L35   - 通常復帰: max(q60, 36本)
L36 - ヒステリシス：前回モードに依存（EMERG→解除は23本以上、CAUTION→通常は45本以上）
L37
L38 ### コンボルール
L39 - **悪化（ダウングレード）**：
L40   final_mode = max(mode①, mode②)
L41   - 例：①=CAUTION, ②=NORMAL → final=CAUTION
L42   - 例：①=EMERG, ②=CAUTION → final=EMERG
L43
L44 - **回復（アップグレード）**：
L45   final_mode を1段階下げるには、mode① と mode② がともに下位モードに揃った場合のみ
L46   - 例：EMERG→CAUTION は ①=CAUTION **かつ** ②=CAUTION
L47   - 例：CAUTION→NORMAL は ①=NORMAL **かつ** ②=NORMAL
L48
L49 > 直感フレーズ：**「悪化はどちらか赤で赤、回復は両方青で青」**
L50
L51 ---
L52
L53 ## モード別設定（現金・ドリフト・保有数）
L54
L55 | モード       | 現金比率 | ドリフト閾値      | 基本TS幅 | Growth枠数 | Defense枠数 | 補足 |
L56 |--------------|----------|-------------------|----------|------------|-------------|------|
L57 | **NORMAL**   | 10%      | 12%               | -15%     | 12         | 8           | フル20銘柄（現金化枠なし） |
L58 | **CAUTION**  | 20%      | 14%               | -13%     | 10         | 8           | Gを2枠外し=現金化10% |
L59 | **EMERG**    | 30%      | ドリフト売買停止 | -10%     | 8          | 8           | Gを4枠外し=現金化20% |
L60
L61 - 含み益到達時のTSタイト化：+30% → -3pt、+60% → -6pt、+100% → -8pt
L62 - 含み益 +100% 達成時は50%を利確し、残りはフリーポジションとして -15%TS で保有継続
L63 - TS発動後のクールダウンは廃止（翌日以降すぐに再IN可）
L64
L65 ---
L66
L67 ## 新規買付
L68 - **新規INは等分比率（=5%）の半分まで**を上限。  
L69 - 追加補充や半戻し買付も同じ上限に従う。
L70
L71 ---
L72
L73 ## 半戻し（リバランス）
L74 1. **現金比率 ≤ 閾値**：過重量銘柄を売却し、不足銘柄を補充。  
L75 2. **現金比率 > 閾値**：**売却は行わず**、現金でドリフト不足銘柄を買付（現金比率を閾値以下へ戻すことを優先）。  
L76 3. **共通**：リバランス後は全銘柄のTSを再設定。EMERGでは「ドリフト売買停止」、20銘柄×5%全戻しのみ許容。
L77
L78 ---
L79
L80 ## モード移行の実務手順
L81 - モードが変わったら、**MMF≒現金**として扱い、Growth枠数だけ調整：  
L82   1. **Gを削る**（CAUTION/EMERG）：⭐️低スコアのGから順に外し、`current_tickers.csv` から行削除（=現金化）。  
L83   2. **現金として保持**。  
L84   3. **NORMAL復帰時の補充**：`current_tickers.csv` に銘柄を追加（スコア上位から）。以降は日次ドリフト/TSルールに従う。  
L85 > driftは `target_ratio = 1/銘柄数` を自動適用。行数に応じて均等比率を再計算。
L86
L87 ---
L88
L89 ## 入替銘柄選定
L90 - **ファクター分散最適化手法を用いて日次でスコア集計**し、**スコア上位からIN/OUT**を決定。  
L91 - 参考：Oxfordキャピタル、Alpha Investor、Motley Fool、moomooスクリーニング等。  
L92 - 年間NISA枠はGrowth群から低ボラ銘柄を選定し利用（長期保持に固執しない）。
L93
L94 ---
L95
L96 ## 実行タイミング
L97 - 判定：米国市場終値直後  
L98 - 執行：翌営業日の米国寄付き成行
```

## <documents/drift_design.md>
```text
L1 # drift.py 詳細設計書
L2
L3 ## 概要
L4 - 20銘柄ポートフォリオのドリフトを日次監視し、閾値超過時に半戻し案をSlack通知するスクリプト。
L5 - Finnhubとyfinanceから価格を取得（レジームは trend_template 本数に基づく（基準 N_G=12））。
L6   - 緊急入り: `max(q05, 12本)`
L7   - 緊急解除: `max(q20, 18本)` （ceil(1.5*12)）
L8   - 通常復帰: `max(q60, 36本)` （3*12）
L9
L10 ## 定数・設定
L11 - `FINNHUB_API_KEY` / `SLACK_WEBHOOK_URL` を環境変数から取得。
L12 - 無料枠を考慮したAPIレート制限: `RATE_LIMIT = 55`。
L13 - デバッグ出力用フラグ `debug_mode`。
L14
L15 ## 主な関数
L16 ### finnhub_get
L17 - 基本的なレート制限付きでFinnhub APIを呼び出し、JSONレスポンスを辞書で返す。
L18
L19 ### fetch_price
L20 - `quote` エンドポイントで株価を取得し、失敗時は `NaN` を返す。
L21
L22 ### fetch_vix_ma5
L23 - yfinanceでVIX終値を取得する関数。将来再利用のため残置。
L24
L25 ### load_portfolio
L26 - `current_tickers.csv` から銘柄と保有株数を読み込み、目標比率4%を付与したリストを生成。
L27
L28 ### compute_threshold_by_mode
L29 - モード(NORMAL/CAUTION/EMERG) に応じて **12% / 14% / 停止(∞)** を返す（`config.py` を参照）。
L30
L31 ### build_dataframe
L32 - 各銘柄の評価額や現在比率、ドリフト、半戻し後比率(`adjusted_ratio`)を計算しDataFrame化。
L33
L34 ### simulate
L35 - ドリフト合計が閾値を超えた場合、半戻し後の売買株数と新比率を試算し、シミュレート後ドリフトを返す。
L36
L37 ### prepare_summary
L38 - 評価額順に並べ替えた後、合計行を付与してSlack表示用テーブルを作成。
L39
L40 ### formatters_for / currency
L41 - 通貨・比率・株数の表示フォーマットを定義。
L42
L43 ### build_header
L44 - 現金保有率・閾値・ドリフト値およびアラート有無をSlackメッセージ用ヘッダに整形。TS(基本)はモード別に `config.py` から動的表示し、段階TSは base から -3/-6/-8 pt。
L45
L46 ### send_slack / send_debug
L47 - 通常通知およびデバッグ詳細をSlack Webhookへ送信。
L48
L49 ### main
L50 - 上記関数を順に呼び出し、日次ドリフトチェックの一連処理を実行。
L51
L52 ## 実行フロー
L53 1. `load_portfolio` で現ポートフォリオを読み込む。
L54 2. `build_breadth_header` でモードを取得し、`compute_threshold_by_mode` で現金保有率とドリフト閾値を決定。
L55 3. `build_dataframe` で現在比率とドリフトを計算。
L56 4. `simulate` で閾値超過時の半戻し案を試算。
L57 5. `prepare_summary` と `build_header` で通知本文とテーブルを構築。
L58 6. `send_slack` で結果を送信。`debug_mode` がTrueなら `send_debug` も併用。
```
