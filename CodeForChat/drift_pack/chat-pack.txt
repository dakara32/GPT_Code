# === Chat Paste Pack ===
# Repo: dakara32/GPT_Code @ main
# Files: drift.py, .github/workflows/daily-report.yml, documents/README.md, documents/drift_design.md
# 使い方: 下のチャンクを順に貼ればこのチャットで全体把握できます。
# 注記: 各ファイルは個別に L1.. で行番号付与。
---

## <drift.py>
```text
L1 import pandas as pd, yfinance as yf
L2 import numpy as np
L3 import requests
L4 import os
L5 import csv
L6 import json
L7 import time
L8 from pathlib import Path
L9 import config
L10
L11 # --- breadth utilities (factor parity) ---
L12 BENCH = "^GSPC"
L13 CAND_PRICE_MAX = 450.0
L14 RESULTS_DIR = "results"
L15 os.makedirs(RESULTS_DIR, exist_ok=True)
L16
L17
L18 def _state_file():
L19     return str(Path(RESULTS_DIR) / "breadth_state.json")
L20
L21
L22 def load_mode(default="NORMAL"):
L23     try:
L24         m = json.loads(open(_state_file()).read()).get("mode", default)
L25         return m if m in ("EMERG","CAUTION","NORMAL") else default
L26     except Exception:
L27         return default
L28
L29
L30 def save_mode(mode: str):
L31     try:
L32         open(_state_file(),"w").write(json.dumps({"mode": mode}))
L33     except Exception:
L34         pass
L35
L36
L37 def _read_csv_list(fname):
L38     p = Path(__file__).with_name(fname)
L39     if not p.exists(): return []
L40     return pd.read_csv(p, header=None).iloc[:,0].astype(str).str.upper().tolist()
L41
L42
L43 def _load_universe():
L44     # exist + candidate を使用。candidate は価格上限で事前フィルタ
L45     exist = _read_csv_list("current_tickers.csv")
L46     cand  = _read_csv_list("candidate_tickers.csv")
L47     cand_info = yf.Tickers(" ".join(cand)) if cand else None
L48     cand_keep = []
L49     for t in cand:
L50         try:
L51             px = cand_info.tickers[t].fast_info.get("lastPrice", float("inf"))
L52         except Exception:
L53             px = float("inf")
L54         if pd.notna(px) and float(px) <= CAND_PRICE_MAX:
L55             cand_keep.append(t)
L56     tickers = sorted(set(exist + cand_keep))
L57     return exist, cand_keep, tickers
L58
L59
L60 def _fetch_prices_600d(tickers):
L61     data = yf.download(tickers + [BENCH], period="600d", auto_adjust=True, progress=False)
L62     px   = data["Close"].dropna(how="all", axis=1)
L63     spx  = data["Close"][BENCH].dropna()
L64     return px, spx
L65
L66
L67 def trend_template_breadth_series(px: pd.DataFrame, spx: pd.Series, win_days: int | None = None) -> pd.Series:
L68     # scorer.py の実装をそのまま移植（ベクトル化版）
L69     import numpy as np, pandas as pd
L70     if px is None or px.empty:
L71         return pd.Series(dtype=int)
L72     px = px.dropna(how="all", axis=1)
L73     if win_days and win_days > 0:
L74         px = px.tail(win_days)
L75     if px.empty:
L76         return pd.Series(dtype=int)
L77     spx = spx.reindex(px.index).ffill()
L78
L79     ma50  = px.rolling(50).mean()
L80     ma150 = px.rolling(150).mean()
L81     ma200 = px.rolling(200).mean()
L82
L83     tt = (px > ma150)
L84     tt &= (px > ma200)
L85     tt &= (ma150 > ma200)
L86     tt &= (ma200 - ma200.shift(21) > 0)
L87     tt &= (ma50  > ma150)
L88     tt &= (ma50  > ma200)
L89     tt &= (px    > ma50)
L90
L91     lo252 = px.rolling(252).min()
L92     hi252 = px.rolling(252).max()
L93     tt &= (px.divide(lo252).sub(1.0) >= 0.30)
L94     tt &= (px >= (0.75 * hi252))
L95
L96     r12  = px.divide(px.shift(252)).sub(1.0)
L97     br12 = spx.divide(spx.shift(252)).sub(1.0)
L98     r1   = px.divide(px.shift(22)).sub(1.0)
L99     br1  = spx.divide(spx.shift(22)).sub(1.0)
L100     rs   = 0.7*(r12.sub(br12, axis=0)) + 0.3*(r1.sub(br1, axis=0))
L101     tt &= (rs >= 0.10)
L102
L103     return tt.fillna(False).sum(axis=1).astype(int)
L104
L105
L106 def build_breadth_header():
L107     # factor._build_breadth_lead_lines と同一挙動
L108     exist, cand, tickers = _load_universe()
L109     if not tickers:
L110         return "", "NORMAL", 0
L111     px, spx = _fetch_prices_600d(tickers)
L112     win = int(os.getenv("BREADTH_CALIB_WIN_DAYS", "600"))
L113     C_ts = trend_template_breadth_series(px, spx, win_days=win)
L114     if C_ts.empty:
L115         return "", "NORMAL", 0
L116     warmup = int(os.getenv("BREADTH_WARMUP_DAYS","252"))
L117     base = C_ts.iloc[warmup:] if len(C_ts)>warmup else C_ts
L118     C_full = int(C_ts.iloc[-1])
L119
L120     q05 = int(np.nan_to_num(base.quantile(float(os.getenv("BREADTH_Q_EMERG_IN",  "0.05"))), nan=0.0))
L121     q20 = int(np.nan_to_num(base.quantile(float(os.getenv("BREADTH_Q_EMERG_OUT", "0.20"))), nan=0.0))
L122     q60 = int(np.nan_to_num(base.quantile(float(os.getenv("BREADTH_Q_WARN_OUT",  "0.60"))), nan=0.0))
L123
L124     # G枠サイズ（Breadth基準）
L125     N_G = config.N_G
L126     th_in_rec   = max(N_G, q05)
L127     th_out_rec  = max(int(np.ceil(1.5*N_G)), q20)
L128     th_norm_rec = max(3*N_G, q60)
L129
L130     use_calib = os.getenv("BREADTH_USE_CALIB", "true").strip().lower() == "true"
L131     if use_calib:
L132         th_in, th_out, th_norm, th_src = th_in_rec, th_out_rec, th_norm_rec, "自動"
L133     else:
L134         th_in   = int(os.getenv("GTT_EMERG_IN", str(N_G)))
L135         th_out  = int(os.getenv("GTT_EMERG_OUT", str(int(1.5*N_G))))
L136         th_norm = int(os.getenv("GTT_CAUTION_OUT", str(3*N_G)))
L137         th_src = "手動"
L138
L139     prev = load_mode("NORMAL")
L140     if   prev == "EMERG":
L141         mode = "EMERG"   if (C_full < th_out)  else ("CAUTION" if (C_full < th_norm) else "NORMAL")
L142     elif prev == "CAUTION":
L143         mode = "CAUTION" if (C_full < th_norm) else "NORMAL"
L144     else:
L145         mode = "EMERG"   if (C_full < th_in)   else ("CAUTION" if (C_full < th_norm) else "NORMAL")
L146     save_mode(mode)
L147
L148     _MODE_JA   = {"EMERG":"緊急","CAUTION":"警戒","NORMAL":"通常"}
L149     _MODE_EMOJI= {"EMERG":"🚨","CAUTION":"⚠️","NORMAL":"🟢"}
L150     mode_ja, emoji = _MODE_JA.get(mode,mode), _MODE_EMOJI.get(mode,"ℹ️")
L151     eff_days = len(base)
L152
L153     lead_lines = [
L154         f"{emoji} *現在モード: {mode_ja}*",
L155         f"テンプレ合格本数: *{C_full}本*",
L156         "しきい値（{0}）".format(th_src),
L157         f"  ・緊急入り: <{th_in}本",
L158         f"  ・緊急解除: ≥{th_out}本",
L159         f"  ・通常復帰: ≥{th_norm}本",
L160         f"参考指標（過去~{win}営業日, 有効={eff_days}日）",
L161         f"  ・下位5%: {q05}本",
L162         f"  ・下位20%: {q20}本",
L163         f"  ・60%分位: {q60}本",
L164     ]
L165     return "```" + "\n".join(lead_lines) + "```", mode, C_full
L166 # Debug flag
L167 debug_mode = False  # set to True for detailed output
L168
L169 # --- Finnhub settings & helper ---
L170 FINNHUB_API_KEY = os.environ.get("FINNHUB_API_KEY")
L171 if not FINNHUB_API_KEY:
L172     raise ValueError("FINNHUB_API_KEY not set (環境変数が未設定です)")
L173
L174 RATE_LIMIT = 55  # requests per minute (free tier is 60)
L175 call_times = []
L176
L177
L178 def finnhub_get(endpoint, params):
L179     """Call Finnhub API with basic rate limiting."""
L180     now = time.time()
L181     cutoff = now - 60
L182     while call_times and call_times[0] < cutoff:
L183         call_times.pop(0)
L184     if len(call_times) >= RATE_LIMIT:
L185         sleep_time = 60 - (now - call_times[0])
L186         time.sleep(sleep_time)
L187     params = {**params, "token": FINNHUB_API_KEY}
L188     try:
L189         resp = requests.get(f"https://finnhub.io/api/v1/{endpoint}", params=params)
L190         resp.raise_for_status()
L191         data = resp.json()
L192     except requests.exceptions.JSONDecodeError as e:
L193         print(f"⚠️ Finnhub API JSON decode error: {e}")
L194         return {}
L195     except Exception as e:
L196         print(f"⚠️ Finnhub API error: {e}")
L197         return {}
L198     call_times.append(time.time())
L199     return data
L200
L201
L202 def fetch_price(symbol):
L203     try:
L204         data = finnhub_get("quote", {"symbol": symbol})
L205         price = data.get("c")
L206         return float(price) if price not in (None, 0) else float("nan")
L207     except Exception:
L208         return float("nan")
L209
L210
L211 def fetch_vix_ma5():
L212     """Retrieve VIX 5-day moving average via yfinance."""
L213     try:
L214         vix = (
L215             yf.download("^VIX", period="7d", interval="1d", progress=False, auto_adjust=False)["Close"]
L216             .dropna()
L217             .tail(5)
L218         )
L219         if len(vix) < 5:
L220             return float("nan")
L221         return vix.mean().item()
L222     except Exception:
L223         return float("nan")
L224
L225
L226
L227 # === Minervini-like sell signals ===
L228 def _yf_df(sym, period="6mo"):
L229     """日足/MA/出来高平均を取得。欠損時は None。"""
L230     try:
L231         df = yf.download(sym, period=period, interval="1d", auto_adjust=False, progress=False)
L232         if df is None or df.empty:
L233             return None
L234         return df.dropna().assign(
L235             ma20=lambda d: d["Close"].rolling(20).mean(),
L236             ma50=lambda d: d["Close"].rolling(50).mean(),
L237             vol50=lambda d: d["Volume"].rolling(50).mean(),
L238         )
L239     except Exception:
L240         return None
L241
L242
L243 def _scalar(row, col):
L244     """Series/npスカラ→Pythonスカラ化（NaNはNaNのまま）"""
L245     try:
L246         v = row[col]
L247         if hasattr(v, "item"):
L248             try:
L249                 v = v.item()
L250             except Exception:
L251                 pass
L252         return v
L253     except Exception:
L254         return float("nan")
L255
L256
L257 def _is_strict_down(seq):
L258     """数列が厳密に連続で切り下がっているか（len>=4を想定）。NaN含みはFalse。"""
L259     try:
L260         xs = [float(x) for x in seq]
L261         if any(pd.isna(x) for x in xs) or len(xs) < 4:
L262             return False
L263         return all(b < a for a, b in zip(xs[:-1], xs[1:]))
L264     except Exception:
L265         return False
L266
L267
L268 def _signals_for_day(df, idx):
L269     """df.loc[idx] 1日分に対しシグナル配列を返す（値動き/出来高ベースのみ）。"""
L270     try:
L271         sig = []
L272         d = df.loc[idx]
L273         close = _scalar(d, "Close")
L274         ma20 = _scalar(d, "ma20")
L275         ma50 = _scalar(d, "ma50")
L276         vol = _scalar(d, "Volume")
L277         vol50 = _scalar(d, "vol50")
L278
L279         if pd.notna(close) and pd.notna(ma20) and close < ma20:
L280             sig.append("20DMA↓")
L281
L282         if all(pd.notna(x) for x in (close, ma50, vol, vol50)) and close < ma50 and vol > 1.5 * vol50:
L283             sig.append("50DMA↓(大商い)")
L284
L285         last4 = df.loc[:idx].tail(4)
L286         last10 = df.loc[:idx].tail(10)
L287
L288         lows_desc = _is_strict_down(last4["Low"].tolist()) if last4["Low"].notna().all() else False
L289         reds = int((last10["Close"] < last10["Open"]).sum()) if last10[["Close", "Open"]].notna().all().all() else 0
L290         if lows_desc or reds > 5:
L291             sig.append("連続安値/陰線優勢")
L292
L293         ups = int((last10["Close"] > last10["Open"]).sum()) if last10[["Close", "Open"]].notna().all().all() else 0
L294         if ups >= 7:
L295             sig.append("上げ偏重(>70%)")
L296
L297         last15 = df.loc[:idx].tail(15)
L298         base0 = _scalar(last15.iloc[0], "Close") if len(last15) > 0 else float("nan")
L299         if pd.notna(base0) and pd.notna(close) and base0 != 0 and (close / base0 - 1) >= 0.25:
L300             sig.append("+25%/15日内")
L301
L302         if len(df.loc[:idx]) >= 2:
L303             t1, t0 = df.loc[:idx].iloc[-2], df.loc[:idx].iloc[-1]
L304             t1_high = _scalar(t1, "High")
L305             t0_open = _scalar(t0, "Open")
L306             t0_close = _scalar(t0, "Close")
L307             if all(pd.notna(x) for x in (t1_high, t0_open, t0_close)):
L308                 if (t0_open > t1_high * 1.02) and (t0_close < t0_open):
L309                     sig.append("GU→陰線")
L310         return sig
L311     except Exception:
L312         return []
L313
L314
L315 def scan_sell_signals(symbols, lookback_days=5):
L316     """
L317     直近 lookback_days 日のうち一度でもシグナルが出たら {sym: [(date,[signals]),...]} を返す。
L318     日付は YYYY-MM-DD。Slackで列挙する。
L319     """
L320     out = {}
L321     for s in symbols:
L322         df = _yf_df(s)
L323         if df is None or len(df) < 60:
L324             continue
L325         alerts = []
L326         for idx in df.tail(lookback_days).index:
L327             tags = _signals_for_day(df, idx)
L328             if tags:
L329                 alerts.append((idx.strftime("%Y-%m-%d"), tags))
L330         if alerts:
L331             out[s] = alerts
L332     return out
L333
L334
L335 def load_portfolio():
L336     tickers_path = Path(__file__).with_name("current_tickers.csv")
L337     with tickers_path.open() as f:
L338         reader = list(csv.reader(f))
L339     return [
L340         {"symbol": sym.strip().upper(), "shares": int(qty), "target_ratio": 1 / len(reader)}
L341         for sym, qty in reader
L342     ]
L343
L344
L345 def compute_threshold():
L346     vix_ma5 = fetch_vix_ma5()
L347     drift_threshold = 10 if vix_ma5 < 20 else 12 if vix_ma5 < 26 else float("inf")
L348     return vix_ma5, drift_threshold
L349
L350
L351 def compute_threshold_by_mode(mode: str):
L352     """モードに応じて現金保有率とドリフト閾値を返す（README準拠）"""
L353     m = (mode or "NORMAL").upper()
L354     cash_map = {"NORMAL": 0.10, "CAUTION": 0.125, "EMERG": 0.20}
L355     drift_map = config.DRIFT_THRESHOLD_BY_MODE
L356     return cash_map.get(m, 0.10), drift_map.get(m, 12)
L357
L358
L359 def recommended_counts_by_mode(mode: str) -> tuple[int, int, int]:
L360     """
L361     モード別の推奨保有数 (G_count, D_count, cash_slots) を返す。
L362     cash_slotsは「外すG枠の数」（各枠=5%）。
L363     NORMAL: G12/D8/現金化0, CAUTION: G10/D8/現金化2, EMERG: G8/D8/現金化4
L364     """
L365     m = (mode or "NORMAL").upper()
L366     base = config.COUNTS_BY_MODE.get("NORMAL", config.COUNTS_BASE)
L367     now  = config.COUNTS_BY_MODE.get(m, base)
L368     cash_slots = max(0, base["G"] - now["G"])
L369     return now["G"], now["D"], cash_slots
L370
L371
L372 def build_dataframe(portfolio):
L373     for stock in portfolio:
L374         price = fetch_price(stock["symbol"])
L375         stock["price"] = price
L376         stock["value"] = price * stock["shares"]
L377
L378     df = pd.DataFrame(portfolio)
L379     total_value = df["value"].sum()
L380     df["current_ratio"] = df["value"] / total_value
L381     df["drift"] = df["current_ratio"] - df["target_ratio"]
L382     df["drift_abs"] = df["drift"].abs()
L383     total_drift_abs = df["drift_abs"].sum()
L384     df["adjusted_ratio"] = df["current_ratio"] - df["drift"] / 2
L385     df["adjustable"] = (
L386         (df["adjusted_ratio"] * total_value) >= df["price"]
L387     ) & df["price"].notna() & df["price"].gt(0)
L388     return df, total_value, total_drift_abs
L389
L390
L391 def simulate(df, total_value, total_drift_abs, drift_threshold):
L392     alert = drift_threshold != float("inf") and total_drift_abs * 100 > drift_threshold
L393     if alert:
L394         df["trade_shares"] = df.apply(
L395             lambda r: int(round(((r["adjusted_ratio"] * total_value) - r["value"]) / r["price"]))
L396             if r["adjustable"] and r["price"] > 0 else 0,
L397             axis=1,
L398         )
L399         df["new_shares"] = df["shares"] + df["trade_shares"]
L400         df["new_value"] = df["new_shares"] * df["price"]
L401         new_total_value = df["new_value"].sum()
L402         df["simulated_ratio"] = df["new_value"] / new_total_value
L403         df["simulated_drift_abs"] = (df["simulated_ratio"] - df["target_ratio"]).abs()
L404         simulated_total_drift_abs = df["simulated_drift_abs"].sum()
L405     else:
L406         df["trade_shares"] = np.nan
L407         df["new_shares"] = np.nan
L408         df["new_value"] = np.nan
L409         new_total_value = np.nan
L410         df["simulated_ratio"] = np.nan
L411         df["simulated_drift_abs"] = np.nan
L412         simulated_total_drift_abs = np.nan
L413     return df, alert, new_total_value, simulated_total_drift_abs
L414
L415
L416 def prepare_summary(df, total_drift_abs, alert):
L417     summary = {
L418         "symbol": "合計",
L419         "shares": df["shares"].sum(),
L420         "value": df["value"].sum(),
L421         "current_ratio": np.nan,
L422         "drift_abs": total_drift_abs,
L423     }
L424     if alert:
L425         summary["trade_shares"] = np.nan
L426     # Sort details by evaluation value descending before appending summary
L427     df = df.sort_values(by="value", ascending=False)
L428     df = pd.concat([df, pd.DataFrame([summary])], ignore_index=True)
L429     if alert:
L430         cols = ["symbol", "shares", "value", "current_ratio", "drift_abs", "trade_shares"]
L431         df_small = df[cols].copy()
L432         df_small.columns = ["sym", "qty", "val", "now", "|d|", "Δqty"]
L433     else:
L434         cols = ["symbol", "shares", "value", "current_ratio", "drift_abs"]
L435         df_small = df[cols].copy()
L436         df_small.columns = ["sym", "qty", "val", "now", "|d|"]
L437     return df_small
L438
L439
L440 def currency(x):
L441     return f"${x:,.0f}" if pd.notnull(x) else ""
L442
L443
L444 def formatters_for(alert):
L445     formatters = {"val": currency, "now": "{:.2%}".format, "|d|": "{:.2%}".format}
L446     if alert:
L447         formatters["Δqty"] = "{:.0f}".format
L448     return formatters
L449
L450
L451 def build_header(mode, cash_ratio, drift_threshold, total_drift_abs, alert, simulated_total_drift_abs):
L452     header = (
L453         f"*💼 現金保有率:* {cash_ratio*100:.1f}%\n"
L454         f"*📊 ドリフト閾値:* {'🔴(停止)' if drift_threshold == float('inf') else str(drift_threshold)+'%'}\n"
L455         f"*📉 現在のドリフト合計:* {total_drift_abs * 100:.2f}%\n"
L456     )
L457     if alert:
L458         header += f"*🔁 半戻し後ドリフト合計(想定):* {simulated_total_drift_abs * 100:.2f}%\n"
L459         header += "🚨 *アラート: 発生！！ Δqtyのマイナス銘柄を売却、任意の銘柄を買い増してバランスを取りましょう！*\n"
L460     else:
L461         header += "✅ アラートなし\n"
L462     # ★ 追記: TSルール（G/D共通）と推奨保有数
L463     # TS(基本)をモードで動的表示。段階TSは「基本から -3/-6/-8 pt」固定。
L464     base_ts = config.TS_BASE_BY_MODE.get(mode.upper(), config.TS_BASE_BY_MODE["NORMAL"])
L465     d1, d2, d3 = config.TS_STEP_DELTAS_PT
L466     ts_line = f"*🛡 TS:* 基本 -{base_ts*100:.0f}% / +30%→-{max(base_ts*100 - d1, 0):.0f}% / +60%→-{max(base_ts*100 - d2, 0):.0f}% / +100%→-{max(base_ts*100 - d3, 0):.0f}%\n"
L467     header += ts_line
L468     g_cnt, d_cnt, cash_slots = recommended_counts_by_mode(mode)
L469     cash_pct = cash_slots * (100 / (config.TOTAL_TARGETS))  # 1枠=総数分割の%（20銘柄なら5%）
L470     header += f"*📋 推奨保有数:* G {g_cnt} / D {d_cnt}（現金化枠 {cash_slots}枠 ≒ {cash_pct:.0f}%）\n"
L471     return header
L472
L473
L474 def send_slack(text):
L475     SLACK_WEBHOOK_URL = os.environ.get("SLACK_WEBHOOK_URL")
L476     if not SLACK_WEBHOOK_URL:
L477         raise ValueError("SLACK_WEBHOOK_URL not set (環境変数が未設定です)")
L478     payload = {"text": text}
L479     try:
L480         resp = requests.post(SLACK_WEBHOOK_URL, json=payload)
L481         resp.raise_for_status()
L482         print("✅ Slack（Webhook）へ送信しました")
L483     except Exception as e:
L484         print(f"⚠️ Slack通知エラー: {e}")
L485
L486
L487 def send_debug(debug_text):
L488     SLACK_WEBHOOK_URL = os.environ.get("SLACK_WEBHOOK_URL")
L489     if not SLACK_WEBHOOK_URL:
L490         raise ValueError("SLACK_WEBHOOK_URL not set (環境変数が未設定です)")
L491     debug_payload = {"text": "```" + debug_text + "```"}
L492     try:
L493         resp = requests.post(SLACK_WEBHOOK_URL, json=debug_payload)
L494         resp.raise_for_status()
L495         print("✅ Debug情報をSlackに送信しました")
L496     except Exception as e:
L497         print(f"⚠️ Slack通知エラー: {e}")
L498
L499
L500 def main():
L501     portfolio = load_portfolio()
L502     symbols = [r["symbol"] for r in portfolio]
L503     sell_alerts = scan_sell_signals(symbols, lookback_days=5)
L504
L505     breadth_block, mode, _C = build_breadth_header()
L506
L507     cash_ratio, drift_threshold = compute_threshold_by_mode(mode)
L508
L509     df, total_value, total_drift_abs = build_dataframe(portfolio)
L510     df, alert, new_total_value, simulated_total_drift_abs = simulate(
L511         df, total_value, total_drift_abs, drift_threshold
L512     )
L513     df_small = prepare_summary(df, total_drift_abs, alert)
L514     if 'df_small' in locals() and isinstance(df_small, pd.DataFrame) and not df_small.empty:
L515         col_sym = "sym" if "sym" in df_small.columns else ("symbol" if "symbol" in df_small.columns else None)
L516         if col_sym:
L517             alert_keys = {str(k) for k in sell_alerts.keys()}
L518             df_small[col_sym] = df_small[col_sym].astype(str)
L519             df_small.insert(0, "⚠", df_small[col_sym].map(lambda x: "🔴" if x in alert_keys else ""))
L520             latest_tag = {s: " / ".join(sell_alerts[s][-1][1]) for s in sell_alerts}
L521             df_small.insert(1, "sig", df_small[col_sym].map(latest_tag).fillna(""))
L522     formatters = formatters_for(alert)
L523     header = build_header(
L524         mode, cash_ratio, drift_threshold, total_drift_abs, alert, simulated_total_drift_abs
L525     )
L526     if breadth_block:
L527         header = breadth_block + "\n" + header
L528     if sell_alerts:
L529         def fmt_pair(date_tags):
L530             date, tags = date_tags
L531             return f"{date}:" + "・".join(tags)
L532         listed = []
L533         for t, arr in sell_alerts.items():
L534             listed.append(f"*{t}*（" + ", ".join(fmt_pair(x) for x in arr) + "）")
L535         hits = ", ".join(listed)
L536         if "✅ アラートなし" in header:
L537             header = header.replace(
L538                 "✅ アラートなし",
L539                 f"⚠️ 売りシグナルあり: {len(sell_alerts)}銘柄\n🟥 {hits}",
L540             )
L541         else:
L542             header += f"\n🟥 {hits}"
L543     table_text = df_small.to_string(formatters=formatters, index=False)
L544     send_slack(header + "\n```" + table_text + "```")
L545
L546     if debug_mode:
L547         debug_cols = [
L548             "symbol",
L549             "shares",
L550             "price",
L551             "value",
L552             "current_ratio",
L553             "drift",
L554             "drift_abs",
L555             "adjusted_ratio",
L556             "adjustable",
L557             "trade_shares",
L558             "new_shares",
L559             "new_value",
L560             "simulated_ratio",
L561             "simulated_drift_abs",
L562         ]
L563         debug_text = (
L564             "=== DEBUG: full dataframe ===\n"
L565             + df[debug_cols].to_string()
L566             + f"\n\ntotal_value={total_value}, new_total_value={new_total_value}\n"
L567             + f"total_drift_abs={total_drift_abs}, simulated_total_drift_abs={simulated_total_drift_abs}"
L568         )
L569         print("\n" + debug_text)
L570         send_debug(debug_text)
L571
L572
L573 if __name__ == "__main__":
L574     main()
L575
```

## <.github/workflows/daily-report.yml>
```text
L1 name: Daily Stock Report
L2
L3 on:
L4   push:
L5     branches: [ main ]
L6     paths-ignore:
L7       - 'CodeForChat/**'
L8   schedule:
L9     - cron: '30 23 * * 2-6'  # UTC 23:30 → JST 08:30（火〜土）
L10   workflow_dispatch:
L11
L12 jobs:
L13   build-and-report:
L14     runs-on: ubuntu-latest
L15
L16     steps:
L17       - name: Debug start
L18         run: echo '🚀 DEBUGstarted'
L19               
L20       - name: Checkout repository
L21         uses: actions/checkout@v3
L22
L23       - name: Setup Python
L24         uses: actions/setup-python@v4
L25         with:
L26           python-version: '3.x'
L27
L28       - name: Install dependencies
L29         run: pip install -r requirements.txt
L30
L31       - name: Prepare results directory
L32         run: mkdir -p results
L33
L34       - name: Run drift.py
L35         env:
L36           SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
L37           FINNHUB_API_KEY: ${{ secrets.FINNHUB_API_KEY }}
L38         run: python drift.py
L39
L40       - name: Persist breadth_state.json
L41         if: always()
L42         run: |
L43           git config user.name  "github-actions[bot]"
L44           git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
L45           git add results/breadth_state.json || true
L46           git commit -m "chore: update breadth_state [skip ci]" || echo "no changes"
L47           git push || true
```

## <documents/README.md>
```text
L1 # 運用ルール
L2
L3 ## 基本構成
L4 - 20銘柄を均等配分（現金を除き1銘柄あたり5%）
L5 - moomoo証券で運用
L6 - **Growth枠 12銘柄 / Defense枠 8銘柄**（NORMAL 基準）
L7
L8 ## Barbell Growth-Defense方針
L9 - Growth枠 **12銘柄**：高成長で乖離源となる攻めの銘柄
L10 - Defense枠 **8銘柄**：低ボラで安定成長し配当を増やす守りの銘柄
L11 - 「猛烈に伸びる攻め × 着実に稼ぐ盾」の組合せで乖離→半戻しプレミアムを狙う
L12
L13 ## レジーム判定（trend_template 合格“本数”で判定）
L14 - 合格本数 = current+candidate 全体のうち、trend_template 条件を満たした銘柄の**本数(C)**（基準 N_G=12）
L15 - しきい値は過去~600営業日の分布から**毎回自動採用**（分位点と運用“床”のmax）
L16   - 緊急入り: `max(q05, 12本)`（= N_G）
L17   - 緊急解除: `max(q20, 18本)`（= ceil(1.5×12)）
L18   - 通常復帰: `max(q60, 36本)`（= 3×N_G）
L19 - ヒステリシス: 前回モードに依存（EMERG→解除は23本以上、CAUTION→通常は45本以上）
L20
L21 ## レジーム別の現金・ドリフト
L22  - **通常(NORMAL)** : 現金 **10%** / ドリフト閾値 **12%**
L23  - **警戒(CAUTION)** : 現金 **12.5%** / ドリフト閾値 **14%**
L24  - **緊急(EMERG)** : 現金 **20%** / **ドリフト売買停止**（20×5%に全戻しのみ）
L25
L26 ## モード別の推奨“保有銘柄数”（MMF≒現金）
L27 *各枠=5%（20銘柄均等）。モード移行時は**Gの枠数のみ**調整し、外した枠は現金として保持。*
L28
L29 - **NORMAL:** G **12** / D **8** / 現金化枠 **0**  
L30 - **CAUTION:** G **10** / D **8** / 現金化枠 **2**（= 10%）  
L31 - **EMERG:** G **8**  / D **8** / 現金化枠 **4**（= 20%）  
L32
L33 > 実運用：⭐️低スコアのGから順に外す。解除時はfactor上位から補充。
L34
L35 ## トレーリングストップ
L36 - **基本TS (モード別):** NORMAL **15%** / CAUTION **13%** / EMERG **10%**
L37 - 含み益が **+30% / +60% / +100%** 到達で、基本から **-3pt / -6pt / -8pt** 引き上げ
L38 - TS発動で減少した銘柄は翌日以降に補充（※緊急モード中は補充しない）
L39
L40 ## 半戻し（リバランス）手順
L41 ドリフトチェックで**アラート**が出た場合（合計|drift| がモード閾値を超過、EMERG除く）、翌営業日の米国寄付きで下記を実施する。
L42
L43 1. **売却（必須）**  
L44    Slackテーブルの **Δqty がマイナスの銘柄を売却** する（寄付き成行推奨）。  
L45    これは「半戻し」計算に基づく過重量の削減を意味する。
L46
L47 2. **購入（任意・半戻し目安）**  
L48    半戻し後の合計|drift|を**シミュレーション値（Slackヘッダに表示）**に近づけることを目安に、  
L49    **任意の銘柄を買い増し**してバランスを取る（Δqtyがプラスの銘柄を優先してもよい）。
L50
L51 3. **トレーリングストップの再設定（必須）**  
L52    すべての保有銘柄について、最新の評価額に合わせてTSを**再発注／更新**する。  
L53    ルールは下記（利益到達で段階的にタイト化）：  
L54    - **基本TS:** -15%  
L55    - **+30% 到達 → TS -12%**  
L56    - **+60% 到達 → TS -9%**  
L57    - **+100% 到達 → TS -7%**  
L58    ※ストップ価格の引き上げは許可、**引き下げは不可**（利益保全の原則）。
L59
L60 4. **例外（EMERGモード）**  
L61    緊急(EMERG)では**ドリフト由来の売買は停止（∞）**。20銘柄×各5%への**全戻し**のみ許容。
L62
L63 5. **実行タイミング**
L64    - 判定：米国市場終値直後
L65    - 執行：翌営業日の米国寄付き成行
L66
L67 ## モード移行の実務手順（超シンプル）
L68 モードが変わったら、**MMF≒現金**として扱い、**Gの枠数だけ**を調整する：
L69 1. **Gを削る**（CAUTION/EMERG）  
L70    - ⭐️低スコアのGから順に外す。  
L71    - **`current_tickers.csv` から外すG銘柄の行を削除**（＝その枠は現金化）。
L72 2. **現金として保持**  
L73    - 外した枠は現金（またはMMF相当）でプール。  
L74 3. **復帰時の補充**（NORMALへ）  
L75    - **`current_tickers.csv` に銘柄を追加**（factor上位から）。  
L76    - 以降は日次ドリフト/TSルールに従う。
L77
L78 > driftは `target_ratio = 1/銘柄数` を自動適用。行数に応じて自動で均等比率が再計算される。
L79
L80 ## 入替銘柄選定
L81 - Oxfordキャピタル／インカム、Alpha Investor、Motley Fool Stock Advisor、moomooスクリーニング等を参考にchatGPTで検討
L82 - 年間NISA枠はGrowth群の中から低ボラ銘柄を選定し利用。長期保持にはこだわらない。
L83
L84 ## 再エントリー（クールダウン）
L85 - TSヒット後の同銘柄再INは **8営業日** のクールダウンを設ける（期間中は再IN禁止）
L86
L87 ## 実行タイミング
L88 - 判定：米国市場終値直後
L89 - 執行：翌営業日の米国寄付き成行
```

## <documents/drift_design.md>
```text
L1 # drift.py 詳細設計書
L2
L3 ## 概要
L4 - 20銘柄ポートフォリオのドリフトを日次監視し、閾値超過時に半戻し案をSlack通知するスクリプト。
L5 - Finnhubとyfinanceから価格を取得（レジームは trend_template 本数に基づく（基準 N_G=12））。
L6   - 緊急入り: `max(q05, 12本)`
L7   - 緊急解除: `max(q20, 18本)` （ceil(1.5*12)）
L8   - 通常復帰: `max(q60, 36本)` （3*12）
L9
L10 ## 定数・設定
L11 - `FINNHUB_API_KEY` / `SLACK_WEBHOOK_URL` を環境変数から取得。
L12 - 無料枠を考慮したAPIレート制限: `RATE_LIMIT = 55`。
L13 - デバッグ出力用フラグ `debug_mode`。
L14
L15 ## 主な関数
L16 ### finnhub_get
L17 - 基本的なレート制限付きでFinnhub APIを呼び出し、JSONレスポンスを辞書で返す。
L18
L19 ### fetch_price
L20 - `quote` エンドポイントで株価を取得し、失敗時は `NaN` を返す。
L21
L22 ### fetch_vix_ma5
L23 - yfinanceでVIX終値を取得する関数。将来再利用のため残置。
L24
L25 ### load_portfolio
L26 - `current_tickers.csv` から銘柄と保有株数を読み込み、目標比率4%を付与したリストを生成。
L27
L28 ### compute_threshold_by_mode
L29 - モード(NORMAL/CAUTION/EMERG) に応じて **12% / 14% / 停止(∞)** を返す（`config.py` を参照）。
L30
L31 ### build_dataframe
L32 - 各銘柄の評価額や現在比率、ドリフト、半戻し後比率(`adjusted_ratio`)を計算しDataFrame化。
L33
L34 ### simulate
L35 - ドリフト合計が閾値を超えた場合、半戻し後の売買株数と新比率を試算し、シミュレート後ドリフトを返す。
L36
L37 ### prepare_summary
L38 - 評価額順に並べ替えた後、合計行を付与してSlack表示用テーブルを作成。
L39
L40 ### formatters_for / currency
L41 - 通貨・比率・株数の表示フォーマットを定義。
L42
L43 ### build_header
L44 - 現金保有率・閾値・ドリフト値およびアラート有無をSlackメッセージ用ヘッダに整形。TS(基本)はモード別に `config.py` から動的表示し、段階TSは base から -3/-6/-8 pt。
L45
L46 ### send_slack / send_debug
L47 - 通常通知およびデバッグ詳細をSlack Webhookへ送信。
L48
L49 ### main
L50 - 上記関数を順に呼び出し、日次ドリフトチェックの一連処理を実行。
L51
L52 ## 実行フロー
L53 1. `load_portfolio` で現ポートフォリオを読み込む。
L54 2. `build_breadth_header` でモードを取得し、`compute_threshold_by_mode` で現金保有率とドリフト閾値を決定。
L55 3. `build_dataframe` で現在比率とドリフトを計算。
L56 4. `simulate` で閾値超過時の半戻し案を試算。
L57 5. `prepare_summary` と `build_header` で通知本文とテーブルを構築。
L58 6. `send_slack` で結果を送信。`debug_mode` がTrueなら `send_debug` も併用。
```
