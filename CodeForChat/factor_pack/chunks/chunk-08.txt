```text
55         v0, v1 = s.iloc[-1], s.iloc[-2]
L256         pair = _valid_ratio(v0, v1)
L257         if pair is None:
L258             return None
L259         a, b = pair
L260         return float(a / b - 1.0)
L261
L262     def ttm_delta(series: pd.Series) -> float | None:
L263         s = _ensure_series(series)
L264         if s.size < 2:
L265             return None
L266         s = s.sort_index()
L267         k = int(min(4, s.size))
L268         cur_slice = s.iloc[-k:]
L269         prev_slice = s.iloc[:-k]
L270         if prev_slice.empty:
L271             return None
L272         prev_k = int(min(k, prev_slice.size))
L273         cur_sum = float(cur_slice.sum())
L274         prev_sum = float(prev_slice.iloc[-prev_k:].sum())
L275         pair = _valid_ratio(cur_sum, prev_sum)
L276         if pair is None:
L277             return None
L278         a, b = pair
L279         return float(a / b - 1.0)
L280
L281     def yoy_y(series: pd.Series) -> float | None:
L282         s = _ensure_series(series)
L283         if s.size < 2:
L284             return None
L285         s = s.sort_index()
L286         v0, v1 = s.iloc[-1], s.iloc[-2]
L287         pair = _valid_ratio(v0, v1)
L288         if pair is None:
L289             return None
L290         a, b = pair
L291         return float(a / b - 1.0)
L292
L293     def price_proxy_growth() -> float | None:
L294         if not isinstance(close_series, pd.Series):
L295             return None
L296         close = close_series.sort_index().dropna()
L297         if close.empty:
L298             return None
L299         hh_window = int(min(126, len(close)))
L300         if hh_window < 20:
L301             return None
L302         hh = close.rolling(hh_window).max().iloc[-1]
L303         prox = None
L304         if np.isfinite(hh) and hh > 0:
L305             prox = float(close.iloc[-1] / hh)
L306         rs6 = None
L307         if len(close) >= 63:
L308             rs6 = float(close.pct_change(63).iloc[-1])
L309         rs12 = None
L310         if len(close) >= 126:
L311             rs12 = float(close.pct_change(126).iloc[-1])
L312         vexp = None
L313         if isinstance(volume_series, pd.Series):
L314             vol = volume_series.reindex(close.index).dropna()
L315             if len(vol) >= 50:
L316                 v20 = vol.rolling(20).mean().iloc[-1]
L317                 v50 = vol.rolling(50).mean().iloc[-1]
L318                 if np.isfinite(v20) and np.isfinite(v50) and v50 > 0:
L319                     vexp = float(v20 / v50 - 1.0)
L320         prox = 0.0 if prox is None or not np.isfinite(prox) else prox
L321         rs6 = 0.0 if rs6 is None or not np.isfinite(rs6) else rs6
L322         rs12 = 0.0 if rs12 is None or not np.isfinite(rs12) else rs12
L323         vexp = 0.0 if vexp is None or not np.isfinite(vexp) else vexp
L324         return 0.5 * prox + 0.3 * rs6 + 0.2 * rs12 + 0.2 * vexp
L325
L326     price_alt = price_proxy_growth() or 0.0
L327     core = 0.0
L328     core_raw = 0.0
L329     price_raw = price_alt
L330
L331     if nQ >= 5:
L332         path = "P5"
L333         yq = yoy_q(s_rev_q)
L334         parts["rev_yoy_q"] = yq
L335         tmp_prev = s_rev_q.iloc[:-1] if s_rev_q.size > 1 else s_rev_q
L336         acc = None
L337         if tmp_prev.size >= 5 and yq is not None:
L338             yq_prev = yoy_q(tmp_prev)
L339             if yq_prev is not None:
L340                 acc = float(yq - yq_prev)
L341         parts["rev_acc_q"] = acc
L342         eps_yoy = yoy_q(s_eps_q) if s_eps_q.size >= 5 else None
L343         parts["eps_yoy_q"] = eps_yoy
L344         eps_acc = None
L345         if eps_yoy is not None and s_eps_q.size > 5:
L346             eps_prev = s_eps_q.iloc[:-1]
L347             if eps_prev.size >= 5:
L348                 eps_prev_yoy = yoy_q(eps_prev)
L349                 if eps_prev_yoy is not None:
L350                     eps_acc = float(eps_yoy - eps_prev_yoy)
L351         parts["eps_acc_q"] = eps_acc
L352         w = 1.0
L353         core_raw = (
L354             0.60 * _nz(yq)
L355             + 0.20 * _nz(acc)
L356             + 0.15 * _nz(eps_yoy)
L357             + 0.05 * _nz(eps_acc)
L358         )
L359         price_alt = 0.0
L360     elif 2 <= nQ <= 4:
L361         path = "P24"
L362         rev_qoq = qoq(s_rev_q)
L363         rev_ttm2 = ttm_delta(s_rev_q)
L364         parts["rev_qoq"] = rev_qoq
L365         parts["rev_ttm2"] = rev_ttm2
L366         eps_qoq = qoq(s_eps_q) if s_eps_q.size >= 2 else None
L367         parts["eps_qoq"] = eps_qoq
L368         w = min(1.0, nQ / 5.0)
L369         core_raw = 0.6 * _nz(rev_qoq) + 0.3 * _nz(rev_ttm2) + 0.1 * _nz(eps_qoq)
L370     else:
L371         path = "P1Y"
L372         rev_yoy_y = yoy_y(s_rev_y) if nY >= 2 else None
L373         parts["rev_yoy_y"] = rev_yoy_y
L374         w = 0.6 * min(1.0, nY / 3.0) if nY >= 2 else 0.4
L375         core_raw = _nz(rev_yoy_y)
L376         if nQ <= 1 and nY < 2 and price_alt == 0.0:
L377             price_alt = price_proxy_growth() or 0.0
L378
L379     core = _winsor(core_raw, lo=-1.5, hi=1.5)
L380     price_alt = _winsor(price_alt, lo=-1.5, hi=1.5)
L381     grw = _winsor(w * core + (1.0 - w) * (0.5 * _nz(price_alt)), lo=-2.0, hi=2.0)
L382
L383     parts.update(
L384         {
L385             "core_raw": core_raw,
L386             "core": core,
L387             "price_proxy_raw": price_raw,
L388             "price_proxy": price_alt,
L389             "weight": w,
L390             "score": grw,
L391         }
L392     )
L393
L394     parts_out: dict[str, Any] = {
L395         "nQ": nQ,
L396         "nY": nY,
L397     }
L398     for key, value in parts.items():
L399         if key in ("nQ", "nY"):
L400             continue
L401         rounded = _round_debug(value)
L402         parts_out[key] = rounded
L403
L404     parts_out["path"] = path
L405     parts_out["w"] = _round_debug(w)
L406
L407     info_entry["DEBUG_GRW_PATH"] = path
L408     info_entry["DEBUG_GRW_PARTS"] = json.dumps(parts_out, ensure_ascii=False, sort_keys=True)
L409     info_entry["DEBUG_GRW_PARTS_DICT"] = dict(parts_out)
L410     info_entry["GRW_SCORE"] = grw
L411     info_entry["GRW_WEIGHT"] = w
L412     info_entry["GRW_CORE"] = core
L413     info_entry["GRW_PRICE_PROXY"] = price_alt
L414
L415     return {
L416         "score": grw,
L417         "path": path,
L418         "parts": info_entry["DEBUG_GRW_PARTS"],
L419         "parts_dict": dict(parts_out),
L420         "weight": w,
L421         "core": core,
L422         "price_proxy": price_alt,
L423     }
L424
L425
L426 D_WEIGHTS_EFF = None  # 出力表示互換のため
L427
L428
L429 def _scalar(v):
L430     """単一セル代入用に値をスカラーへ正規化する。
L431
L432     - pandas Series -> .iloc[-1]（最後を採用）
L433     - list/tuple/ndarray -> 最後の要素
L434     - それ以外          -> そのまま
L435     取得失敗時は np.nan を返す。
L436     """
L437     import numpy as _np
L438     import pandas as _pd
L439     try:
L440         if isinstance(v, _pd.Series):
L441             return v.iloc[-1] if len(v) else _np.nan
L442         if isinstance(v, (list, tuple, _np.ndarray)):
L443             return v[-1] if len(v) else _np.nan
L444         return v
L445     except Exception:
L446         return _np.nan
L447
L448
L449 # ---- Scorer 本体 -------------------------------------------------------------
L450 class Scorer:
L451     """
L452     - factor.py からは `aggregate_scores(ib, cfg)` を呼ぶだけでOK。
L453     - cfg は必須（factor.PipelineConfig を渡す）。
L454     - 旧カラム名を自動リネームして新スキーマに吸収します。
L455     """
L456
L457     # === 先頭で旧→新カラム名マップ（移行用） ===
L458     EPS_RENAME = {"eps_ttm":"EPS_TTM", "eps_q_recent":"EPS_Q_LastQ"}
L459     FCF_RENAME = {"fcf_ttm":"FCF_TTM"}
L460
L461     # === スキーマ簡易チェック（最低限） ===
L462     @staticmethod
L463     def _validate_ib_for_scorer(ib: Any):
L464         miss = [a for a in ["tickers","bench","data","px","spx","tickers_bulk","info","eps_df","fcf_df","returns"] if not hasattr(ib,a) or getattr(ib,a) is None]
L465         if miss: raise ValueError(f"InputBundle is missing required attributes for Scorer: {miss}")
L466         if any(c in ib.eps_df.columns for c in Scorer.EPS_RENAME): ib.eps_df.rename(columns=Scorer.EPS_RENAME, inplace=True)
L467         if any(c in ib.fcf_df.columns for c in Scorer.FCF_RENAME): ib.fcf_df.rename(columns=Scorer.FCF_RENAME, inplace=True)
L468         need_eps, need_fcf = {"EPS_TTM","EPS_Q_LastQ"},{"FCF_TTM"}
L469         if not need_eps.issubset(ib.eps_df.columns): raise ValueError(f"eps_df must contain columns {need_eps} (accepts old names via auto-rename). Got: {list(ib.eps_df.columns)}")
L470         if not need_fcf.issubset(ib.fcf_df.columns): raise ValueError(f"fcf_df must contain columns {need_fcf} (accepts old names via auto-rename). Got: {list(ib.fcf_df.columns)}")
L471
L472     # ----（Scorer専用）テクニカル・指標系 ----
L473     @staticmethod
L474     def trend(s: pd.Series):
L475         if len(s)<200: return np.nan
L476         sma50, sma150, sma200 = s.rolling(50).mean().iloc[-1], s.rolling(150).mean().iloc[-1], s.rolling(200).mean().iloc[-1]
L477         prev200, p = s.rolling(200).mean().iloc[-21], s.iloc[-1]
L478         lo_52 = s[-252:].min() if len(s)>=252 else s.min(); hi_52 = s[-252:].max() if len(s)>=252 else s.max()
L479         rng = (hi_52 - lo_52) if hi_52>lo_52 else np.nan
L480         clip = lambda x,lo,hi: (np.nan if pd.isna(x) else max(lo,min(hi,x)))
L481         a = clip(p/(s.rolling(50).mean().iloc[-1]) - 1, -0.5, 0.5)
L482         b = clip(sma50/sma150 - 1, -0.5, 0.5)
L483         c = clip(sma150/sma200 - 1, -0.5, 0.5)
L484         d = clip(sma200/prev200 - 1, -0.2, 0.2)
L485         e = clip((p - lo_52) / (rng if rng and rng>0 else np.nan) - 0.5, -0.5, 0.5)
L486         parts = [0.0 if pd.isna(x) else x for x in (a,b,c,d,e)]
L487         return 0.30*parts[0] + 0.20*parts[1] + 0.15*parts[2] + 0.15*parts[3] + 0.20*parts[4]
L488
L489     @staticmethod
L490     def rs(s, b):
L491         n, nb = len(s), len(b)
L492         if n<60 or nb<60: return np.nan
L493         L12 = 252 if n>=252 and nb>=252 else min(n,nb)-1; L1 = 22 if n>=22 and nb>=22 else max(5, min(n,nb)//3)
L494         r12, r1, br12, br1 = s.iloc[-1]/s.iloc[-L12]-1, s.iloc[-1]/s.iloc[-L1]-1, b.iloc[-1]/b.iloc[-L12]-1, b.iloc[-1]/b.iloc[-L1]-1
L495         return (r12 - br12)*0.7 + (r1 - br1)*0.3
L496
L497     @staticmethod
L498     def tr_str(s):
L499         if s is None:
L500             return np.nan
L501         s = s.ffill(limit=2).dropna()
L502         if len(s) < 50:
L503             return np.nan
L504         ma50 = s.rolling(50, min_periods=50).mean()
L505         last_ma = ma50.iloc[-1]
L506         last_px = s.iloc[-1]
L507         return float(last_px/last_ma - 1.0) if pd.notna(last_ma) and pd.notna(last_px) else np.nan
L508
L509     @staticmethod
L510     def rs_line_slope(s: pd.Series, b: pd.Series, win: int) -> float:
L511         r = (s/b).dropna()
L512         if len(r) < win: return np.nan
L513         y, x = np.log(r.iloc[-win:]), np.arange(win, dtype=float)
L514         try: return float(np.polyfit(x, y, 1)[0])
L515         except Exception: return np.nan
L516
L517     @staticmethod
L518     def ev_fallback(info_t: dict, tk: yf.Ticker) -> float:
L519         ev = info_t.get('enterpriseValue', np.nan)
L520         if pd.notna(ev) and ev>0: return float(ev)
L521         mc, debt, cash = info_t.get('marketCap', np.nan), np.nan, np.nan
L522         try:
L523             bs = tk.quarterly_balance_sheet
L524             if bs is not None and not bs.empty:
L525                 c = bs.columns[0]
L526                 for k in ("Total Debt","Long Term Debt","Short Long Term Debt"):
L527                     if k in bs.index: debt = float(bs.loc[k,c]); break
L528                 for k in ("Cash And Cash Equivalents","Cash And Cash Equivalents And Short Term Investments","Cash"):
L529                     if k in bs.index: cash = float(bs.loc[k,c]); break
L530         except Exception: pass
L531         if pd.notna(mc): return float(mc + (0 if pd.isna(debt) else debt) - (0 if pd.isna(cash) else cash))
L532         return np.nan
L533
L534     
```