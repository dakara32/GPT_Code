```text
(x, pd.Series):
L386         return x.dropna()
L387     if isinstance(x, (list, tuple)):
L388         if len(x) and isinstance(x[0], (tuple, list)) and len(x[0]) == 2:
L389             dt = pd.to_datetime([d for d, _ in x], errors="coerce")
L390             v = pd.to_numeric([_v for _, _v in x], errors="coerce")
L391             return pd.Series(v, index=dt).dropna()
L392         return pd.Series(pd.to_numeric(list(x), errors="coerce")).dropna()
L393     try:
L394         return pd.Series(x).dropna()
L395     except Exception:
L396         return pd.Series(dtype=float)
L397
L398
L399 def _to_quarterly(s: pd.Series) -> pd.Series:
L400     if s.empty or not isinstance(s.index, pd.DatetimeIndex):
L401         return s
L402     return s.resample("Q").last().dropna()
L403
L404
L405 def _ttm_yoy_from_quarterly(qs: pd.Series) -> pd.Series:
L406     if qs is None or qs.empty:
L407         return pd.Series(dtype=float)
L408     ttm = qs.rolling(4, min_periods=2).sum()
L409     yoy = ttm.pct_change(4)
L410     return yoy
L411
L412
L413 def _nz(x) -> float:
L414     if x is None:
L415         return 0.0
L416     try:
L417         value = float(x)
L418     except Exception:
L419         return 0.0
L420     if not np.isfinite(value):
L421         return 0.0
L422     return value
L423
L424
L425 def _winsor(x, lo=-2.0, hi=2.0) -> float:
L426     v = _nz(x)
L427     if v < lo:
L428         return float(lo)
L429     if v > hi:
L430         return float(hi)
L431     return float(v)
L432
L433
L434 def _round_debug(x, ndigits: int = 4):
L435     try:
L436         value = float(x)
L437     except Exception:
L438         return None
L439     if not np.isfinite(value):
L440         return None
L441     return round(value, ndigits)
L442
L443
L444 def _calc_grw_flexible(
L445     ticker: str,
L446     info_entry: dict | None,
L447     close_series: pd.Series | None,
L448     volume_series: pd.Series | None,
L449 ):
L450     info_entry = info_entry if isinstance(info_entry, dict) else {}
L451
L452     s_rev_q = _ensure_series(info_entry.get("SEC_REV_Q_SERIES"))
L453     s_eps_q = _ensure_series(info_entry.get("SEC_EPS_Q_SERIES"))
L454     s_rev_y = _ensure_series(info_entry.get("SEC_REV_Y_SERIES"))
L455
L456     nQ = int(getattr(s_rev_q, "size", 0))
L457     nY = int(getattr(s_rev_y, "size", 0))
L458
L459     parts: dict[str, Any] = {"nQ": nQ, "nY": nY}
L460     path = "NONE"
L461     w = 0.0
L462
L463     def _valid_ratio(a, b):
L464         try:
L465             na, nb = float(a), float(b)
L466         except Exception:
L467             return None
L468         if not np.isfinite(na) or not np.isfinite(nb) or nb == 0:
L469             return None
L470         return na, nb
L471
L472     def yoy_q(series: pd.Series) -> float | None:
L473         s = _ensure_series(series)
L474         if s.empty:
L475             return None
L476         s = s.sort_index()
L477         if isinstance(s.index, pd.DatetimeIndex):
L478             last_idx = s.index[-1]
L479             window_start = last_idx - pd.DateOffset(months=15)
L480             window_end = last_idx - pd.DateOffset(months=9)
L481             candidates = s.loc[(s.index >= window_start) & (s.index <= window_end)]
L482             if candidates.empty:
L483                 candidates = s.loc[s.index <= window_end]
L484             if candidates.empty:
L485                 return None
L486             v1 = candidates.iloc[-1]
L487             v0 = s.iloc[-1]
L488         else:
L489             if s.size < 5:
L490                 return None
L491             v0 = s.iloc[-1]
L492             v1 = s.iloc[-5]
L493         pair = _valid_ratio(v0, v1)
L494         if pair is None:
L495             return None
L496         a, b = pair
L497         return float(a / b - 1.0)
L498
L499     def qoq(series: pd.Series) -> float | None:
L500         s = _ensure_series(series)
L501         if s.size < 2:
L502             return None
L503         s = s.sort_index()
L504         v0, v1 = s.iloc[-1], s.iloc[-2]
L505         pair = _valid_ratio(v0, v1)
L506         if pair is None:
L507             return None
L508         a, b = pair
L509         return float(a / b - 1.0)
L510
L511     def ttm_delta(series: pd.Series) -> float | None:
L512         s = _ensure_series(series)
L513         if s.size < 2:
L514             return None
L515         s = s.sort_index()
L516         k = int(min(4, s.size))
L517         cur_slice = s.iloc[-k:]
L518         prev_slice = s.iloc[:-k]
L519         if prev_slice.empty:
L520             return None
L521         prev_k = int(min(k, prev_slice.size))
L522         cur_sum = float(cur_slice.sum())
L523         prev_sum = float(prev_slice.iloc[-prev_k:].sum())
L524         pair = _valid_ratio(cur_sum, prev_sum)
L525         if pair is None:
L526             return None
L527         a, b = pair
L528         return float(a / b - 1.0)
L529
L530     def yoy_y(series: pd.Series) -> float | None:
L531         s = _ensure_series(series)
L532         if s.size < 2:
L533             return None
L534         s = s.sort_index()
L535         v0, v1 = s.iloc[-1], s.iloc[-2]
L536         pair = _valid_ratio(v0, v1)
L537         if pair is None:
L538             return None
L539         a, b = pair
L540         return float(a / b - 1.0)
L541
L542     def price_proxy_growth() -> float | None:
L543         if not isinstance(close_series, pd.Series):
L544             return None
L545         close = close_series.sort_index().dropna()
L546         if close.empty:
L547             return None
L548         hh_window = int(min(126, len(close)))
L549         if hh_window < 20:
L550             return None
L551         hh = close.rolling(hh_window).max().iloc[-1]
L552         prox = None
L553         if np.isfinite(hh) and hh > 0:
L554             prox = float(close.iloc[-1] / hh)
L555         rs6 = None
L556         if len(close) >= 63:
L557             rs6 = float(close.pct_change(63).iloc[-1])
L558         rs12 = None
L559         if len(close) >= 126:
L560             rs12 = float(close.pct_change(126).iloc[-1])
L561         vexp = None
L562         if isinstance(volume_series, pd.Series):
L563             vol = volume_series.reindex(close.index).dropna()
L564             if len(vol) >= 50:
L565                 v20 = vol.rolling(20).mean().iloc[-1]
L566                 v50 = vol.rolling(50).mean().iloc[-1]
L567                 if np.isfinite(v20) and np.isfinite(v50) and v50 > 0:
L568                     vexp = float(v20 / v50 - 1.0)
L569         prox = 0.0 if prox is None or not np.isfinite(prox) else prox
L570         rs6 = 0.0 if rs6 is None or not np.isfinite(rs6) else rs6
L571         rs12 = 0.0 if rs12 is None or not np.isfinite(rs12) else rs12
L572         vexp = 0.0 if vexp is None or not np.isfinite(vexp) else vexp
L573         return 0.5 * prox + 0.3 * rs6 + 0.2 * rs12 + 0.2 * vexp
L574
L575     price_alt = price_proxy_growth() or 0.0
L576     core = 0.0
L577     core_raw = 0.0
L578     price_raw = price_alt
L579
L580     if nQ >= 5:
L581         path = "P5"
L582         yq = yoy_q(s_rev_q)
L583         parts["rev_yoy_q"] = yq
L584         tmp_prev = s_rev_q.iloc[:-1] if s_rev_q.size > 1 else s_rev_q
L585         acc = None
L586         if tmp_prev.size >= 5 and yq is not None:
L587             yq_prev = yoy_q(tmp_prev)
L588             if yq_prev is not None:
L589                 acc = float(yq - yq_prev)
L590         parts["rev_acc_q"] = acc
L591         eps_yoy = yoy_q(s_eps_q) if s_eps_q.size >= 5 else None
L592         parts["eps_yoy_q"] = eps_yoy
L593         eps_acc = None
L594         if eps_yoy is not None and s_eps_q.size > 5:
L595             eps_prev = s_eps_q.iloc[:-1]
L596             if eps_prev.size >= 5:
L597                 eps_prev_yoy = yoy_q(eps_prev)
L598                 if eps_prev_yoy is not None:
L599                     eps_acc = float(eps_yoy - eps_prev_yoy)
L600         parts["eps_acc_q"] = eps_acc
L601         w = 1.0
L602         core_raw = (
L603             0.60 * _nz(yq)
L604             + 0.20 * _nz(acc)
L605             + 0.15 * _nz(eps_yoy)
L606             + 0.05 * _nz(eps_acc)
L607         )
L608         price_alt = 0.0
L609     elif 2 <= nQ <= 4:
L610         path = "P24"
L611         rev_qoq = qoq(s_rev_q)
L612         rev_ttm2 = ttm_delta(s_rev_q)
L613         parts["rev_qoq"] = rev_qoq
L614         parts["rev_ttm2"] = rev_ttm2
L615         eps_qoq = qoq(s_eps_q) if s_eps_q.size >= 2 else None
L616         parts["eps_qoq"] = eps_qoq
L617         w = min(1.0, nQ / 5.0)
L618         core_raw = 0.6 * _nz(rev_qoq) + 0.3 * _nz(rev_ttm2) + 0.1 * _nz(eps_qoq)
L619     else:
L620         path = "P1Y"
L621         rev_yoy_y = yoy_y(s_rev_y) if nY >= 2 else None
L622         parts["rev_yoy_y"] = rev_yoy_y
L623         w = 0.6 * min(1.0, nY / 3.0) if nY >= 2 else 0.4
L624         core_raw = _nz(rev_yoy_y)
L625         if nQ <= 1 and nY < 2 and price_alt == 0.0:
L626             price_alt = price_proxy_growth() or 0.0
L627
L628     core = _winsor(core_raw, lo=-1.5, hi=1.5)
L629     price_alt = _winsor(price_alt, lo=-1.5, hi=1.5)
L630     grw = _winsor(w * core + (1.0 - w) * (0.5 * _nz(price_alt)), lo=-2.0, hi=2.0)
L631
L632     parts.update(
L633         {
L634             "core_raw": core_raw,
L635             "core": core,
L636             "price_proxy_raw": price_raw,
L637             "price_proxy": price_alt,
L638             "weight": w,
L639             "score": grw,
L640         }
L641     )
L642
L643     parts_out: dict[str, Any] = {
L644         "nQ": nQ,
L645         "nY": nY,
L646     }
L647     for key, value in parts.items():
L648         if key in ("nQ", "nY"):
L649             continue
L650         rounded = _round_debug(value)
L651         parts_out[key] = rounded
L652
L653     info_entry["DEBUG_GRW_PATH"] = path
L654     info_entry["DEBUG_GRW_PARTS"] = json.dumps(parts_out, ensure_ascii=False, sort_keys=True)
L655     info_entry["GRW_SCORE"] = grw
L656     info_entry["GRW_WEIGHT"] = w
L657     info_entry["GRW_CORE"] = core
L658     info_entry["GRW_PRICE_PROXY"] = price_alt
L659
L660     return {
L661         "score": grw,
L662         "path": path,
L663         "parts": info_entry["DEBUG_GRW_PARTS"],
L664         "weight": w,
L665         "core": core,
L666         "price_proxy": price_alt,
L667     }
L668
L669
L670 D_WEIGHTS_EFF = None  # 出力表示互換のため
L671
L672
L673 def _scalar(v):
L674     """単一セル代入用に値をスカラーへ正規化する。
L675
L676     - pandas Series -> .iloc[-1]（最後を採用）
L677     - list/tuple/ndarray -> 最後の要素
L678     - それ以外          -> そのまま
L679     取得失敗時は np.nan を返す。
L680     """
L681     import numpy as _np
L682     import pandas as _pd
L683     try:
L684         if isinstance(v, _pd.Series):
L685             return v.iloc[-1] if len(v) else _np.nan
L686         if isinstance(v, (list, tuple, _np.ndarray)):
L687             return v[-1] if len(v) else _np.nan
L688         return v
L689     except Exception:
L690         return _np.nan
L691
L692
L693 # ---- Scorer 本体 -------------------------------------------------------------
L694 class Scorer:
L695     """
L696     - factor.py からは `aggregate_scores(ib, cfg)` を呼ぶだけでOK。
L697     - cfg は必須（factor.PipelineConfig を渡す）。
L698     - 旧カラム名を自動リネームして新スキーマに吸収します。
L699     """
L700
L701     # === 先頭で旧→新カラム名マップ（移行用） ===
L702     EPS_RENAME = {"eps_ttm":"EPS_TTM", "eps_q_recent":"EPS_Q_LastQ"}
L703     FCF_RENAME = {"fcf_ttm":"FCF_TTM"}
L704
L705     # === スキーマ簡易チェック（最低限） ===
L706     @staticmethod
L707     def _validate_ib_for_scorer(ib: Any):
L708         miss = [a for a in ["tickers","bench","data","px","spx","tickers_bulk","info","eps_df","fcf_df","returns"] if not hasattr(ib,a) or getattr(ib,a) is None]
L709         if miss: raise ValueError(f"InputBundle is missing required attributes for Scorer: {miss}")
L710         if any(c in ib.eps_df.columns for c in Scorer.EPS_RENAME): ib.eps_df.rename(columns=Scorer.EPS_RENAME, inplace=True)
L711         if any(c in ib.fcf_df.columns for c in Scorer.FCF_RENAME): ib.fcf_df.rename(columns=Scorer.FCF_RENAME, inplace=True
```