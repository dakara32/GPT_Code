```text
         if s.size < 2:
L255             return None
L256         s = s.sort_index()
L257         v0, v1 = s.iloc[-1], s.iloc[-2]
L258         pair = _valid_ratio(v0, v1)
L259         if pair is None:
L260             return None
L261         a, b = pair
L262         return float(a / b - 1.0)
L263
L264     def price_proxy_growth() -> float | None:
L265         if not isinstance(close_series, pd.Series):
L266             return None
L267         close = close_series.sort_index().dropna()
L268         if close.empty:
L269             return None
L270         hh_window = int(min(126, len(close)))
L271         if hh_window < 20:
L272             return None
L273         hh = close.rolling(hh_window).max().iloc[-1]
L274         prox = None
L275         if np.isfinite(hh) and hh > 0:
L276             prox = float(close.iloc[-1] / hh)
L277         rs6 = None
L278         if len(close) >= 63:
L279             rs6 = float(close.pct_change(63).iloc[-1])
L280         rs12 = None
L281         if len(close) >= 126:
L282             rs12 = float(close.pct_change(126).iloc[-1])
L283         vexp = None
L284         if isinstance(volume_series, pd.Series):
L285             vol = volume_series.reindex(close.index).dropna()
L286             if len(vol) >= 50:
L287                 v20 = vol.rolling(20).mean().iloc[-1]
L288                 v50 = vol.rolling(50).mean().iloc[-1]
L289                 if np.isfinite(v20) and np.isfinite(v50) and v50 > 0:
L290                     vexp = float(v20 / v50 - 1.0)
L291         prox = 0.0 if prox is None or not np.isfinite(prox) else prox
L292         rs6 = 0.0 if rs6 is None or not np.isfinite(rs6) else rs6
L293         rs12 = 0.0 if rs12 is None or not np.isfinite(rs12) else rs12
L294         vexp = 0.0 if vexp is None or not np.isfinite(vexp) else vexp
L295         return 0.5 * prox + 0.3 * rs6 + 0.2 * rs12 + 0.2 * vexp
L296
L297     price_alt = price_proxy_growth() or 0.0
L298     core = 0.0
L299     core_raw = 0.0
L300     price_raw = price_alt
L301
L302     if nQ >= 5:
L303         path = "P5"
L304         yq = yoy_q(s_rev_q)
L305         parts["rev_yoy_q"] = yq
L306         tmp_prev = s_rev_q.iloc[:-1] if s_rev_q.size > 1 else s_rev_q
L307         acc = None
L308         if tmp_prev.size >= 5 and yq is not None:
L309             yq_prev = yoy_q(tmp_prev)
L310             if yq_prev is not None:
L311                 acc = float(yq - yq_prev)
L312         parts["rev_acc_q"] = acc
L313         eps_yoy = yoy_q(s_eps_q) if s_eps_q.size >= 5 else None
L314         parts["eps_yoy_q"] = eps_yoy
L315         eps_acc = None
L316         if eps_yoy is not None and s_eps_q.size > 5:
L317             eps_prev = s_eps_q.iloc[:-1]
L318             if eps_prev.size >= 5:
L319                 eps_prev_yoy = yoy_q(eps_prev)
L320                 if eps_prev_yoy is not None:
L321                     eps_acc = float(eps_yoy - eps_prev_yoy)
L322         parts["eps_acc_q"] = eps_acc
L323         w = 1.0
L324         core_raw = (
L325             0.60 * _nz(yq)
L326             + 0.20 * _nz(acc)
L327             + 0.15 * _nz(eps_yoy)
L328             + 0.05 * _nz(eps_acc)
L329         )
L330         price_alt = 0.0
L331     elif 2 <= nQ <= 4:
L332         path = "P24"
L333         rev_qoq = qoq(s_rev_q)
L334         rev_ttm2 = ttm_delta(s_rev_q)
L335         parts["rev_qoq"] = rev_qoq
L336         parts["rev_ttm2"] = rev_ttm2
L337         eps_qoq = qoq(s_eps_q) if s_eps_q.size >= 2 else None
L338         parts["eps_qoq"] = eps_qoq
L339         w = min(1.0, nQ / 5.0)
L340         core_raw = 0.6 * _nz(rev_qoq) + 0.3 * _nz(rev_ttm2) + 0.1 * _nz(eps_qoq)
L341     else:
L342         path = "P1Y"
L343         rev_yoy_y = yoy_y(s_rev_y) if nY >= 2 else None
L344         parts["rev_yoy_y"] = rev_yoy_y
L345         w = 0.6 * min(1.0, nY / 3.0) if nY >= 2 else 0.4
L346         core_raw = _nz(rev_yoy_y)
L347         if nQ <= 1 and nY < 2 and price_alt == 0.0:
L348             price_alt = price_proxy_growth() or 0.0
L349
L350     core = _winsor(core_raw, lo=-1.5, hi=1.5)
L351     price_alt = _winsor(price_alt, lo=-1.5, hi=1.5)
L352     grw = _winsor(w * core + (1.0 - w) * (0.5 * _nz(price_alt)), lo=-2.0, hi=2.0)
L353
L354     parts.update(
L355         {
L356             "core_raw": core_raw,
L357             "core": core,
L358             "price_proxy_raw": price_raw,
L359             "price_proxy": price_alt,
L360             "weight": w,
L361             "score": grw,
L362         }
L363     )
L364
L365     parts_out: dict[str, Any] = {
L366         "nQ": nQ,
L367         "nY": nY,
L368     }
L369     for key, value in parts.items():
L370         if key in ("nQ", "nY"):
L371             continue
L372         rounded = _round_debug(value)
L373         parts_out[key] = rounded
L374
L375     info_entry["DEBUG_GRW_PATH"] = path
L376     info_entry["DEBUG_GRW_PARTS"] = json.dumps(parts_out, ensure_ascii=False, sort_keys=True)
L377     info_entry["GRW_SCORE"] = grw
L378     info_entry["GRW_WEIGHT"] = w
L379     info_entry["GRW_CORE"] = core
L380     info_entry["GRW_PRICE_PROXY"] = price_alt
L381
L382     return {
L383         "score": grw,
L384         "path": path,
L385         "parts": info_entry["DEBUG_GRW_PARTS"],
L386         "weight": w,
L387         "core": core,
L388         "price_proxy": price_alt,
L389     }
L390
L391
L392 D_WEIGHTS_EFF = None  # 出力表示互換のため
L393
L394
L395 def _scalar(v):
L396     """単一セル代入用に値をスカラーへ正規化する。
L397
L398     - pandas Series -> .iloc[-1]（最後を採用）
L399     - list/tuple/ndarray -> 最後の要素
L400     - それ以外          -> そのまま
L401     取得失敗時は np.nan を返す。
L402     """
L403     import numpy as _np
L404     import pandas as _pd
L405     try:
L406         if isinstance(v, _pd.Series):
L407             return v.iloc[-1] if len(v) else _np.nan
L408         if isinstance(v, (list, tuple, _np.ndarray)):
L409             return v[-1] if len(v) else _np.nan
L410         return v
L411     except Exception:
L412         return _np.nan
L413
L414
L415 # ---- Scorer 本体 -------------------------------------------------------------
L416 class Scorer:
L417     """
L418     - factor.py からは `aggregate_scores(ib, cfg)` を呼ぶだけでOK。
L419     - cfg は必須（factor.PipelineConfig を渡す）。
L420     - 旧カラム名を自動リネームして新スキーマに吸収します。
L421     """
L422
L423     # === 先頭で旧→新カラム名マップ（移行用） ===
L424     EPS_RENAME = {"eps_ttm":"EPS_TTM", "eps_q_recent":"EPS_Q_LastQ"}
L425     FCF_RENAME = {"fcf_ttm":"FCF_TTM"}
L426
L427     # === スキーマ簡易チェック（最低限） ===
L428     @staticmethod
L429     def _validate_ib_for_scorer(ib: Any):
L430         miss = [a for a in ["tickers","bench","data","px","spx","tickers_bulk","info","eps_df","fcf_df","returns"] if not hasattr(ib,a) or getattr(ib,a) is None]
L431         if miss: raise ValueError(f"InputBundle is missing required attributes for Scorer: {miss}")
L432         if any(c in ib.eps_df.columns for c in Scorer.EPS_RENAME): ib.eps_df.rename(columns=Scorer.EPS_RENAME, inplace=True)
L433         if any(c in ib.fcf_df.columns for c in Scorer.FCF_RENAME): ib.fcf_df.rename(columns=Scorer.FCF_RENAME, inplace=True)
L434         need_eps, need_fcf = {"EPS_TTM","EPS_Q_LastQ"},{"FCF_TTM"}
L435         if not need_eps.issubset(ib.eps_df.columns): raise ValueError(f"eps_df must contain columns {need_eps} (accepts old names via auto-rename). Got: {list(ib.eps_df.columns)}")
L436         if not need_fcf.issubset(ib.fcf_df.columns): raise ValueError(f"fcf_df must contain columns {need_fcf} (accepts old names via auto-rename). Got: {list(ib.fcf_df.columns)}")
L437
L438     # ----（Scorer専用）テクニカル・指標系 ----
L439     @staticmethod
L440     def trend(s: pd.Series):
L441         if len(s)<200: return np.nan
L442         sma50, sma150, sma200 = s.rolling(50).mean().iloc[-1], s.rolling(150).mean().iloc[-1], s.rolling(200).mean().iloc[-1]
L443         prev200, p = s.rolling(200).mean().iloc[-21], s.iloc[-1]
L444         lo_52 = s[-252:].min() if len(s)>=252 else s.min(); hi_52 = s[-252:].max() if len(s)>=252 else s.max()
L445         rng = (hi_52 - lo_52) if hi_52>lo_52 else np.nan
L446         clip = lambda x,lo,hi: (np.nan if pd.isna(x) else max(lo,min(hi,x)))
L447         a = clip(p/(s.rolling(50).mean().iloc[-1]) - 1, -0.5, 0.5)
L448         b = clip(sma50/sma150 - 1, -0.5, 0.5)
L449         c = clip(sma150/sma200 - 1, -0.5, 0.5)
L450         d = clip(sma200/prev200 - 1, -0.2, 0.2)
L451         e = clip((p - lo_52) / (rng if rng and rng>0 else np.nan) - 0.5, -0.5, 0.5)
L452         parts = [0.0 if pd.isna(x) else x for x in (a,b,c,d,e)]
L453         return 0.30*parts[0] + 0.20*parts[1] + 0.15*parts[2] + 0.15*parts[3] + 0.20*parts[4]
L454
L455     @staticmethod
L456     def rs(s, b):
L457         n, nb = len(s), len(b)
L458         if n<60 or nb<60: return np.nan
L459         L12 = 252 if n>=252 and nb>=252 else min(n,nb)-1; L1 = 22 if n>=22 and nb>=22 else max(5, min(n,nb)//3)
L460         r12, r1, br12, br1 = s.iloc[-1]/s.iloc[-L12]-1, s.iloc[-1]/s.iloc[-L1]-1, b.iloc[-1]/b.iloc[-L12]-1, b.iloc[-1]/b.iloc[-L1]-1
L461         return (r12 - br12)*0.7 + (r1 - br1)*0.3
L462
L463     @staticmethod
L464     def tr_str(s):
L465         if s is None:
L466             return np.nan
L467         s = s.ffill(limit=2).dropna()
L468         if len(s) < 50:
L469             return np.nan
L470         ma50 = s.rolling(50, min_periods=50).mean()
L471         last_ma = ma50.iloc[-1]
L472         last_px = s.iloc[-1]
L473         return float(last_px/last_ma - 1.0) if pd.notna(last_ma) and pd.notna(last_px) else np.nan
L474
L475     @staticmethod
L476     def rs_line_slope(s: pd.Series, b: pd.Series, win: int) -> float:
L477         r = (s/b).dropna()
L478         if len(r) < win: return np.nan
L479         y, x = np.log(r.iloc[-win:]), np.arange(win, dtype=float)
L480         try: return float(np.polyfit(x, y, 1)[0])
L481         except Exception: return np.nan
L482
L483     @staticmethod
L484     def ev_fallback(info_t: dict, tk: yf.Ticker) -> float:
L485         ev = info_t.get('enterpriseValue', np.nan)
L486         if pd.notna(ev) and ev>0: return float(ev)
L487         mc, debt, cash = info_t.get('marketCap', np.nan), np.nan, np.nan
L488         try:
L489             bs = tk.quarterly_balance_sheet
L490             if bs is not None and not bs.empty:
L491                 c = bs.columns[0]
L492                 for k in ("Total Debt","Long Term Debt","Short Long Term Debt"):
L493                     if k in bs.index: debt = float(bs.loc[k,c]); break
L494                 for k in ("Cash And Cash Equivalents","Cash And Cash Equivalents And Short Term Investments","Cash"):
L495                     if k in bs.index: cash = float(bs.loc[k,c]); break
L496         except Exception: pass
L497         if pd.notna(mc): return float(mc + (0 if pd.isna(debt) else debt) - (0 if pd.isna(cash) else cash))
L498         return np.nan
L499
L500     @staticmethod
L501     def dividend_status(ticker: str) -> str:
L502         t = yf.Ticker(ticker)
L503         try:
L504             if not t.dividends.empty: return "has"
L505         except Exception: return "unknown"
L506         try:
L507             a = t.actions
L508             if (a is not None and not a.empty and "Stock Splits" in a.columns and a["Stock Splits"].abs().sum()>0): return "none_confident"
L509         except Exception: pass
L510         try:
L511             fi = t.fast_info
L512             if any(getattr(fi,k,None) for k in ("last_dividend_date","dividend_rate","dividend_yield")): return "maybe_missing"
L513         except Exception: pass
L514         return "unknown"
L515
L516     @staticmethod
L517     def div_streak(t):
L518         try:
L519             divs = yf.Ticker(t).dividends.dropna(); ann = divs.groupby(divs.index.year).sum(); ann = ann[ann.index<pd.Timestamp.today().year]
L520             years, streak = sorted(ann.index), 0
L521             for i in range(len(years)-1,0,-1):
L522                 if ann[years[i]] > ann[years[i-1]]: streak += 1
L523                 else: break
L524             return streak
L525         except Exception: return 0
```