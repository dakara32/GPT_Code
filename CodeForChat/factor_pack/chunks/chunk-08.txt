```text
         value = float(x)
L177     except Exception:
L178         return 0.0
L179     if not np.isfinite(value):
L180         return 0.0
L181     return value
L182
L183
L184 def _winsor(x, lo=-2.0, hi=2.0) -> float:
L185     v = _nz(x)
L186     if v < lo:
L187         return float(lo)
L188     if v > hi:
L189         return float(hi)
L190     return float(v)
L191
L192
L193 def _round_debug(x, ndigits: int = 4):
L194     try:
L195         value = float(x)
L196     except Exception:
L197         return None
L198     if not np.isfinite(value):
L199         return None
L200     return round(value, ndigits)
L201
L202
L203 def _calc_grw_flexible(
L204     ticker: str,
L205     info_entry: dict | None,
L206     close_series: pd.Series | None,
L207     volume_series: pd.Series | None,
L208 ):
L209     info_entry = info_entry if isinstance(info_entry, dict) else {}
L210
L211     s_rev_q = _ensure_series(info_entry.get("SEC_REV_Q_SERIES"))
L212     s_eps_q = _ensure_series(info_entry.get("SEC_EPS_Q_SERIES"))
L213     s_rev_y = _ensure_series(info_entry.get("SEC_REV_Y_SERIES"))
L214
L215     nQ = int(getattr(s_rev_q, "size", 0))
L216     nY = int(getattr(s_rev_y, "size", 0))
L217
L218     parts: dict[str, Any] = {"nQ": nQ, "nY": nY}
L219     path = "NONE"
L220     w = 0.0
L221
L222     def _valid_ratio(a, b):
L223         try:
L224             na, nb = float(a), float(b)
L225         except Exception:
L226             return None
L227         if not np.isfinite(na) or not np.isfinite(nb) or nb == 0:
L228             return None
L229         return na, nb
L230
L231     def yoy_q(series: pd.Series) -> float | None:
L232         s = _ensure_series(series)
L233         if s.empty:
L234             return None
L235         s = s.sort_index()
L236         if isinstance(s.index, pd.DatetimeIndex):
L237             last_idx = s.index[-1]
L238             window_start = last_idx - pd.DateOffset(months=15)
L239             window_end = last_idx - pd.DateOffset(months=9)
L240             candidates = s.loc[(s.index >= window_start) & (s.index <= window_end)]
L241             if candidates.empty:
L242                 candidates = s.loc[s.index <= window_end]
L243             if candidates.empty:
L244                 return None
L245             v1 = candidates.iloc[-1]
L246             v0 = s.iloc[-1]
L247         else:
L248             if s.size < 5:
L249                 return None
L250             v0 = s.iloc[-1]
L251             v1 = s.iloc[-5]
L252         pair = _valid_ratio(v0, v1)
L253         if pair is None:
L254             return None
L255         a, b = pair
L256         return float(a / b - 1.0)
L257
L258     def qoq(series: pd.Series) -> float | None:
L259         s = _ensure_series(series)
L260         if s.size < 2:
L261             return None
L262         s = s.sort_index()
L263         v0, v1 = s.iloc[-1], s.iloc[-2]
L264         pair = _valid_ratio(v0, v1)
L265         if pair is None:
L266             return None
L267         a, b = pair
L268         return float(a / b - 1.0)
L269
L270     def ttm_delta(series: pd.Series) -> float | None:
L271         s = _ensure_series(series)
L272         if s.size < 2:
L273             return None
L274         s = s.sort_index()
L275         k = int(min(4, s.size))
L276         cur_slice = s.iloc[-k:]
L277         prev_slice = s.iloc[:-k]
L278         if prev_slice.empty:
L279             return None
L280         prev_k = int(min(k, prev_slice.size))
L281         cur_sum = float(cur_slice.sum())
L282         prev_sum = float(prev_slice.iloc[-prev_k:].sum())
L283         pair = _valid_ratio(cur_sum, prev_sum)
L284         if pair is None:
L285             return None
L286         a, b = pair
L287         return float(a / b - 1.0)
L288
L289     def yoy_y(series: pd.Series) -> float | None:
L290         s = _ensure_series(series)
L291         if s.size < 2:
L292             return None
L293         s = s.sort_index()
L294         v0, v1 = s.iloc[-1], s.iloc[-2]
L295         pair = _valid_ratio(v0, v1)
L296         if pair is None:
L297             return None
L298         a, b = pair
L299         return float(a / b - 1.0)
L300
L301     def price_proxy_growth() -> float | None:
L302         if not isinstance(close_series, pd.Series):
L303             return None
L304         close = close_series.sort_index().dropna()
L305         if close.empty:
L306             return None
L307         hh_window = int(min(126, len(close)))
L308         if hh_window < 20:
L309             return None
L310         hh = close.rolling(hh_window).max().iloc[-1]
L311         prox = None
L312         if np.isfinite(hh) and hh > 0:
L313             prox = float(close.iloc[-1] / hh)
L314         rs6 = None
L315         if len(close) >= 63:
L316             rs6 = float(close.pct_change(63).iloc[-1])
L317         rs12 = None
L318         if len(close) >= 126:
L319             rs12 = float(close.pct_change(126).iloc[-1])
L320         vexp = None
L321         if isinstance(volume_series, pd.Series):
L322             vol = volume_series.reindex(close.index).dropna()
L323             if len(vol) >= 50:
L324                 v20 = vol.rolling(20).mean().iloc[-1]
L325                 v50 = vol.rolling(50).mean().iloc[-1]
L326                 if np.isfinite(v20) and np.isfinite(v50) and v50 > 0:
L327                     vexp = float(v20 / v50 - 1.0)
L328         prox = 0.0 if prox is None or not np.isfinite(prox) else prox
L329         rs6 = 0.0 if rs6 is None or not np.isfinite(rs6) else rs6
L330         rs12 = 0.0 if rs12 is None or not np.isfinite(rs12) else rs12
L331         vexp = 0.0 if vexp is None or not np.isfinite(vexp) else vexp
L332         return 0.5 * prox + 0.3 * rs6 + 0.2 * rs12 + 0.2 * vexp
L333
L334     price_alt = price_proxy_growth() or 0.0
L335     core = 0.0
L336     core_raw = 0.0
L337     price_raw = price_alt
L338
L339     if nQ >= 5:
L340         path = "P5"
L341         yq = yoy_q(s_rev_q)
L342         parts["rev_yoy_q"] = yq
L343         tmp_prev = s_rev_q.iloc[:-1] if s_rev_q.size > 1 else s_rev_q
L344         acc = None
L345         if tmp_prev.size >= 5 and yq is not None:
L346             yq_prev = yoy_q(tmp_prev)
L347             if yq_prev is not None:
L348                 acc = float(yq - yq_prev)
L349         parts["rev_acc_q"] = acc
L350         eps_yoy = yoy_q(s_eps_q) if s_eps_q.size >= 5 else None
L351         parts["eps_yoy_q"] = eps_yoy
L352         eps_acc = None
L353         if eps_yoy is not None and s_eps_q.size > 5:
L354             eps_prev = s_eps_q.iloc[:-1]
L355             if eps_prev.size >= 5:
L356                 eps_prev_yoy = yoy_q(eps_prev)
L357                 if eps_prev_yoy is not None:
L358                     eps_acc = float(eps_yoy - eps_prev_yoy)
L359         parts["eps_acc_q"] = eps_acc
L360         w = 1.0
L361         core_raw = (
L362             0.60 * _nz(yq)
L363             + 0.20 * _nz(acc)
L364             + 0.15 * _nz(eps_yoy)
L365             + 0.05 * _nz(eps_acc)
L366         )
L367         price_alt = 0.0
L368     elif 2 <= nQ <= 4:
L369         path = "P24"
L370         rev_qoq = qoq(s_rev_q)
L371         rev_ttm2 = ttm_delta(s_rev_q)
L372         parts["rev_qoq"] = rev_qoq
L373         parts["rev_ttm2"] = rev_ttm2
L374         eps_qoq = qoq(s_eps_q) if s_eps_q.size >= 2 else None
L375         parts["eps_qoq"] = eps_qoq
L376         w = min(1.0, nQ / 5.0)
L377         core_raw = 0.6 * _nz(rev_qoq) + 0.3 * _nz(rev_ttm2) + 0.1 * _nz(eps_qoq)
L378     else:
L379         path = "P1Y"
L380         rev_yoy_y = yoy_y(s_rev_y) if nY >= 2 else None
L381         parts["rev_yoy_y"] = rev_yoy_y
L382         w = 0.6 * min(1.0, nY / 3.0) if nY >= 2 else 0.4
L383         core_raw = _nz(rev_yoy_y)
L384         if nQ <= 1 and nY < 2 and price_alt == 0.0:
L385             price_alt = price_proxy_growth() or 0.0
L386
L387     core = _winsor(core_raw, lo=-1.5, hi=1.5)
L388     price_alt = _winsor(price_alt, lo=-1.5, hi=1.5)
L389     grw = _winsor(w * core + (1.0 - w) * (0.5 * _nz(price_alt)), lo=-2.0, hi=2.0)
L390
L391     parts.update(
L392         {
L393             "core_raw": core_raw,
L394             "core": core,
L395             "price_proxy_raw": price_raw,
L396             "price_proxy": price_alt,
L397             "weight": w,
L398             "score": grw,
L399         }
L400     )
L401
L402     parts_out: dict[str, Any] = {
L403         "nQ": nQ,
L404         "nY": nY,
L405     }
L406     for key, value in parts.items():
L407         if key in ("nQ", "nY"):
L408             continue
L409         rounded = _round_debug(value)
L410         parts_out[key] = rounded
L411
L412     parts_out["path"] = path
L413     parts_out["w"] = _round_debug(w)
L414
L415     info_entry["DEBUG_GRW_PATH"] = path
L416     info_entry["DEBUG_GRW_PARTS"] = json.dumps(parts_out, ensure_ascii=False, sort_keys=True)
L417     info_entry["DEBUG_GRW_PARTS_DICT"] = dict(parts_out)
L418     info_entry["GRW_SCORE"] = grw
L419     info_entry["GRW_WEIGHT"] = w
L420     info_entry["GRW_CORE"] = core
L421     info_entry["GRW_PRICE_PROXY"] = price_alt
L422
L423     return {
L424         "score": grw,
L425         "path": path,
L426         "parts": info_entry["DEBUG_GRW_PARTS"],
L427         "parts_dict": dict(parts_out),
L428         "weight": w,
L429         "core": core,
L430         "price_proxy": price_alt,
L431     }
L432
L433
L434 D_WEIGHTS_EFF = None  # 出力表示互換のため
L435
L436
L437 def _scalar(v):
L438     """単一セル代入用に値をスカラーへ正規化する。
L439
L440     - pandas Series -> .iloc[-1]（最後を採用）
L441     - list/tuple/ndarray -> 最後の要素
L442     - それ以外          -> そのまま
L443     取得失敗時は np.nan を返す。
L444     """
L445     import numpy as _np
L446     import pandas as _pd
L447     try:
L448         if isinstance(v, _pd.Series):
L449             return v.iloc[-1] if len(v) else _np.nan
L450         if isinstance(v, (list, tuple, _np.ndarray)):
L451             return v[-1] if len(v) else _np.nan
L452         return v
L453     except Exception:
L454         return _np.nan
L455
L456
L457 # ---- Scorer 本体 -------------------------------------------------------------
L458 class Scorer:
L459     """
L460     - factor.py からは `aggregate_scores(ib, cfg)` を呼ぶだけでOK。
L461     - cfg は必須（factor.PipelineConfig を渡す）。
L462     - 旧カラム名を自動リネームして新スキーマに吸収します。
L463     """
L464
L465     # === 先頭で旧→新カラム名マップ（移行用） ===
L466     EPS_RENAME = {"eps_ttm":"EPS_TTM", "eps_q_recent":"EPS_Q_LastQ"}
L467     FCF_RENAME = {"fcf_ttm":"FCF_TTM"}
L468
L469     # === スキーマ簡易チェック（最低限） ===
L470     @staticmethod
L471     def _validate_ib_for_scorer(ib: Any):
L472         miss = [a for a in ["tickers","bench","data","px","spx","tickers_bulk","info","eps_df","fcf_df","returns"] if not hasattr(ib,a) or getattr(ib,a) is None]
L473         if miss: raise ValueError(f"InputBundle is missing required attributes for Scorer: {miss}")
L474         if any(c in ib.eps_df.columns for c in Scorer.EPS_RENAME): ib.eps_df.rename(columns=Scorer.EPS_RENAME, inplace=True)
L475         if any(c in ib.fcf_df.columns for c in Scorer.FCF_RENAME): ib.fcf_df.rename(columns=Scorer.FCF_RENAME, inplace=True)
L476         need_eps, need_fcf = {"EPS_TTM","EPS_Q_LastQ"},{"FCF_TTM"}
L477         if not need_eps.issubset(ib.eps_df.columns): raise ValueError(f"eps_df must contain columns {need_eps} (accepts old names via auto-rename). Got: {list(ib.eps_df.columns)}")
L478         if not need_fcf.issubset(ib.fcf_df.columns): raise ValueError(f"fcf_df must contain columns {need_fcf} (accepts old names via auto-rename). Got: {list(ib.fcf_df.columns)}")
L479
L480     # ----（Scorer専用）テクニカル・指標系 ----
L481     @staticmethod
L482     def trend(s: pd.Series):
L483         if len(s)<200: return np.nan
L484         sma50, sma150, sma200 = s.rolling(50).mean().iloc[-1], s.rolling(150).mean().iloc[-1], s.rolling(200).mean().iloc[-1]
L485         prev200, p = s.rolling(200).mean().iloc[-21], s.iloc[-1]
L486         lo_52 = s[-252:].min() if len(s)>=252 else s.min(); hi_52 = s[-252:].max() if len(s)>=252 else s.max()
L487         rng = (hi_52 - lo_52)
```