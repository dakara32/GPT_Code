```text
 return float(v)
L368
L369
L370 def _round_debug(x, ndigits: int = 4):
L371     try:
L372         value = float(x)
L373     except Exception:
L374         return None
L375     if not np.isfinite(value):
L376         return None
L377     return round(value, ndigits)
L378
L379
L380 def _calc_grw_flexible(
L381     ticker: str,
L382     info_entry: dict | None,
L383     close_series: pd.Series | None,
L384     volume_series: pd.Series | None,
L385 ):
L386     info_entry = info_entry if isinstance(info_entry, dict) else {}
L387
L388     s_rev_q = _ensure_series(info_entry.get("SEC_REV_Q_SERIES"))
L389     s_eps_q = _ensure_series(info_entry.get("SEC_EPS_Q_SERIES"))
L390     s_rev_y = _ensure_series(info_entry.get("SEC_REV_Y_SERIES"))
L391
L392     nQ = int(getattr(s_rev_q, "size", 0))
L393     nY = int(getattr(s_rev_y, "size", 0))
L394
L395     parts: dict[str, Any] = {"nQ": nQ, "nY": nY}
L396     path = "NONE"
L397     w = 0.0
L398
L399     def _valid_ratio(a, b):
L400         try:
L401             na, nb = float(a), float(b)
L402         except Exception:
L403             return None
L404         if not np.isfinite(na) or not np.isfinite(nb) or nb == 0:
L405             return None
L406         return na, nb
L407
L408     def yoy_q(series: pd.Series) -> float | None:
L409         s = _ensure_series(series)
L410         if s.empty:
L411             return None
L412         s = s.sort_index()
L413         if isinstance(s.index, pd.DatetimeIndex):
L414             last_idx = s.index[-1]
L415             window_start = last_idx - pd.DateOffset(months=15)
L416             window_end = last_idx - pd.DateOffset(months=9)
L417             candidates = s.loc[(s.index >= window_start) & (s.index <= window_end)]
L418             if candidates.empty:
L419                 candidates = s.loc[s.index <= window_end]
L420             if candidates.empty:
L421                 return None
L422             v1 = candidates.iloc[-1]
L423             v0 = s.iloc[-1]
L424         else:
L425             if s.size < 5:
L426                 return None
L427             v0 = s.iloc[-1]
L428             v1 = s.iloc[-5]
L429         pair = _valid_ratio(v0, v1)
L430         if pair is None:
L431             return None
L432         a, b = pair
L433         return float(a / b - 1.0)
L434
L435     def qoq(series: pd.Series) -> float | None:
L436         s = _ensure_series(series)
L437         if s.size < 2:
L438             return None
L439         s = s.sort_index()
L440         v0, v1 = s.iloc[-1], s.iloc[-2]
L441         pair = _valid_ratio(v0, v1)
L442         if pair is None:
L443             return None
L444         a, b = pair
L445         return float(a / b - 1.0)
L446
L447     def ttm_delta(series: pd.Series) -> float | None:
L448         s = _ensure_series(series)
L449         if s.size < 2:
L450             return None
L451         s = s.sort_index()
L452         k = int(min(4, s.size))
L453         cur_slice = s.iloc[-k:]
L454         prev_slice = s.iloc[:-k]
L455         if prev_slice.empty:
L456             return None
L457         prev_k = int(min(k, prev_slice.size))
L458         cur_sum = float(cur_slice.sum())
L459         prev_sum = float(prev_slice.iloc[-prev_k:].sum())
L460         pair = _valid_ratio(cur_sum, prev_sum)
L461         if pair is None:
L462             return None
L463         a, b = pair
L464         return float(a / b - 1.0)
L465
L466     def yoy_y(series: pd.Series) -> float | None:
L467         s = _ensure_series(series)
L468         if s.size < 2:
L469             return None
L470         s = s.sort_index()
L471         v0, v1 = s.iloc[-1], s.iloc[-2]
L472         pair = _valid_ratio(v0, v1)
L473         if pair is None:
L474             return None
L475         a, b = pair
L476         return float(a / b - 1.0)
L477
L478     def price_proxy_growth() -> float | None:
L479         if not isinstance(close_series, pd.Series):
L480             return None
L481         close = close_series.sort_index().dropna()
L482         if close.empty:
L483             return None
L484         hh_window = int(min(126, len(close)))
L485         if hh_window < 20:
L486             return None
L487         hh = close.rolling(hh_window).max().iloc[-1]
L488         prox = None
L489         if np.isfinite(hh) and hh > 0:
L490             prox = float(close.iloc[-1] / hh)
L491         rs6 = None
L492         if len(close) >= 63:
L493             rs6 = float(close.pct_change(63).iloc[-1])
L494         rs12 = None
L495         if len(close) >= 126:
L496             rs12 = float(close.pct_change(126).iloc[-1])
L497         vexp = None
L498         if isinstance(volume_series, pd.Series):
L499             vol = volume_series.reindex(close.index).dropna()
L500             if len(vol) >= 50:
L501                 v20 = vol.rolling(20).mean().iloc[-1]
L502                 v50 = vol.rolling(50).mean().iloc[-1]
L503                 if np.isfinite(v20) and np.isfinite(v50) and v50 > 0:
L504                     vexp = float(v20 / v50 - 1.0)
L505         prox = 0.0 if prox is None or not np.isfinite(prox) else prox
L506         rs6 = 0.0 if rs6 is None or not np.isfinite(rs6) else rs6
L507         rs12 = 0.0 if rs12 is None or not np.isfinite(rs12) else rs12
L508         vexp = 0.0 if vexp is None or not np.isfinite(vexp) else vexp
L509         return 0.5 * prox + 0.3 * rs6 + 0.2 * rs12 + 0.2 * vexp
L510
L511     price_alt = price_proxy_growth() or 0.0
L512     core = 0.0
L513     core_raw = 0.0
L514     price_raw = price_alt
L515
L516     if nQ >= 5:
L517         path = "P5"
L518         yq = yoy_q(s_rev_q)
L519         parts["rev_yoy_q"] = yq
L520         tmp_prev = s_rev_q.iloc[:-1] if s_rev_q.size > 1 else s_rev_q
L521         acc = None
L522         if tmp_prev.size >= 5 and yq is not None:
L523             yq_prev = yoy_q(tmp_prev)
L524             if yq_prev is not None:
L525                 acc = float(yq - yq_prev)
L526         parts["rev_acc_q"] = acc
L527         eps_yoy = yoy_q(s_eps_q) if s_eps_q.size >= 5 else None
L528         parts["eps_yoy_q"] = eps_yoy
L529         eps_acc = None
L530         if eps_yoy is not None and s_eps_q.size > 5:
L531             eps_prev = s_eps_q.iloc[:-1]
L532             if eps_prev.size >= 5:
L533                 eps_prev_yoy = yoy_q(eps_prev)
L534                 if eps_prev_yoy is not None:
L535                     eps_acc = float(eps_yoy - eps_prev_yoy)
L536         parts["eps_acc_q"] = eps_acc
L537         w = 1.0
L538         core_raw = (
L539             0.60 * _nz(yq)
L540             + 0.20 * _nz(acc)
L541             + 0.15 * _nz(eps_yoy)
L542             + 0.05 * _nz(eps_acc)
L543         )
L544         price_alt = 0.0
L545     elif 2 <= nQ <= 4:
L546         path = "P24"
L547         rev_qoq = qoq(s_rev_q)
L548         rev_ttm2 = ttm_delta(s_rev_q)
L549         parts["rev_qoq"] = rev_qoq
L550         parts["rev_ttm2"] = rev_ttm2
L551         eps_qoq = qoq(s_eps_q) if s_eps_q.size >= 2 else None
L552         parts["eps_qoq"] = eps_qoq
L553         w = min(1.0, nQ / 5.0)
L554         core_raw = 0.6 * _nz(rev_qoq) + 0.3 * _nz(rev_ttm2) + 0.1 * _nz(eps_qoq)
L555     else:
L556         path = "P1Y"
L557         rev_yoy_y = yoy_y(s_rev_y) if nY >= 2 else None
L558         parts["rev_yoy_y"] = rev_yoy_y
L559         w = 0.6 * min(1.0, nY / 3.0) if nY >= 2 else 0.4
L560         core_raw = _nz(rev_yoy_y)
L561         if nQ <= 1 and nY < 2 and price_alt == 0.0:
L562             price_alt = price_proxy_growth() or 0.0
L563
L564     core = _winsor(core_raw, lo=-1.5, hi=1.5)
L565     price_alt = _winsor(price_alt, lo=-1.5, hi=1.5)
L566     grw = _winsor(w * core + (1.0 - w) * (0.5 * _nz(price_alt)), lo=-2.0, hi=2.0)
L567
L568     parts.update(
L569         {
L570             "core_raw": core_raw,
L571             "core": core,
L572             "price_proxy_raw": price_raw,
L573             "price_proxy": price_alt,
L574             "weight": w,
L575             "score": grw,
L576         }
L577     )
L578
L579     parts_out: dict[str, Any] = {
L580         "nQ": nQ,
L581         "nY": nY,
L582     }
L583     for key, value in parts.items():
L584         if key in ("nQ", "nY"):
L585             continue
L586         rounded = _round_debug(value)
L587         parts_out[key] = rounded
L588
L589     info_entry["DEBUG_GRW_PATH"] = path
L590     info_entry["DEBUG_GRW_PARTS"] = json.dumps(parts_out, ensure_ascii=False, sort_keys=True)
L591     info_entry["GRW_SCORE"] = grw
L592     info_entry["GRW_WEIGHT"] = w
L593     info_entry["GRW_CORE"] = core
L594     info_entry["GRW_PRICE_PROXY"] = price_alt
L595
L596     return {
L597         "score": grw,
L598         "path": path,
L599         "parts": info_entry["DEBUG_GRW_PARTS"],
L600         "weight": w,
L601         "core": core,
L602         "price_proxy": price_alt,
L603     }
L604
L605
L606 D_WEIGHTS_EFF = None  # 出力表示互換のため
L607
L608
L609 def _scalar(v):
L610     """単一セル代入用に値をスカラーへ正規化する。
L611
L612     - pandas Series -> .iloc[-1]（最後を採用）
L613     - list/tuple/ndarray -> 最後の要素
L614     - それ以外          -> そのまま
L615     取得失敗時は np.nan を返す。
L616     """
L617     import numpy as _np
L618     import pandas as _pd
L619     try:
L620         if isinstance(v, _pd.Series):
L621             return v.iloc[-1] if len(v) else _np.nan
L622         if isinstance(v, (list, tuple, _np.ndarray)):
L623             return v[-1] if len(v) else _np.nan
L624         return v
L625     except Exception:
L626         return _np.nan
L627
L628
L629 # ---- Scorer 本体 -------------------------------------------------------------
L630 class Scorer:
L631     """
L632     - factor.py からは `aggregate_scores(ib, cfg)` を呼ぶだけでOK。
L633     - cfg は必須（factor.PipelineConfig を渡す）。
L634     - 旧カラム名を自動リネームして新スキーマに吸収します。
L635     """
L636
L637     # === 先頭で旧→新カラム名マップ（移行用） ===
L638     EPS_RENAME = {"eps_ttm":"EPS_TTM", "eps_q_recent":"EPS_Q_LastQ"}
L639     FCF_RENAME = {"fcf_ttm":"FCF_TTM"}
L640
L641     # === スキーマ簡易チェック（最低限） ===
L642     @staticmethod
L643     def _validate_ib_for_scorer(ib: Any):
L644         miss = [a for a in ["tickers","bench","data","px","spx","tickers_bulk","info","eps_df","fcf_df","returns"] if not hasattr(ib,a) or getattr(ib,a) is None]
L645         if miss: raise ValueError(f"InputBundle is missing required attributes for Scorer: {miss}")
L646         if any(c in ib.eps_df.columns for c in Scorer.EPS_RENAME): ib.eps_df.rename(columns=Scorer.EPS_RENAME, inplace=True)
L647         if any(c in ib.fcf_df.columns for c in Scorer.FCF_RENAME): ib.fcf_df.rename(columns=Scorer.FCF_RENAME, inplace=True)
L648         need_eps, need_fcf = {"EPS_TTM","EPS_Q_LastQ"},{"FCF_TTM"}
L649         if not need_eps.issubset(ib.eps_df.columns): raise ValueError(f"eps_df must contain columns {need_eps} (accepts old names via auto-rename). Got: {list(ib.eps_df.columns)}")
L650         if not need_fcf.issubset(ib.fcf_df.columns): raise ValueError(f"fcf_df must contain columns {need_fcf} (accepts old names via auto-rename). Got: {list(ib.fcf_df.columns)}")
L651
L652     # ----（Scorer専用）テクニカル・指標系 ----
L653     @staticmethod
L654     def trend(s: pd.Series):
L655         if len(s)<200: return np.nan
L656         sma50, sma150, sma200 = s.rolling(50).mean().iloc[-1], s.rolling(150).mean().iloc[-1], s.rolling(200).mean().iloc[-1]
L657         prev200, p = s.rolling(200).mean().iloc[-21], s.iloc[-1]
L658         lo_52 = s[-252:].min() if len(s)>=252 else s.min(); hi_52 = s[-252:].max() if len(s)>=252 else s.max()
L659         rng = (hi_52 - lo_52) if hi_52>lo_52 else np.nan
L660         clip = lambda x,lo,hi: (np.nan if pd.isna(x) else max(lo,min(hi,x)))
L661         a = clip(p/(s.rolling(50).mean().iloc[-1]) - 1, -0.5, 0.5)
L662         b = clip(sma50/sma150 - 1, -0.5, 0.5)
L663         c = clip(sma150/sma200 - 1, -0.5, 0.5)
L664         d = clip(sma200/prev200 - 1, -0.2, 0.2)
L665         e = clip((p - lo_52) / (rng if rng and rng>0 else np.nan) - 0.5, -0.5, 0.5)
L666         parts = [0.0 if pd.isna(x) else x for x in (a,b,c,d,e)]
L667         return 0.30*parts[0] +
```