```text
      return pd.Series(x).dropna()
L392     except Exception:
L393         return pd.Series(dtype=float)
L394
L395
L396 def _to_quarterly(s: pd.Series) -> pd.Series:
L397     if s.empty or not isinstance(s.index, pd.DatetimeIndex):
L398         return s
L399     return s.resample("Q").last().dropna()
L400
L401
L402 def _ttm_yoy_from_quarterly(qs: pd.Series) -> pd.Series:
L403     if qs is None or qs.empty:
L404         return pd.Series(dtype=float)
L405     ttm = qs.rolling(4, min_periods=2).sum()
L406     yoy = ttm.pct_change(4)
L407     return yoy
L408
L409
L410 def _nz(x) -> float:
L411     if x is None:
L412         return 0.0
L413     try:
L414         value = float(x)
L415     except Exception:
L416         return 0.0
L417     if not np.isfinite(value):
L418         return 0.0
L419     return value
L420
L421
L422 def _winsor(x, lo=-2.0, hi=2.0) -> float:
L423     v = _nz(x)
L424     if v < lo:
L425         return float(lo)
L426     if v > hi:
L427         return float(hi)
L428     return float(v)
L429
L430
L431 def _round_debug(x, ndigits: int = 4):
L432     try:
L433         value = float(x)
L434     except Exception:
L435         return None
L436     if not np.isfinite(value):
L437         return None
L438     return round(value, ndigits)
L439
L440
L441 def _calc_grw_flexible(
L442     ticker: str,
L443     info_entry: dict | None,
L444     close_series: pd.Series | None,
L445     volume_series: pd.Series | None,
L446 ):
L447     info_entry = info_entry if isinstance(info_entry, dict) else {}
L448
L449     s_rev_q = _ensure_series(info_entry.get("SEC_REV_Q_SERIES"))
L450     s_eps_q = _ensure_series(info_entry.get("SEC_EPS_Q_SERIES"))
L451     s_rev_y = _ensure_series(info_entry.get("SEC_REV_Y_SERIES"))
L452
L453     nQ = int(getattr(s_rev_q, "size", 0))
L454     nY = int(getattr(s_rev_y, "size", 0))
L455
L456     parts: dict[str, Any] = {"nQ": nQ, "nY": nY}
L457     path = "NONE"
L458     w = 0.0
L459
L460     def _valid_ratio(a, b):
L461         try:
L462             na, nb = float(a), float(b)
L463         except Exception:
L464             return None
L465         if not np.isfinite(na) or not np.isfinite(nb) or nb == 0:
L466             return None
L467         return na, nb
L468
L469     def yoy_q(series: pd.Series) -> float | None:
L470         s = _ensure_series(series)
L471         if s.empty:
L472             return None
L473         s = s.sort_index()
L474         if isinstance(s.index, pd.DatetimeIndex):
L475             last_idx = s.index[-1]
L476             window_start = last_idx - pd.DateOffset(months=15)
L477             window_end = last_idx - pd.DateOffset(months=9)
L478             candidates = s.loc[(s.index >= window_start) & (s.index <= window_end)]
L479             if candidates.empty:
L480                 candidates = s.loc[s.index <= window_end]
L481             if candidates.empty:
L482                 return None
L483             v1 = candidates.iloc[-1]
L484             v0 = s.iloc[-1]
L485         else:
L486             if s.size < 5:
L487                 return None
L488             v0 = s.iloc[-1]
L489             v1 = s.iloc[-5]
L490         pair = _valid_ratio(v0, v1)
L491         if pair is None:
L492             return None
L493         a, b = pair
L494         return float(a / b - 1.0)
L495
L496     def qoq(series: pd.Series) -> float | None:
L497         s = _ensure_series(series)
L498         if s.size < 2:
L499             return None
L500         s = s.sort_index()
L501         v0, v1 = s.iloc[-1], s.iloc[-2]
L502         pair = _valid_ratio(v0, v1)
L503         if pair is None:
L504             return None
L505         a, b = pair
L506         return float(a / b - 1.0)
L507
L508     def ttm_delta(series: pd.Series) -> float | None:
L509         s = _ensure_series(series)
L510         if s.size < 2:
L511             return None
L512         s = s.sort_index()
L513         k = int(min(4, s.size))
L514         cur_slice = s.iloc[-k:]
L515         prev_slice = s.iloc[:-k]
L516         if prev_slice.empty:
L517             return None
L518         prev_k = int(min(k, prev_slice.size))
L519         cur_sum = float(cur_slice.sum())
L520         prev_sum = float(prev_slice.iloc[-prev_k:].sum())
L521         pair = _valid_ratio(cur_sum, prev_sum)
L522         if pair is None:
L523             return None
L524         a, b = pair
L525         return float(a / b - 1.0)
L526
L527     def yoy_y(series: pd.Series) -> float | None:
L528         s = _ensure_series(series)
L529         if s.size < 2:
L530             return None
L531         s = s.sort_index()
L532         v0, v1 = s.iloc[-1], s.iloc[-2]
L533         pair = _valid_ratio(v0, v1)
L534         if pair is None:
L535             return None
L536         a, b = pair
L537         return float(a / b - 1.0)
L538
L539     def price_proxy_growth() -> float | None:
L540         if not isinstance(close_series, pd.Series):
L541             return None
L542         close = close_series.sort_index().dropna()
L543         if close.empty:
L544             return None
L545         hh_window = int(min(126, len(close)))
L546         if hh_window < 20:
L547             return None
L548         hh = close.rolling(hh_window).max().iloc[-1]
L549         prox = None
L550         if np.isfinite(hh) and hh > 0:
L551             prox = float(close.iloc[-1] / hh)
L552         rs6 = None
L553         if len(close) >= 63:
L554             rs6 = float(close.pct_change(63).iloc[-1])
L555         rs12 = None
L556         if len(close) >= 126:
L557             rs12 = float(close.pct_change(126).iloc[-1])
L558         vexp = None
L559         if isinstance(volume_series, pd.Series):
L560             vol = volume_series.reindex(close.index).dropna()
L561             if len(vol) >= 50:
L562                 v20 = vol.rolling(20).mean().iloc[-1]
L563                 v50 = vol.rolling(50).mean().iloc[-1]
L564                 if np.isfinite(v20) and np.isfinite(v50) and v50 > 0:
L565                     vexp = float(v20 / v50 - 1.0)
L566         prox = 0.0 if prox is None or not np.isfinite(prox) else prox
L567         rs6 = 0.0 if rs6 is None or not np.isfinite(rs6) else rs6
L568         rs12 = 0.0 if rs12 is None or not np.isfinite(rs12) else rs12
L569         vexp = 0.0 if vexp is None or not np.isfinite(vexp) else vexp
L570         return 0.5 * prox + 0.3 * rs6 + 0.2 * rs12 + 0.2 * vexp
L571
L572     price_alt = price_proxy_growth() or 0.0
L573     core = 0.0
L574     core_raw = 0.0
L575     price_raw = price_alt
L576
L577     if nQ >= 5:
L578         path = "P5"
L579         yq = yoy_q(s_rev_q)
L580         parts["rev_yoy_q"] = yq
L581         tmp_prev = s_rev_q.iloc[:-1] if s_rev_q.size > 1 else s_rev_q
L582         acc = None
L583         if tmp_prev.size >= 5 and yq is not None:
L584             yq_prev = yoy_q(tmp_prev)
L585             if yq_prev is not None:
L586                 acc = float(yq - yq_prev)
L587         parts["rev_acc_q"] = acc
L588         eps_yoy = yoy_q(s_eps_q) if s_eps_q.size >= 5 else None
L589         parts["eps_yoy_q"] = eps_yoy
L590         eps_acc = None
L591         if eps_yoy is not None and s_eps_q.size > 5:
L592             eps_prev = s_eps_q.iloc[:-1]
L593             if eps_prev.size >= 5:
L594                 eps_prev_yoy = yoy_q(eps_prev)
L595                 if eps_prev_yoy is not None:
L596                     eps_acc = float(eps_yoy - eps_prev_yoy)
L597         parts["eps_acc_q"] = eps_acc
L598         w = 1.0
L599         core_raw = (
L600             0.60 * _nz(yq)
L601             + 0.20 * _nz(acc)
L602             + 0.15 * _nz(eps_yoy)
L603             + 0.05 * _nz(eps_acc)
L604         )
L605         price_alt = 0.0
L606     elif 2 <= nQ <= 4:
L607         path = "P24"
L608         rev_qoq = qoq(s_rev_q)
L609         rev_ttm2 = ttm_delta(s_rev_q)
L610         parts["rev_qoq"] = rev_qoq
L611         parts["rev_ttm2"] = rev_ttm2
L612         eps_qoq = qoq(s_eps_q) if s_eps_q.size >= 2 else None
L613         parts["eps_qoq"] = eps_qoq
L614         w = min(1.0, nQ / 5.0)
L615         core_raw = 0.6 * _nz(rev_qoq) + 0.3 * _nz(rev_ttm2) + 0.1 * _nz(eps_qoq)
L616     else:
L617         path = "P1Y"
L618         rev_yoy_y = yoy_y(s_rev_y) if nY >= 2 else None
L619         parts["rev_yoy_y"] = rev_yoy_y
L620         w = 0.6 * min(1.0, nY / 3.0) if nY >= 2 else 0.4
L621         core_raw = _nz(rev_yoy_y)
L622         if nQ <= 1 and nY < 2 and price_alt == 0.0:
L623             price_alt = price_proxy_growth() or 0.0
L624
L625     core = _winsor(core_raw, lo=-1.5, hi=1.5)
L626     price_alt = _winsor(price_alt, lo=-1.5, hi=1.5)
L627     grw = _winsor(w * core + (1.0 - w) * (0.5 * _nz(price_alt)), lo=-2.0, hi=2.0)
L628
L629     parts.update(
L630         {
L631             "core_raw": core_raw,
L632             "core": core,
L633             "price_proxy_raw": price_raw,
L634             "price_proxy": price_alt,
L635             "weight": w,
L636             "score": grw,
L637         }
L638     )
L639
L640     parts_out: dict[str, Any] = {
L641         "nQ": nQ,
L642         "nY": nY,
L643     }
L644     for key, value in parts.items():
L645         if key in ("nQ", "nY"):
L646             continue
L647         rounded = _round_debug(value)
L648         parts_out[key] = rounded
L649
L650     info_entry["DEBUG_GRW_PATH"] = path
L651     info_entry["DEBUG_GRW_PARTS"] = json.dumps(parts_out, ensure_ascii=False, sort_keys=True)
L652     info_entry["GRW_SCORE"] = grw
L653     info_entry["GRW_WEIGHT"] = w
L654     info_entry["GRW_CORE"] = core
L655     info_entry["GRW_PRICE_PROXY"] = price_alt
L656
L657     return {
L658         "score": grw,
L659         "path": path,
L660         "parts": info_entry["DEBUG_GRW_PARTS"],
L661         "weight": w,
L662         "core": core,
L663         "price_proxy": price_alt,
L664     }
L665
L666
L667 D_WEIGHTS_EFF = None  # 出力表示互換のため
L668
L669
L670 def _scalar(v):
L671     """単一セル代入用に値をスカラーへ正規化する。
L672
L673     - pandas Series -> .iloc[-1]（最後を採用）
L674     - list/tuple/ndarray -> 最後の要素
L675     - それ以外          -> そのまま
L676     取得失敗時は np.nan を返す。
L677     """
L678     import numpy as _np
L679     import pandas as _pd
L680     try:
L681         if isinstance(v, _pd.Series):
L682             return v.iloc[-1] if len(v) else _np.nan
L683         if isinstance(v, (list, tuple, _np.ndarray)):
L684             return v[-1] if len(v) else _np.nan
L685         return v
L686     except Exception:
L687         return _np.nan
L688
L689
L690 # ---- Scorer 本体 -------------------------------------------------------------
L691 class Scorer:
L692     """
L693     - factor.py からは `aggregate_scores(ib, cfg)` を呼ぶだけでOK。
L694     - cfg は必須（factor.PipelineConfig を渡す）。
L695     - 旧カラム名を自動リネームして新スキーマに吸収します。
L696     """
L697
L698     # === 先頭で旧→新カラム名マップ（移行用） ===
L699     EPS_RENAME = {"eps_ttm":"EPS_TTM", "eps_q_recent":"EPS_Q_LastQ"}
L700     FCF_RENAME = {"fcf_ttm":"FCF_TTM"}
L701
L702     # === スキーマ簡易チェック（最低限） ===
L703     @staticmethod
L704     def _validate_ib_for_scorer(ib: Any):
L705         miss = [a for a in ["tickers","bench","data","px","spx","tickers_bulk","info","eps_df","fcf_df","returns"] if not hasattr(ib,a) or getattr(ib,a) is None]
L706         if miss: raise ValueError(f"InputBundle is missing required attributes for Scorer: {miss}")
L707         if any(c in ib.eps_df.columns for c in Scorer.EPS_RENAME): ib.eps_df.rename(columns=Scorer.EPS_RENAME, inplace=True)
L708         if any(c in ib.fcf_df.columns for c in Scorer.FCF_RENAME): ib.fcf_df.rename(columns=Scorer.FCF_RENAME, inplace=True)
L709         need_eps, need_fcf = {"EPS_TTM","EPS_Q_LastQ"},{"FCF_TTM"}
L710         if not need_eps.issubset(ib.eps_df.columns): raise ValueError(f"eps_df must contain columns {need_eps} (accepts old names via auto-rename). Got: {list(ib.eps_df.columns)}")
L711         if not need_fcf.issubset(ib.fcf_df.columns): raise ValueError(f"fcf_df must contain columns {need_fcf} (accepts old names via auto-rename). Got: {list(ib.fcf_df.columns)}")
L712
L713     # ----（Scor
```