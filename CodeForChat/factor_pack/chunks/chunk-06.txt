```text
utBundle:
L1113     """
L1114     既存の『データ取得→前処理』を実行し、InputBundle を返す。
L1115     処理内容・列名・丸め・例外・ログ文言は現行どおり（変更禁止）。
L1116     """
L1117     state = Input(cand=cand, exist=exist, bench=bench, price_max=CAND_PRICE_MAX, finnhub_api_key=FINNHUB_API_KEY).prepare_data()
L1118     return InputBundle(cand=state["cand"], tickers=state["tickers"], bench=bench, data=state["data"], px=state["px"], spx=state["spx"], tickers_bulk=state["tickers_bulk"], info=state["info"], eps_df=state["eps_df"], fcf_df=state["fcf_df"], returns=state["returns"])
L1119
L1120 def run_group(sc: Scorer, group: str, inb: InputBundle, cfg: PipelineConfig,
L1121               n_target: int) -> tuple[list, float, float, float]:
L1122     """
L1123     G/Dを同一手順で処理：採点→フィルター→選定（相関低減込み）。
L1124     戻り値：(pick, avg_res_corr, sum_score, objective)
L1125     JSON保存は既存フォーマット（キー名・丸め桁・順序）を踏襲。
L1126     """
L1127     sc.cfg = cfg
L1128
L1129     if hasattr(sc, "score_build_features"):
L1130         feat = sc.score_build_features(inb)
L1131         if not hasattr(sc, "_feat_logged"):
L1132             T.log("features built (scorer)")
L1133             sc._feat_logged = True
L1134         agg = sc.score_aggregate(feat, group, cfg) if hasattr(sc, "score_aggregate") else feat
L1135     else:
L1136         fb = sc.aggregate_scores(inb, cfg)
L1137         if not hasattr(sc, "_feat_logged"):
L1138             T.log("features built (scorer)")
L1139             sc._feat_logged = True
L1140         sc._feat = fb
L1141         agg = fb.g_score if group == "G" else fb.d_score_all
L1142         if group == "D" and hasattr(fb, "df"):
L1143             agg = agg[fb.df['BETA'] < D_BETA_MAX]
L1144
L1145     if hasattr(sc, "filter_candidates"):
L1146         agg = agg[sc.filter_candidates(inb, agg, group, cfg)]
L1147
L1148     selector = Selector()
L1149     if hasattr(sc, "select_diversified"):
L1150         pick, avg_r, sum_sc, obj = sc.select_diversified(agg, group, cfg, n_target,
L1151             selector=selector, prev_tickers=None,
L1152             corrM=cfg.drrs.corrM, shrink=cfg.drrs.shrink,
L1153             cross_mu=cfg.drrs.cross_mu_gd)
L1154     else:
L1155         if group == "G":
L1156             init = agg.nlargest(min(cfg.drrs.corrM, len(agg))).index.tolist()
L1157             res = selector.select_bucket_drrs(returns_df=inb.returns, score_ser=agg, pool_tickers=init, k=n_target,
L1158                 n_pc=cfg.drrs.G.get("n_pc", 3), gamma=cfg.drrs.G.get("gamma", 1.2),
L1159                 lam=cfg.drrs.G.get("lam", 0.68),
L1160                 lookback=cfg.drrs.G.get("lookback", 252),
L1161                 shrink=cfg.drrs.shrink, g_fixed_tickers=None, mu=0.0)
L1162         else:
L1163             init = agg.nlargest(min(cfg.drrs.corrM, len(agg))).index.tolist()
L1164             g_fixed = getattr(sc, "_top_G", None)
L1165             res = selector.select_bucket_drrs(returns_df=inb.returns, score_ser=agg, pool_tickers=init, k=n_target,
L1166                 n_pc=cfg.drrs.D.get("n_pc", 4), gamma=cfg.drrs.D.get("gamma", 0.8),
L1167                 lam=cfg.drrs.D.get("lam", 0.85),
L1168                 lookback=cfg.drrs.D.get("lookback", 504),
L1169                 shrink=cfg.drrs.shrink, g_fixed_tickers=g_fixed,
L1170                 mu=cfg.drrs.cross_mu_gd)
L1171         pick = res["tickers"]; avg_r = res["avg_res_corr"]
L1172         sum_sc = res["sum_score"]; obj = res["objective"]
L1173         if group == "D":
L1174             _, pick = _disjoint_keepG(getattr(sc, "_top_G", []), pick, init)
L1175             T.log("selection finalized (G/D)")
L1176     try:
L1177         inc = [t for t in exist if t in agg.index]
L1178         pick = _sticky_keep_current(
L1179             agg=agg, pick=pick, incumbents=inc, n_target=n_target,
L1180             delta_z=SWAP_DELTA_Z, keep_buffer=SWAP_KEEP_BUFFER
L1181         )
L1182     except Exception as _e:
L1183         print(f"[warn] sticky_keep_current skipped: {str(_e)}")
L1184     # --- Near-Miss: 惜しくも選ばれなかった上位10を保持（Slack表示用） ---
L1185     # 5) Near-Miss と最終集計Seriesを保持（表示専用。計算へ影響なし）
L1186     try:
L1187         pool = agg.drop(index=[t for t in pick if t in agg.index], errors="ignore")
L1188         near10 = list(pool.sort_values(ascending=False).head(10).index)
L1189         setattr(sc, f"_near_{group}", near10)
L1190         setattr(sc, f"_agg_{group}", agg)
L1191     except Exception:
L1192         pass
L1193
L1194     if group == "D":
L1195         T.log("save done")
L1196     if group == "G":
L1197         sc._top_G = pick
L1198     return pick, avg_r, sum_sc, obj
L1199
L1200 def run_pipeline() -> SelectionBundle:
L1201     """
L1202     G/D共通フローの入口。I/Oはここだけで実施し、計算はScorerに委譲。
L1203     Slack文言・丸め・順序は既存の Output を用いて変更しない。
L1204     """
L1205     inb = io_build_input_bundle()
L1206     cfg = PipelineConfig(
L1207         weights=WeightsConfig(g=g_weights, d=D_weights),
L1208         drrs=DRRSParams(
L1209             corrM=corrM, shrink=DRRS_SHRINK,
L1210             G=DRRS_G, D=DRRS_D, cross_mu_gd=CROSS_MU_GD
L1211         ),
L1212         price_max=CAND_PRICE_MAX,
L1213         debug_mode=debug_mode
L1214     )
L1215     sc = Scorer()
L1216     top_G, avgG, sumG, objG = run_group(sc, "G", inb, cfg, N_G)
L1217     poolG = list(getattr(sc, "_agg_G", pd.Series(dtype=float)).sort_values(ascending=False).index)
L1218     alpha = Scorer.spx_to_alpha(inb.spx)
L1219     sectors = {t:(inb.info.get(t,{}).get("sector") or "U") for t in poolG}; scores = {t:Scorer.g_score.get(t,0.0) for t in poolG}
L1220     top_G = Scorer.pick_top_softcap(scores, sectors, N=N_G, cap=2, alpha=alpha, hard=5)
L1221     sc._top_G = top_G
L1222     try:
L1223         aggG = getattr(sc, "_agg_G", pd.Series(dtype=float)).sort_values(ascending=False)
L1224         sc._near_G = [t for t in aggG.index if t not in set(top_G)][:10]
L1225     except Exception:
L1226         pass
L1227     base = sum(Scorer.g_score.get(t,0.0) for t in poolG[:N_G])
L1228     effs = sum(Scorer.g_score.get(t,0.0) for t in top_G)
L1229     print(f"[soft_cap2] score_cost={(base-effs)/max(1e-9,abs(base)):.2%}, alpha={alpha:.3f}")
L1230     top_D, avgD, sumD, objD = run_group(sc, "D", inb, cfg, N_D)
L1231     fb = getattr(sc, "_feat", None)
L1232     near_G = getattr(sc, "_near_G", [])
L1233     selected12 = list(top_G)
L1234     df = fb.df if fb is not None else pd.DataFrame()
L1235     guni = _infer_g_universe(df, selected12, near_G)
L1236     try:
L1237         fire_recent = [t for t in guni
L1238                        if (str(df.at[t, "G_BREAKOUT_recent_5d"]) == "True") or
L1239                           (str(df.at[t, "G_PULLBACK_recent_5d"]) == "True")]
L1240     except Exception: fire_recent = []
L1241
L1242     lines = [
L1243         "【G枠レポート｜週次モニタ（直近5営業日）】",
L1244         "【凡例】🔥=直近5営業日内に「ブレイクアウト確定」または「押し目反発」を検知",
L1245         f"選定{N_G}: {', '.join(_fmt_with_fire_mark(selected12, df))}" if selected12 else f"選定{N_G}: なし",
L1246         f"次点10: {', '.join(_fmt_with_fire_mark(near_G, df))}" if near_G else "次点10: なし",]
L1247
L1248     if fire_recent:
L1249         fire_list = ", ".join([_label_recent_event(t, df) for t in fire_recent])
L1250         lines.append(f"過去5営業日の検知: {fire_list}")
L1251     else:
L1252         lines.append("過去5営業日の検知: なし")
L1253
L1254     try:
L1255         webhook = os.environ.get("SLACK_WEBHOOK_URL", "")
L1256         if webhook:
L1257             requests.post(webhook, json={"text": "\n".join([s for s in lines if s != ""])}, timeout=10)
L1258     except Exception:
L1259         pass
L1260
L1261     out = Output()
L1262     # 表示側から選定時の集計へアクセスできるように保持（表示専用・副作用なし）
L1263     try: out._sc = sc
L1264     except Exception: pass
L1265     if hasattr(sc, "_feat"):
L1266         try:
L1267             fb = sc._feat
L1268             out.miss_df = fb.missing_logs
L1269             out.display_results(
L1270                 exist=exist,
L1271                 bench=bench,
L1272                 df_z=fb.df_z,
L1273                 g_score=fb.g_score,
L1274                 d_score_all=fb.d_score_all,
L1275                 init_G=top_G,
L1276                 init_D=top_D,
L1277                 top_G=top_G,
L1278                 top_D=top_D,
L1279                 df_full_z=getattr(fb, "df_full_z", None),
L1280                 prev_G=getattr(sc, "_prev_G", exist),
L1281                 prev_D=getattr(sc, "_prev_D", exist),
L1282             )
L1283         except Exception:
L1284             pass
L1285     out.notify_slack()
L1286     sb = SelectionBundle(resG={"tickers": top_G, "avg_res_corr": avgG,
L1287               "sum_score": sumG, "objective": objG},
L1288         resD={"tickers": top_D, "avg_res_corr": avgD,
L1289               "sum_score": sumD, "objective": objD},
L1290         top_G=top_G, top_D=top_D, init_G=top_G, init_D=top_D)
L1291
L1292     # --- Low Score Candidates (GSC+DSC bottom 10) : send before debug dump ---
L1293     try:
L1294         _low_df = (pd.DataFrame({"GSC": fb.g_score, "DSC": fb.d_score_all})
L1295               .assign(G_plus_D=lambda x: x["GSC"] + x["DSC"])
L1296               .sort_values("G_plus_D")
L1297               .head(10)
L1298               .round(3))
L1299         low_msg = "Low Score Candidates (GSC+DSC bottom 10)\n" + _low_df.to_string(index=True, index_names=False)
L1300         _post_slack({"text": f"```{low_msg}```"})
L1301     except Exception as _e:
L1302         _post_slack({"text": f"```Low Score Candidates: 作成失敗: {_e}```"})
L1303
L1304     return sb
L1305
L1306 if __name__ == "__main__":
L1307     run_pipeline()
```

## <scorer.py>
```text
L1 # scorer.py
L2 # kawatest
L3 # =============================================================================
L4 # Scorer: ファクター/指標の生成と合成スコア算出を担う純粋層
L5 #
L6 # 【このファイルだけ読めば分かるポイント】
L7 # - 入力(InputBundle)は「価格/出来高/ベンチ/基本情報/EPS/FCF/リターン」を含むDTO
L8 # - 出力(FeatureBundle)は「raw特徴量 df」「標準化 df_z」「G/D スコア」「欠損ログ」
L9 # - 重み等のコンフィグ(PipelineConfig)は factor から渡す（cfg 必須）
L10 # - 旧カラム名は Scorer 内で自動リネームして受け入れ（後方互換）
L11 #   例) eps_ttm -> EPS_TTM, eps_q_recent -> EPS_Q_LastQ, fcf_ttm -> FCF_TTM
L12 #
L13 # 【I/O契約（Scorerが参照するInputBundleフィールド）】
L14 #   - cand: List[str]    … 候補銘柄（単体実行では未使用）
L15 #   - tickers: List[str] … 対象銘柄リスト
L16 #   - bench: str         … ベンチマークティッカー（例 '^GSPC'）
L17 #   - data: pd.DataFrame … yfinance download結果 ('Close','Volume' 等の階層列)
L18 #   - px: pd.DataFrame   … data['Close'] 相当（終値）
L19 #   - spx: pd.Series     … ベンチマークの終値
L20 #   - tickers_bulk: object         … yfinance.Tickers
L21 #   - info: Dict[str, dict]        … yfinance info per ticker
L22 #   - eps_df: pd.DataFrame         … 必須列: EPS_TTM, EPS_Q_LastQ（旧名も可）
L23 #   - fcf_df: pd.DataFrame         … 必須列: FCF_TTM（旧名も可）
L24 #   - returns: pd.DataFrame        … px[tickers].pct_change() 相当
L25 #
L26 # ※入出力の形式・例外文言は既存実装を変えません（安全な短縮のみ）
L27 # =============================================================================
L28
L29 import logging
L30 import os, sys, warnings
L31 import json
L32 import requests
L33 import numpy as np
L34 import pandas as pd
L35 import yfinance as yf
L36 from typing import Any, TYPE_CHECKING
L37 from scipy.stats import zscore
L38 from datetime import datetime as _dt
L39
L40 FACTOR_COLUMNS = {
L41     "GRW": [
L42         "GROWTH_F",
L43         "GRW_FLEX_SCORE",
L44         "GRW_REV_YOY_Q",
L45         "GRW_REV_ACC_Q",
L46         "GRW_REV_QOQ",
L47         "GRW_REV_TTM2",
L48         "GRW_REV_YOY_Y",
L49         "GRW_PRICE_PROXY",
L50         "GRW_PATH",
L51     ],
L52     "MOM": ["MOM", "MOM_RAW", "MOM_P12M", "MOM_P6M", "MOM_P1M"],
L53     "VOL": ["VOL", "VOL_SD", "VOL_BETA"],
L54     "QUAL": ["QUAL", "ROE", "ROA", "FCF_MGN"],
L55     "VAL": ["VAL", "PE", "PB", "PS", "EVEBITDA"],
L56 }
L57
L58 if TYPE_CHECKING:
L59     from factor import PipelineConfig  # type: ignore  # 実行時importなし（循環回避）
L60
L61 logger = logging.getLogger(__name__)
L62
L63
L64 def _log(stage, msg):
L65     try:
L66         print(f"[DBG][{_dt.utcnow().isoformat(timespec='seconds')}Z][{stage}] {msg}")
L67     except Exception:
L68         print(f"[DBG][{stage}] {msg}")
L69
L70
L71 def _c
```