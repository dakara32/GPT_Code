```text
 init_G=top_G, init_D=top_D)
L1126
L1127     # --- Low Score Candidates (GSC+DSC bottom 10) : send before debug dump ---
L1128     try:
L1129         _low_df = (pd.DataFrame({"GSC": fb.g_score, "DSC": fb.d_score_all})
L1130               .assign(G_plus_D=lambda x: x["GSC"] + x["DSC"])
L1131               .sort_values("G_plus_D")
L1132               .head(10)
L1133               .round(3))
L1134         low_msg = "Low Score Candidates (GSC+DSC bottom 10)\n" + _low_df.to_string(index=True, index_names=False)
L1135         _post_slack({"text": f"```{low_msg}```"})
L1136     except Exception as _e:
L1137         _post_slack({"text": f"```Low Score Candidates: 作成失敗: {_e}```"})
L1138
L1139     return sb
L1140
L1141 if __name__ == "__main__":
L1142     run_pipeline()
```

## <scorer.py>
```text
L1 # scorer.py
L2 # kawatest
L3 # =============================================================================
L4 # Scorer: ファクター/指標の生成と合成スコア算出を担う純粋層
L5 #
L6 # 【このファイルだけ読めば分かるポイント】
L7 # - 入力(InputBundle)は「価格/出来高/ベンチ/基本情報/EPS/FCF/リターン」を含むDTO
L8 # - 出力(FeatureBundle)は「raw特徴量 df」「標準化 df_z」「G/D スコア」「欠損ログ」
L9 # - 重み等のコンフィグ(PipelineConfig)は factor から渡す（cfg 必須）
L10 # - 旧カラム名は Scorer 内で自動リネームして受け入れ（後方互換）
L11 #   例) eps_ttm -> EPS_TTM, eps_q_recent -> EPS_Q_LastQ, fcf_ttm -> FCF_TTM
L12 #
L13 # 【I/O契約（Scorerが参照するInputBundleフィールド）】
L14 #   - cand: List[str]    … 候補銘柄（単体実行では未使用）
L15 #   - tickers: List[str] … 対象銘柄リスト
L16 #   - bench: str         … ベンチマークティッカー（例 '^GSPC'）
L17 #   - data: pd.DataFrame … yfinance download結果 ('Close','Volume' 等の階層列)
L18 #   - px: pd.DataFrame   … data['Close'] 相当（終値）
L19 #   - spx: pd.Series     … ベンチマークの終値
L20 #   - tickers_bulk: object         … yfinance.Tickers
L21 #   - info: Dict[str, dict]        … yfinance info per ticker
L22 #   - eps_df: pd.DataFrame         … 必須列: EPS_TTM, EPS_Q_LastQ（旧名も可）
L23 #   - fcf_df: pd.DataFrame         … 必須列: FCF_TTM（旧名も可）
L24 #   - returns: pd.DataFrame        … px[tickers].pct_change() 相当
L25 #
L26 # ※入出力の形式・例外文言は既存実装を変えません（安全な短縮のみ）
L27 # =============================================================================
L28
L29 import logging
L30 import os, sys, warnings
L31 import requests
L32 import numpy as np
L33 import pandas as pd
L34 import yfinance as yf
L35 from typing import Any, TYPE_CHECKING
L36 from scipy.stats import zscore
L37
L38 if TYPE_CHECKING:
L39     from factor import PipelineConfig  # type: ignore  # 実行時importなし（循環回避）
L40
L41 logger = logging.getLogger(__name__)
L42
L43 # ---- Dividend Helpers -------------------------------------------------------
L44 def _last_close(t, price_map=None):
L45     if price_map and (c := price_map.get(t)) is not None: return float(c)
L46     try:
L47         h = yf.Ticker(t).history(period="5d")["Close"].dropna()
L48         return float(h.iloc[-1]) if len(h) else np.nan
L49     except Exception:
L50         return np.nan
L51
L52 def _ttm_div_sum(t, lookback_days=400):
L53     try:
L54         div = yf.Ticker(t).dividends
L55         if div is None or len(div) == 0: return 0.0
L56         cutoff = pd.Timestamp.utcnow().tz_localize(None) - pd.Timedelta(days=lookback_days)
L57         ttm = float(div[div.index.tz_localize(None) >= cutoff].sum())
L58         return ttm if ttm > 0 else float(div.tail(4).sum())
L59     except Exception:
L60         return 0.0
L61
L62 def ttm_div_yield_portfolio(tickers, price_map=None):
L63     ys = [(lambda c, s: (s/c) if (np.isfinite(c) and c>0 and s>0) else 0.0)(_last_close(t, price_map), _ttm_div_sum(t)) for t in tickers]
L64     return float(np.mean(ys)) if ys else 0.0
L65
L66 # ---- 簡易ユーティリティ（安全な短縮のみ） -----------------------------------
L67 def winsorize_s(s: pd.Series, p=0.02):
L68     if s is None or s.dropna().empty: return s
L69     lo, hi = np.nanpercentile(s.astype(float), [100*p, 100*(1-p)]); return s.clip(lo, hi)
L70
L71 def robust_z(s: pd.Series, p=0.02):
L72     s2 = winsorize_s(s,p); return np.nan_to_num(zscore(s2.fillna(s2.mean())))
L73
L74 def robust_z_keepnan(s: pd.Series) -> pd.Series:
L75     """robust_z variant that preserves NaNs and falls back to rank-z when needed."""
L76     if s is None:
L77         return pd.Series(dtype=float)
L78     v = pd.to_numeric(s, errors="coerce")
L79     m = np.nanmedian(v)
L80     mad = np.nanmedian(np.abs(v - m))
L81     z = (v - m) / (1.4826 * mad + 1e-9)
L82     if np.nanstd(z) < 1e-9:
L83         r = v.rank(method="average", na_option="keep")
L84         z = (r - np.nanmean(r)) / (np.nanstd(r) + 1e-9)
L85     return pd.Series(z, index=v.index, dtype=float)
L86
L87
L88 def _dump_dfz(df_z: pd.DataFrame, debug_mode: bool, max_rows: int = 400, ndigits: int = 3) -> None:
L89     """df_z を System log(INFO) へダンプする簡潔なユーティリティ."""
L90     if not debug_mode:
L91         return
L92     try:
L93         view = df_z.copy()
L94         view = view.apply(
L95             lambda s: s.round(ndigits)
L96             if getattr(getattr(s, "dtype", None), "kind", "") in ("f", "i")
L97             else s
L98         )
L99         if len(view) > max_rows:
L100             view = view.iloc[:max_rows]
L101
L102         # === NaNサマリ（列ごとの欠損件数 上位20） ===
L103         try:
L104             nan_counts = df_z.isna().sum().sort_values(ascending=False)
L105             top_nan = nan_counts[nan_counts > 0].head(20)
L106             if len(top_nan) > 0:
L107                 logger.info("NaN columns (top20):\n%s", top_nan.to_string())
L108             else:
L109                 logger.info("NaN columns: none")
L110         except Exception as exc:
L111             logger.warning("nan summary failed: %s", exc)
L112
L113         # === Zeroサマリ（列ごとのゼロ比率 上位20） ===
L114         try:
L115             zero_counts = ((df_z == 0) & (~df_z.isna())).sum()
L116             nonnull_counts = (~df_z.isna()).sum()
L117             zero_ratio = (zero_counts / nonnull_counts).sort_values(ascending=False)
L118             top_zero = zero_ratio[zero_ratio > 0].head(20)
L119             if len(top_zero) > 0:
L120                 logger.info(
L121                     "Zero-dominated columns (top20):\n%s",
L122                     top_zero.to_string(float_format=lambda x: f"{x:.2%}"),
L123                 )
L124             else:
L125                 logger.info("Zero-dominated columns: none")
L126         except Exception as exc:
L127             logger.warning("zero summary failed: %s", exc)
L128
L129         logger.info("===== DF_Z DUMP START =====")
L130         logger.info("\n%s", view.to_string(max_rows=None, max_cols=None))
L131         logger.info("===== DF_Z DUMP END =====")
L132     except Exception as exc:
L133         logger.warning("df_z dump failed: %s", exc)
L134
L135 def _safe_div(a, b):
L136     try: return np.nan if (b is None or float(b)==0 or pd.isna(b)) else float(a)/float(b)
L137     except Exception: return np.nan
L138
L139 def _safe_last(series: pd.Series, default=np.nan):
L140     try: return float(series.iloc[-1])
L141     except Exception: return default
L142
L143 D_WEIGHTS_EFF = None  # 出力表示互換のため
L144
L145
L146 def _scalar(v):
L147     """単一セル代入用に値をスカラーへ正規化する。
L148
L149     - pandas Series -> .iloc[-1]（最後を採用）
L150     - list/tuple/ndarray -> 最後の要素
L151     - それ以外          -> そのまま
L152     取得失敗時は np.nan を返す。
L153     """
L154     import numpy as _np
L155     import pandas as _pd
L156     try:
L157         if isinstance(v, _pd.Series):
L158             return v.iloc[-1] if len(v) else _np.nan
L159         if isinstance(v, (list, tuple, _np.ndarray)):
L160             return v[-1] if len(v) else _np.nan
L161         return v
L162     except Exception:
L163         return _np.nan
L164
L165
L166 # ---- Scorer 本体 -------------------------------------------------------------
L167 class Scorer:
L168     """
L169     - factor.py からは `aggregate_scores(ib, cfg)` を呼ぶだけでOK。
L170     - cfg は必須（factor.PipelineConfig を渡す）。
L171     - 旧カラム名を自動リネームして新スキーマに吸収します。
L172     """
L173
L174     # === 先頭で旧→新カラム名マップ（移行用） ===
L175     EPS_RENAME = {"eps_ttm":"EPS_TTM", "eps_q_recent":"EPS_Q_LastQ"}
L176     FCF_RENAME = {"fcf_ttm":"FCF_TTM"}
L177
L178     # === スキーマ簡易チェック（最低限） ===
L179     @staticmethod
L180     def _validate_ib_for_scorer(ib: Any):
L181         miss = [a for a in ["tickers","bench","data","px","spx","tickers_bulk","info","eps_df","fcf_df","returns"] if not hasattr(ib,a) or getattr(ib,a) is None]
L182         if miss: raise ValueError(f"InputBundle is missing required attributes for Scorer: {miss}")
L183         if any(c in ib.eps_df.columns for c in Scorer.EPS_RENAME): ib.eps_df.rename(columns=Scorer.EPS_RENAME, inplace=True)
L184         if any(c in ib.fcf_df.columns for c in Scorer.FCF_RENAME): ib.fcf_df.rename(columns=Scorer.FCF_RENAME, inplace=True)
L185         need_eps, need_fcf = {"EPS_TTM","EPS_Q_LastQ"},{"FCF_TTM"}
L186         if not need_eps.issubset(ib.eps_df.columns): raise ValueError(f"eps_df must contain columns {need_eps} (accepts old names via auto-rename). Got: {list(ib.eps_df.columns)}")
L187         if not need_fcf.issubset(ib.fcf_df.columns): raise ValueError(f"fcf_df must contain columns {need_fcf} (accepts old names via auto-rename). Got: {list(ib.fcf_df.columns)}")
L188
L189     # ----（Scorer専用）テクニカル・指標系 ----
L190     @staticmethod
L191     def trend(s: pd.Series):
L192         if len(s)<200: return np.nan
L193         sma50, sma150, sma200 = s.rolling(50).mean().iloc[-1], s.rolling(150).mean().iloc[-1], s.rolling(200).mean().iloc[-1]
L194         prev200, p = s.rolling(200).mean().iloc[-21], s.iloc[-1]
L195         lo_52 = s[-252:].min() if len(s)>=252 else s.min(); hi_52 = s[-252:].max() if len(s)>=252 else s.max()
L196         rng = (hi_52 - lo_52) if hi_52>lo_52 else np.nan
L197         clip = lambda x,lo,hi: (np.nan if pd.isna(x) else max(lo,min(hi,x)))
L198         a = clip(p/(s.rolling(50).mean().iloc[-1]) - 1, -0.5, 0.5)
L199         b = clip(sma50/sma150 - 1, -0.5, 0.5)
L200         c = clip(sma150/sma200 - 1, -0.5, 0.5)
L201         d = clip(sma200/prev200 - 1, -0.2, 0.2)
L202         e = clip((p - lo_52) / (rng if rng and rng>0 else np.nan) - 0.5, -0.5, 0.5)
L203         parts = [0.0 if pd.isna(x) else x for x in (a,b,c,d,e)]
L204         return 0.30*parts[0] + 0.20*parts[1] + 0.15*parts[2] + 0.15*parts[3] + 0.20*parts[4]
L205
L206     @staticmethod
L207     def rs(s, b):
L208         n, nb = len(s), len(b)
L209         if n<60 or nb<60: return np.nan
L210         L12 = 252 if n>=252 and nb>=252 else min(n,nb)-1; L1 = 22 if n>=22 and nb>=22 else max(5, min(n,nb)//3)
L211         r12, r1, br12, br1 = s.iloc[-1]/s.iloc[-L12]-1, s.iloc[-1]/s.iloc[-L1]-1, b.iloc[-1]/b.iloc[-L12]-1, b.iloc[-1]/b.iloc[-L1]-1
L212         return (r12 - br12)*0.7 + (r1 - br1)*0.3
L213
L214     @staticmethod
L215     def tr_str(s):
L216         if s is None:
L217             return np.nan
L218         s = s.ffill(limit=2).dropna()
L219         if len(s) < 50:
L220             return np.nan
L221         ma50 = s.rolling(50, min_periods=50).mean()
L222         last_ma = ma50.iloc[-1]
L223         last_px = s.iloc[-1]
L224         return float(last_px/last_ma - 1.0) if pd.notna(last_ma) and pd.notna(last_px) else np.nan
L225
L226     @staticmethod
L227     def rs_line_slope(s: pd.Series, b: pd.Series, win: int) -> float:
L228         r = (s/b).dropna()
L229         if len(r) < win: return np.nan
L230         y, x = np.log(r.iloc[-win:]), np.arange(win, dtype=float)
L231         try: return float(np.polyfit(x, y, 1)[0])
L232         except Exception: return np.nan
L233
L234     @staticmethod
L235     def ev_fallback(info_t: dict, tk: yf.Ticker) -> float:
L236         ev = info_t.get('enterpriseValue', np.nan)
L237         if pd.notna(ev) and ev>0: return float(ev)
L238         mc, debt, cash = info_t.get('marketCap', np.nan), np.nan, np.nan
L239         try:
L240             bs = tk.quarterly_balance_sheet
L241             if bs is not None and not bs.empty:
L242                 c = bs.columns[0]
L243                 for k in ("Total Debt","Long Term Debt","Short Long Term Debt"):
L244                     if k in bs.index: debt =
```