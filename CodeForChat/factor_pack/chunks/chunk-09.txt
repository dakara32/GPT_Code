```text
 def _log(stage, msg):
L45     try:
L46         print(f"[DBG][{_dt.utcnow().isoformat(timespec='seconds')}Z][{stage}] {msg}")
L47     except Exception:
L48         print(f"[DBG][{stage}] {msg}")
L49
L50
L51 # ---- Dividend Helpers -------------------------------------------------------
L52 def _last_close(t, price_map=None):
L53     if price_map and (c := price_map.get(t)) is not None: return float(c)
L54     try:
L55         h = yf.Ticker(t).history(period="5d")["Close"].dropna()
L56         return float(h.iloc[-1]) if len(h) else np.nan
L57     except Exception:
L58         return np.nan
L59
L60 def _ttm_div_sum(t, lookback_days=400):
L61     try:
L62         div = yf.Ticker(t).dividends
L63         if div is None or len(div) == 0: return 0.0
L64         cutoff = pd.Timestamp.utcnow().tz_localize(None) - pd.Timedelta(days=lookback_days)
L65         ttm = float(div[div.index.tz_localize(None) >= cutoff].sum())
L66         return ttm if ttm > 0 else float(div.tail(4).sum())
L67     except Exception:
L68         return 0.0
L69
L70 def ttm_div_yield_portfolio(tickers, price_map=None):
L71     ys = [(lambda c, s: (s/c) if (np.isfinite(c) and c>0 and s>0) else 0.0)(_last_close(t, price_map), _ttm_div_sum(t)) for t in tickers]
L72     return float(np.mean(ys)) if ys else 0.0
L73
L74 # ---- 簡易ユーティリティ（安全な短縮のみ） -----------------------------------
L75 def _as_numeric_series(s: pd.Series) -> pd.Series:
L76     """Series を float dtype に強制変換し、index を保持する。"""
L77     if s is None:
L78         return pd.Series(dtype=float)
L79     v = pd.to_numeric(s, errors="coerce")
L80     return pd.Series(v.values, index=getattr(s, "index", None), dtype=float, name=getattr(s, "name", None))
L81
L82
L83 def _scalar(x):
L84     """
L85     入力を安全に float スカラへ変換する。
L86
L87     許容する入力パターン:
L88       - pandas.Series: 非NaNの最後の値を採用
L89       - numpy スカラ/配列: 最後の要素を採用
L90       - その他の数値っぽい値: float へ変換
L91
L92     変換できない場合は np.nan を返す。
L93     """
L94
L95     if x is None:
L96         return np.nan
L97
L98     # pandas.Series の場合は非NaNの最後の値を採用
L99     if isinstance(x, pd.Series):
L100         s = pd.to_numeric(x, errors="coerce").dropna()
L101         return float(s.iloc[-1]) if not s.empty else np.nan
L102
L103     # numpy スカラ (item() を持つ) ※文字列は除外
L104     if hasattr(x, "item") and not isinstance(x, (str, bytes)):
L105         try:
L106             return float(x.item())
L107         except Exception:
L108             pass
L109
L110     # 配列様のオブジェクト
L111     try:
L112         arr = np.asarray(x, dtype=float).ravel()
L113         return float(arr[-1]) if arr.size else np.nan
L114     except Exception:
L115         pass
L116
L117     # 最後に素直に float 変換を試す
L118     try:
L119         return float(x)
L120     except Exception:
L121         return np.nan
L122
L123
L124 def winsorize_s(s: pd.Series, p=0.02):
L125     if s is None or s.dropna().empty: return s
L126     lo, hi = np.nanpercentile(s.astype(float), [100*p, 100*(1-p)]); return s.clip(lo, hi)
L127
L128 def robust_z(s: pd.Series, p=0.02):
L129     s2 = winsorize_s(s,p); return np.nan_to_num(zscore(s2.fillna(s2.mean())))
L130
L131 def robust_z_keepnan(s: pd.Series) -> pd.Series:
L132     """robust_z variant that preserves NaNs and falls back to rank-z when needed."""
L133     if s is None:
L134         return pd.Series(dtype=float)
L135     v = pd.to_numeric(s, errors="coerce")
L136     m = np.nanmedian(v)
L137     mad = np.nanmedian(np.abs(v - m))
L138     z = (v - m) / (1.4826 * mad + 1e-9)
L139     if np.nanstd(z) < 1e-9:
L140         r = v.rank(method="average", na_option="keep")
L141         z = (r - np.nanmean(r)) / (np.nanstd(r) + 1e-9)
L142     return pd.Series(z, index=v.index, dtype=float)
L143
L144
L145 def _safe_div(a, b):
L146     try: return np.nan if (b is None or float(b)==0 or pd.isna(b)) else float(a)/float(b)
L147     except Exception: return np.nan
L148
L149 def _safe_last(series: pd.Series, default=np.nan):
L150     try: return float(series.iloc[-1])
L151     except Exception: return default
L152
L153
L154 def _ensure_series(x):
L155     if x is None:
L156         return pd.Series(dtype=float)
L157     if isinstance(x, pd.Series):
L158         return x.dropna()
L159     if isinstance(x, (list, tuple)):
L160         if len(x) and isinstance(x[0], (tuple, list)) and len(x[0]) == 2:
L161             dt = pd.to_datetime([d for d, _ in x], errors="coerce")
L162             v = pd.to_numeric([_v for _, _v in x], errors="coerce")
L163             return pd.Series(v, index=dt).dropna()
L164         return pd.Series(pd.to_numeric(list(x), errors="coerce")).dropna()
L165     try:
L166         return pd.Series(x).dropna()
L167     except Exception:
L168         return pd.Series(dtype=float)
L169
L170
L171 def _to_quarterly(s: pd.Series) -> pd.Series:
L172     if s.empty or not isinstance(s.index, pd.DatetimeIndex):
L173         return s
L174     return s.resample("Q").last().dropna()
L175
L176
L177 def _ttm_yoy_from_quarterly(qs: pd.Series) -> pd.Series:
L178     if qs is None or qs.empty:
L179         return pd.Series(dtype=float)
L180     ttm = qs.rolling(4, min_periods=2).sum()
L181     yoy = ttm.pct_change(4)
L182     return yoy
L183
L184
L185
L186
L187 class Scorer:
L188     """
L189     - factor.py からは `aggregate_scores(ib, cfg)` を呼ぶだけでOK。
L190     - cfg は必須（factor.PipelineConfig を渡す）。
L191     - 旧カラム名を自動リネームして新スキーマに吸収します。
L192     """
L193
L194     # === 先頭で旧→新カラム名マップ（移行用） ===
L195     EPS_RENAME = {"eps_ttm":"EPS_TTM", "eps_q_recent":"EPS_Q_LastQ"}
L196     FCF_RENAME = {"fcf_ttm":"FCF_TTM"}
L197
L198     # === スキーマ簡易チェック（最低限） ===
L199     @staticmethod
L200     def _validate_ib_for_scorer(ib: Any):
L201         miss = [a for a in ["tickers","bench","data","px","spx","tickers_bulk","info","eps_df","fcf_df","returns"] if not hasattr(ib,a) or getattr(ib,a) is None]
L202         if miss: raise ValueError(f"InputBundle is missing required attributes for Scorer: {miss}")
L203         if any(c in ib.eps_df.columns for c in Scorer.EPS_RENAME): ib.eps_df.rename(columns=Scorer.EPS_RENAME, inplace=True)
L204         if any(c in ib.fcf_df.columns for c in Scorer.FCF_RENAME): ib.fcf_df.rename(columns=Scorer.FCF_RENAME, inplace=True)
L205         need_eps, need_fcf = {"EPS_TTM","EPS_Q_LastQ"},{"FCF_TTM"}
L206         if not need_eps.issubset(ib.eps_df.columns): raise ValueError(f"eps_df must contain columns {need_eps} (accepts old names via auto-rename). Got: {list(ib.eps_df.columns)}")
L207         if not need_fcf.issubset(ib.fcf_df.columns): raise ValueError(f"fcf_df must contain columns {need_fcf} (accepts old names via auto-rename). Got: {list(ib.fcf_df.columns)}")
L208
L209     # ----（Scorer専用）テクニカル・指標系 ----
L210     @staticmethod
L211     def trend(s: pd.Series):
L212         if len(s)<200: return np.nan
L213         sma50, sma150, sma200 = s.rolling(50).mean().iloc[-1], s.rolling(150).mean().iloc[-1], s.rolling(200).mean().iloc[-1]
L214         prev200, p = s.rolling(200).mean().iloc[-21], s.iloc[-1]
L215         lo_52 = s[-252:].min() if len(s)>=252 else s.min(); hi_52 = s[-252:].max() if len(s)>=252 else s.max()
L216         rng = (hi_52 - lo_52) if hi_52>lo_52 else np.nan
L217         clip = lambda x,lo,hi: (np.nan if pd.isna(x) else max(lo,min(hi,x)))
L218         a = clip(p/(s.rolling(50).mean().iloc[-1]) - 1, -0.5, 0.5)
L219         b = clip(sma50/sma150 - 1, -0.5, 0.5)
L220         c = clip(sma150/sma200 - 1, -0.5, 0.5)
L221         d = clip(sma200/prev200 - 1, -0.2, 0.2)
L222         e = clip((p - lo_52) / (rng if rng and rng>0 else np.nan) - 0.5, -0.5, 0.5)
L223         parts = [0.0 if pd.isna(x) else x for x in (a,b,c,d,e)]
L224         return 0.30*parts[0] + 0.20*parts[1] + 0.15*parts[2] + 0.15*parts[3] + 0.20*parts[4]
L225
L226     @staticmethod
L227     def rs(s, b):
L228         n, nb = len(s), len(b)
L229         if n<60 or nb<60: return np.nan
L230         L12 = 252 if n>=252 and nb>=252 else min(n,nb)-1; L1 = 22 if n>=22 and nb>=22 else max(5, min(n,nb)//3)
L231         r12, r1, br12, br1 = s.iloc[-1]/s.iloc[-L12]-1, s.iloc[-1]/s.iloc[-L1]-1, b.iloc[-1]/b.iloc[-L12]-1, b.iloc[-1]/b.iloc[-L1]-1
L232         return (r12 - br12)*0.7 + (r1 - br1)*0.3
L233
L234     @staticmethod
L235     def tr_str(s):
L236         if s is None:
L237             return np.nan
L238         s = s.ffill(limit=2).dropna()
L239         if len(s) < 50:
L240             return np.nan
L241         ma50 = s.rolling(50, min_periods=50).mean()
L242         last_ma = ma50.iloc[-1]
L243         last_px = s.iloc[-1]
L244         return float(last_px/last_ma - 1.0) if pd.notna(last_ma) and pd.notna(last_px) else np.nan
L245
L246     @staticmethod
L247     def rs_line_slope(s: pd.Series, b: pd.Series, win: int) -> float:
L248         r = (s/b).dropna()
L249         if len(r) < win: return np.nan
L250         y, x = np.log(r.iloc[-win:]), np.arange(win, dtype=float)
L251         try: return float(np.polyfit(x, y, 1)[0])
L252         except Exception: return np.nan
L253
L254     @staticmethod
L255     def ev_fallback(info_t: dict, tk: yf.Ticker) -> float:
L256         ev = info_t.get('enterpriseValue', np.nan)
L257         if pd.notna(ev) and ev>0: return float(ev)
L258         mc, debt, cash = info_t.get('marketCap', np.nan), np.nan, np.nan
L259         try:
L260             bs = tk.quarterly_balance_sheet
L261             if bs is not None and not bs.empty:
L262                 c = bs.columns[0]
L263                 for k in ("Total Debt","Long Term Debt","Short Long Term Debt"):
L264                     if k in bs.index: debt = float(bs.loc[k,c]); break
L265                 for k in ("Cash And Cash Equivalents","Cash And Cash Equivalents And Short Term Investments","Cash"):
L266                     if k in bs.index: cash = float(bs.loc[k,c]); break
L267         except Exception: pass
L268         if pd.notna(mc): return float(mc + (0 if pd.isna(debt) else debt) - (0 if pd.isna(cash) else cash))
L269         return np.nan
L270
L271     @staticmethod
L272     def dividend_status(ticker: str) -> str:
L273         t = yf.Ticker(ticker)
L274         try:
L275             if not t.dividends.empty: return "has"
L276         except Exception: return "unknown"
L277         try:
L278             a = t.actions
L279             if (a is not None and not a.empty and "Stock Splits" in a.columns and a["Stock Splits"].abs().sum()>0): return "none_confident"
L280         except Exception: pass
L281         try:
L282             fi = t.fast_info
L283             if any(getattr(fi,k,None) for k in ("last_dividend_date","dividend_rate","dividend_yield")): return "maybe_missing"
L284         except Exception: pass
L285         return "unknown"
L286
L287     @staticmethod
L288     def div_streak(t):
L289         try:
L290             divs = yf.Ticker(t).dividends.dropna(); ann = divs.groupby(divs.index.year).sum(); ann = ann[ann.index<pd.Timestamp.today().year]
L291             years, streak = sorted(ann.index), 0
L292             for i in range(len(years)-1,0,-1):
L293                 if ann[years[i]] > ann[years[i-1]]: streak += 1
L294                 else: break
L295             return streak
L296         except Exception: return 0
L297
L298     @staticmethod
L299     def fetch_finnhub_metrics(symbol):
L300         api_key = os.environ.get("FINNHUB_API_KEY")
L301         if not api_key: return {}
L302         url, params = "https://finnhub.io/api/v1/stock/metric", {"symbol":symbol,"metric":"all","token":api_key}
L303         try:
L304             r = requests.get(url, params=params, timeout=10); r.raise_for_status(); m = r.json().get("metric",{})
L305             return {'EPS':m.get('epsGrowthTTMYoy'),'REV':m.get('revenueGrowthTTMYoy'),'ROE':m.get('roeTTM'),'BETA':m.get('beta'),'DIV':m.get('dividendYieldIndicatedAnnual'),'FCF':(m.get('freeCashFlowTTM')/m.get('enterpriseValue')) if m.get('freeCashFlowTTM') and m.get('enterpriseValue') else None}
L306         except Exception: return {}
L307
L308     @staticmethod
L309     def calc_beta(series: pd.Series, market: pd.Series, lookback=252
```