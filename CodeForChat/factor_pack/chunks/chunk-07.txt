```text
top_D=top_D,
L1366                 df_full_z=getattr(fb, "df_full_z", None),
L1367                 prev_G=getattr(sc, "_prev_G", exist),
L1368                 prev_D=getattr(sc, "_prev_D", exist),
L1369             )
L1370         except Exception:
L1371             pass
L1372     out.notify_slack()
L1373     sb = SelectionBundle(resG={"tickers": top_G, "avg_res_corr": avgG,
L1374               "sum_score": sumG, "objective": objG},
L1375         resD={"tickers": top_D, "avg_res_corr": avgD,
L1376               "sum_score": sumD, "objective": objD},
L1377         top_G=top_G, top_D=top_D, init_G=top_G, init_D=top_D)
L1378
L1379     # --- Low Score Candidates (GSC+DSC bottom 10) : send before debug dump ---
L1380     try:
L1381         _low_df = (pd.DataFrame({"GSC": fb.g_score, "DSC": fb.d_score_all})
L1382               .assign(G_plus_D=lambda x: x["GSC"] + x["DSC"])
L1383               .sort_values("G_plus_D")
L1384               .head(10)
L1385               .round(3))
L1386         low_msg = "Low Score Candidates (GSC+DSC bottom 10)\n" + _low_df.to_string(index=True, index_names=False)
L1387         _post_slack({"text": f"```{low_msg}```"})
L1388     except Exception as _e:
L1389         _post_slack({"text": f"```Low Score Candidates: 作成失敗: {_e}```"})
L1390
L1391     return sb
L1392
L1393 if __name__ == "__main__":
L1394     run_pipeline()
```

## <scorer.py>
```text
L1 # scorer.py
L2 # kawatest
L3 # =============================================================================
L4 # Scorer: ファクター/指標の生成と合成スコア算出を担う純粋層
L5 #
L6 # 【このファイルだけ読めば分かるポイント】
L7 # - 入力(InputBundle)は「価格/出来高/ベンチ/基本情報/EPS/FCF/リターン」を含むDTO
L8 # - 出力(FeatureBundle)は「raw特徴量 df」「標準化 df_z」「G/D スコア」「欠損ログ」
L9 # - 重み等のコンフィグ(PipelineConfig)は factor から渡す（cfg 必須）
L10 # - 旧カラム名は Scorer 内で自動リネームして受け入れ（後方互換）
L11 #   例) eps_ttm -> EPS_TTM, eps_q_recent -> EPS_Q_LastQ, fcf_ttm -> FCF_TTM
L12 #
L13 # 【I/O契約（Scorerが参照するInputBundleフィールド）】
L14 #   - cand: List[str]    … 候補銘柄（単体実行では未使用）
L15 #   - tickers: List[str] … 対象銘柄リスト
L16 #   - bench: str         … ベンチマークティッカー（例 '^GSPC'）
L17 #   - data: pd.DataFrame … yfinance download結果 ('Close','Volume' 等の階層列)
L18 #   - px: pd.DataFrame   … data['Close'] 相当（終値）
L19 #   - spx: pd.Series     … ベンチマークの終値
L20 #   - tickers_bulk: object         … yfinance.Tickers
L21 #   - info: Dict[str, dict]        … yfinance info per ticker
L22 #   - eps_df: pd.DataFrame         … 必須列: EPS_TTM, EPS_Q_LastQ（旧名も可）
L23 #   - fcf_df: pd.DataFrame         … 必須列: FCF_TTM（旧名も可）
L24 #   - returns: pd.DataFrame        … px[tickers].pct_change() 相当
L25 #
L26 # ※入出力の形式・例外文言は既存実装を変えません（安全な短縮のみ）
L27 # =============================================================================
L28
L29 import json, logging, os, requests, sys, warnings
L30 import numpy as np
L31 import pandas as pd
L32 import yfinance as yf
L33 from typing import Any, TYPE_CHECKING
L34 from scipy.stats import zscore
L35 from datetime import datetime as _dt
L36
L37 if TYPE_CHECKING:
L38     from factor import PipelineConfig  # type: ignore  # 実行時importなし（循環回避）
L39
L40 logger = logging.getLogger(__name__)
L41
L42
L43 def _log(stage, msg):
L44     try:
L45         print(f"[DBG][{_dt.utcnow().isoformat(timespec='seconds')}Z][{stage}] {msg}")
L46     except Exception:
L47         print(f"[DBG][{stage}] {msg}")
L48
L49
L50 # ---- Dividend Helpers -------------------------------------------------------
L51 def _last_close(t, price_map=None):
L52     if price_map and (c := price_map.get(t)) is not None: return float(c)
L53     try:
L54         h = yf.Ticker(t).history(period="5d")["Close"].dropna()
L55         return float(h.iloc[-1]) if len(h) else np.nan
L56     except Exception:
L57         return np.nan
L58
L59 def _ttm_div_sum(t, lookback_days=400):
L60     try:
L61         div = yf.Ticker(t).dividends
L62         if div is None or len(div) == 0: return 0.0
L63         cutoff = pd.Timestamp.utcnow().tz_localize(None) - pd.Timedelta(days=lookback_days)
L64         ttm = float(div[div.index.tz_localize(None) >= cutoff].sum())
L65         return ttm if ttm > 0 else float(div.tail(4).sum())
L66     except Exception:
L67         return 0.0
L68
L69 def ttm_div_yield_portfolio(tickers, price_map=None):
L70     ys = [(lambda c, s: (s/c) if (np.isfinite(c) and c>0 and s>0) else 0.0)(_last_close(t, price_map), _ttm_div_sum(t)) for t in tickers]
L71     return float(np.mean(ys)) if ys else 0.0
L72
L73 # ---- 簡易ユーティリティ（安全な短縮のみ） -----------------------------------
L74 def winsorize_s(s: pd.Series, p=0.02):
L75     if s is None or s.dropna().empty: return s
L76     lo, hi = np.nanpercentile(s.astype(float), [100*p, 100*(1-p)]); return s.clip(lo, hi)
L77
L78 def robust_z(s: pd.Series, p=0.02):
L79     s2 = winsorize_s(s,p); return np.nan_to_num(zscore(s2.fillna(s2.mean())))
L80
L81 def robust_z_keepnan(s: pd.Series) -> pd.Series:
L82     """robust_z variant that preserves NaNs and falls back to rank-z when needed."""
L83     if s is None:
L84         return pd.Series(dtype=float)
L85     v = pd.to_numeric(s, errors="coerce")
L86     m = np.nanmedian(v)
L87     mad = np.nanmedian(np.abs(v - m))
L88     z = (v - m) / (1.4826 * mad + 1e-9)
L89     if np.nanstd(z) < 1e-9:
L90         r = v.rank(method="average", na_option="keep")
L91         z = (r - np.nanmean(r)) / (np.nanstd(r) + 1e-9)
L92     return pd.Series(z, index=v.index, dtype=float)
L93
L94
L95 def _safe_div(a, b):
L96     try: return np.nan if (b is None or float(b)==0 or pd.isna(b)) else float(a)/float(b)
L97     except Exception: return np.nan
L98
L99 def _safe_last(series: pd.Series, default=np.nan):
L100     try: return float(series.iloc[-1])
L101     except Exception: return default
L102
L103
L104 def _ensure_series(x):
L105     if x is None:
L106         return pd.Series(dtype=float)
L107     if isinstance(x, pd.Series):
L108         return x.dropna()
L109     if isinstance(x, (list, tuple)):
L110         if len(x) and isinstance(x[0], (tuple, list)) and len(x[0]) == 2:
L111             dt = pd.to_datetime([d for d, _ in x], errors="coerce")
L112             v = pd.to_numeric([_v for _, _v in x], errors="coerce")
L113             return pd.Series(v, index=dt).dropna()
L114         return pd.Series(pd.to_numeric(list(x), errors="coerce")).dropna()
L115     try:
L116         return pd.Series(x).dropna()
L117     except Exception:
L118         return pd.Series(dtype=float)
L119
L120
L121 def _to_quarterly(s: pd.Series) -> pd.Series:
L122     if s.empty or not isinstance(s.index, pd.DatetimeIndex):
L123         return s
L124     return s.resample("Q").last().dropna()
L125
L126
L127 def _ttm_yoy_from_quarterly(qs: pd.Series) -> pd.Series:
L128     if qs is None or qs.empty:
L129         return pd.Series(dtype=float)
L130     ttm = qs.rolling(4, min_periods=2).sum()
L131     yoy = ttm.pct_change(4)
L132     return yoy
L133
L134
L135 def _nz(x) -> float:
L136     if x is None:
L137         return 0.0
L138     try:
L139         value = float(x)
L140     except Exception:
L141         return 0.0
L142     if not np.isfinite(value):
L143         return 0.0
L144     return value
L145
L146
L147 def _winsor(x, lo=-2.0, hi=2.0) -> float:
L148     v = _nz(x)
L149     if v < lo:
L150         return float(lo)
L151     if v > hi:
L152         return float(hi)
L153     return float(v)
L154
L155
L156 def _round_debug(x, ndigits: int = 4):
L157     try:
L158         value = float(x)
L159     except Exception:
L160         return None
L161     if not np.isfinite(value):
L162         return None
L163     return round(value, ndigits)
L164
L165
L166 def _calc_grw_flexible(
L167     ticker: str,
L168     info_entry: dict | None,
L169     close_series: pd.Series | None,
L170     volume_series: pd.Series | None,
L171 ):
L172     info_entry = info_entry if isinstance(info_entry, dict) else {}
L173
L174     s_rev_q = _ensure_series(info_entry.get("SEC_REV_Q_SERIES"))
L175     s_eps_q = _ensure_series(info_entry.get("SEC_EPS_Q_SERIES"))
L176     s_rev_y = _ensure_series(info_entry.get("SEC_REV_Y_SERIES"))
L177
L178     nQ = int(getattr(s_rev_q, "size", 0))
L179     nY = int(getattr(s_rev_y, "size", 0))
L180
L181     parts: dict[str, Any] = {"nQ": nQ, "nY": nY}
L182     path = "NONE"
L183     w = 0.0
L184
L185     def _valid_ratio(a, b):
L186         try:
L187             na, nb = float(a), float(b)
L188         except Exception:
L189             return None
L190         if not np.isfinite(na) or not np.isfinite(nb) or nb == 0:
L191             return None
L192         return na, nb
L193
L194     def yoy_q(series: pd.Series) -> float | None:
L195         s = _ensure_series(series)
L196         if s.empty:
L197             return None
L198         s = s.sort_index()
L199         if isinstance(s.index, pd.DatetimeIndex):
L200             last_idx = s.index[-1]
L201             window_start = last_idx - pd.DateOffset(months=15)
L202             window_end = last_idx - pd.DateOffset(months=9)
L203             candidates = s.loc[(s.index >= window_start) & (s.index <= window_end)]
L204             if candidates.empty:
L205                 candidates = s.loc[s.index <= window_end]
L206             if candidates.empty:
L207                 return None
L208             v1 = candidates.iloc[-1]
L209             v0 = s.iloc[-1]
L210         else:
L211             if s.size < 5:
L212                 return None
L213             v0 = s.iloc[-1]
L214             v1 = s.iloc[-5]
L215         pair = _valid_ratio(v0, v1)
L216         if pair is None:
L217             return None
L218         a, b = pair
L219         return float(a / b - 1.0)
L220
L221     def qoq(series: pd.Series) -> float | None:
L222         s = _ensure_series(series)
L223         if s.size < 2:
L224             return None
L225         s = s.sort_index()
L226         v0, v1 = s.iloc[-1], s.iloc[-2]
L227         pair = _valid_ratio(v0, v1)
L228         if pair is None:
L229             return None
L230         a, b = pair
L231         return float(a / b - 1.0)
L232
L233     def ttm_delta(series: pd.Series) -> float | None:
L234         s = _ensure_series(series)
L235         if s.size < 2:
L236             return None
L237         s = s.sort_index()
L238         k = int(min(4, s.size))
L239         cur_slice = s.iloc[-k:]
L240         prev_slice = s.iloc[:-k]
L241         if prev_slice.empty:
L242             return None
L243         prev_k = int(min(k, prev_slice.size))
L244         cur_sum = float(cur_slice.sum())
L245         prev_sum = float(prev_slice.iloc[-prev_k:].sum())
L246         pair = _valid_ratio(cur_sum, prev_sum)
L247         if pair is None:
L248             return None
L249         a, b = pair
L250         return float(a / b - 1.0)
L251
L252     def yoy_y(series: pd.Series) -> float | None:
L253         s = _ensure_series(series)
L254         if s.size < 2:
L255             return None
L256         s = s.sort_index()
L257         v0, v1 = s.iloc[-1], s.iloc[-2]
L258         pair = _valid_ratio(v0, v1)
L259         if pair is None:
L260             return None
L261         a, b = pair
L262         return float(a / b - 1.0)
L263
L264     def price_proxy_growth() -> float | None:
L265         if not isinstance(close_series, pd.Series):
L266             return None
L267         close = close_series.sort_index().dropna()
L268         if close.empty:
L269             return None
L270         hh_window = int(min(126, len(close)))
L271         if hh_window < 20:
L272             return None
L273         hh = close.rolling(hh_window).max().iloc[-1]
L274         prox = None
L275         if np.isfinite(hh) and hh > 0:
L276             prox = float(close.iloc[-1] / hh)
L277         rs6 = None
L278         if len(close) >= 63:
L279             rs6 = float(close.pct_change(63).iloc[-1])
L280         rs12 = None
L281         if len(close) >= 126:
L282             rs12 = float(close.pct_change(126).iloc[-1])
L283         vexp = None
L284         if isinstance(volume_series, pd.Series):
L285             vol = volume_series.reindex(close.index).dropna()
L286             if le
```