```text
n 0.0
L65         cutoff = pd.Timestamp.utcnow().tz_localize(None) - pd.Timedelta(days=lookback_days)
L66         ttm = float(div[div.index.tz_localize(None) >= cutoff].sum())
L67         return ttm if ttm > 0 else float(div.tail(4).sum())
L68     except Exception:
L69         return 0.0
L70
L71 def ttm_div_yield_portfolio(tickers, price_map=None):
L72     ys = [(lambda c, s: (s/c) if (np.isfinite(c) and c>0 and s>0) else 0.0)(_last_close(t, price_map), _ttm_div_sum(t)) for t in tickers]
L73     return float(np.mean(ys)) if ys else 0.0
L74
L75 # ---- 簡易ユーティリティ（安全な短縮のみ） -----------------------------------
L76 def winsorize_s(s: pd.Series, p=0.02):
L77     if s is None or s.dropna().empty: return s
L78     lo, hi = np.nanpercentile(s.astype(float), [100*p, 100*(1-p)]); return s.clip(lo, hi)
L79
L80 def robust_z(s: pd.Series, p=0.02):
L81     s2 = winsorize_s(s,p); return np.nan_to_num(zscore(s2.fillna(s2.mean())))
L82
L83 def robust_z_keepnan(s: pd.Series) -> pd.Series:
L84     """robust_z variant that preserves NaNs and falls back to rank-z when needed."""
L85     if s is None:
L86         return pd.Series(dtype=float)
L87     v = pd.to_numeric(s, errors="coerce")
L88     m = np.nanmedian(v)
L89     mad = np.nanmedian(np.abs(v - m))
L90     z = (v - m) / (1.4826 * mad + 1e-9)
L91     if np.nanstd(z) < 1e-9:
L92         r = v.rank(method="average", na_option="keep")
L93         z = (r - np.nanmean(r)) / (np.nanstd(r) + 1e-9)
L94     return pd.Series(z, index=v.index, dtype=float)
L95
L96
L97 def _dump_dfz(df_z: pd.DataFrame, debug_mode: bool, max_rows: int = 400, ndigits: int = 3) -> None:
L98     """df_z を System log(INFO) へダンプする簡潔なユーティリティ."""
L99     if not debug_mode:
L100         return
L101     try:
L102         view = df_z.copy()
L103         view = view.apply(
L104             lambda s: s.round(ndigits)
L105             if getattr(getattr(s, "dtype", None), "kind", "") in ("f", "i")
L106             else s
L107         )
L108         if len(view) > max_rows:
L109             view = view.iloc[:max_rows]
L110
L111         # === NaNサマリ（列ごとの欠損件数 上位20） ===
L112         try:
L113             nan_counts = df_z.isna().sum().sort_values(ascending=False)
L114             top_nan = nan_counts[nan_counts > 0].head(20)
L115             if len(top_nan) > 0:
L116                 logger.info("NaN columns (top20):\n%s", top_nan.to_string())
L117             else:
L118                 logger.info("NaN columns: none")
L119         except Exception as exc:
L120             logger.warning("nan summary failed: %s", exc)
L121
L122         # === Zeroサマリ（列ごとのゼロ比率 上位20） ===
L123         try:
L124             zero_counts = ((df_z == 0) & (~df_z.isna())).sum()
L125             nonnull_counts = (~df_z.isna()).sum()
L126             zero_ratio = (zero_counts / nonnull_counts).sort_values(ascending=False)
L127             top_zero = zero_ratio[zero_ratio > 0].head(20)
L128             if len(top_zero) > 0:
L129                 logger.info(
L130                     "Zero-dominated columns (top20):\n%s",
L131                     top_zero.to_string(float_format=lambda x: f"{x:.2%}"),
L132                 )
L133             else:
L134                 logger.info("Zero-dominated columns: none")
L135         except Exception as exc:
L136             logger.warning("zero summary failed: %s", exc)
L137
L138         logger.info("===== DF_Z DUMP START =====")
L139         logger.info("\n%s", view.to_string(max_rows=None, max_cols=None))
L140         logger.info("===== DF_Z DUMP END =====")
L141     except Exception as exc:
L142         logger.warning("df_z dump failed: %s", exc)
L143
L144 def _safe_div(a, b):
L145     try: return np.nan if (b is None or float(b)==0 or pd.isna(b)) else float(a)/float(b)
L146     except Exception: return np.nan
L147
L148 def _safe_last(series: pd.Series, default=np.nan):
L149     try: return float(series.iloc[-1])
L150     except Exception: return default
L151
L152
L153 def _ensure_series(x):
L154     if x is None:
L155         return pd.Series(dtype=float)
L156     if isinstance(x, pd.Series):
L157         return x.dropna()
L158     if isinstance(x, (list, tuple)):
L159         if len(x) and isinstance(x[0], (tuple, list)) and len(x[0]) == 2:
L160             dt = pd.to_datetime([d for d, _ in x], errors="coerce")
L161             v = pd.to_numeric([_v for _, _v in x], errors="coerce")
L162             return pd.Series(v, index=dt).dropna()
L163         return pd.Series(pd.to_numeric(list(x), errors="coerce")).dropna()
L164     try:
L165         return pd.Series(x).dropna()
L166     except Exception:
L167         return pd.Series(dtype=float)
L168
L169
L170 def _to_quarterly(s: pd.Series) -> pd.Series:
L171     if s.empty or not isinstance(s.index, pd.DatetimeIndex):
L172         return s
L173     return s.resample("Q").last().dropna()
L174
L175
L176 def _ttm_yoy_from_quarterly(qs: pd.Series) -> pd.Series:
L177     if qs is None or qs.empty:
L178         return pd.Series(dtype=float)
L179     ttm = qs.rolling(4, min_periods=2).sum()
L180     yoy = ttm.pct_change(4)
L181     return yoy
L182
L183
L184 def _nz(x) -> float:
L185     if x is None:
L186         return 0.0
L187     try:
L188         value = float(x)
L189     except Exception:
L190         return 0.0
L191     if not np.isfinite(value):
L192         return 0.0
L193     return value
L194
L195
L196 def _winsor(x, lo=-2.0, hi=2.0) -> float:
L197     v = _nz(x)
L198     if v < lo:
L199         return float(lo)
L200     if v > hi:
L201         return float(hi)
L202     return float(v)
L203
L204
L205 def _round_debug(x, ndigits: int = 4):
L206     try:
L207         value = float(x)
L208     except Exception:
L209         return None
L210     if not np.isfinite(value):
L211         return None
L212     return round(value, ndigits)
L213
L214
L215 def _calc_grw_flexible(
L216     ticker: str,
L217     info_entry: dict | None,
L218     close_series: pd.Series | None,
L219     volume_series: pd.Series | None,
L220 ):
L221     info_entry = info_entry if isinstance(info_entry, dict) else {}
L222
L223     s_rev_q = _ensure_series(info_entry.get("SEC_REV_Q_SERIES"))
L224     s_eps_q = _ensure_series(info_entry.get("SEC_EPS_Q_SERIES"))
L225     s_rev_y = _ensure_series(info_entry.get("SEC_REV_Y_SERIES"))
L226
L227     nQ = int(getattr(s_rev_q, "size", 0))
L228     nY = int(getattr(s_rev_y, "size", 0))
L229
L230     parts: dict[str, Any] = {"nQ": nQ, "nY": nY}
L231     path = "NONE"
L232     w = 0.0
L233
L234     def _valid_ratio(a, b):
L235         try:
L236             na, nb = float(a), float(b)
L237         except Exception:
L238             return None
L239         if not np.isfinite(na) or not np.isfinite(nb) or nb == 0:
L240             return None
L241         return na, nb
L242
L243     def yoy_q(series: pd.Series) -> float | None:
L244         s = _ensure_series(series)
L245         if s.empty:
L246             return None
L247         s = s.sort_index()
L248         if isinstance(s.index, pd.DatetimeIndex):
L249             last_idx = s.index[-1]
L250             window_start = last_idx - pd.DateOffset(months=15)
L251             window_end = last_idx - pd.DateOffset(months=9)
L252             candidates = s.loc[(s.index >= window_start) & (s.index <= window_end)]
L253             if candidates.empty:
L254                 candidates = s.loc[s.index <= window_end]
L255             if candidates.empty:
L256                 return None
L257             v1 = candidates.iloc[-1]
L258             v0 = s.iloc[-1]
L259         else:
L260             if s.size < 5:
L261                 return None
L262             v0 = s.iloc[-1]
L263             v1 = s.iloc[-5]
L264         pair = _valid_ratio(v0, v1)
L265         if pair is None:
L266             return None
L267         a, b = pair
L268         return float(a / b - 1.0)
L269
L270     def qoq(series: pd.Series) -> float | None:
L271         s = _ensure_series(series)
L272         if s.size < 2:
L273             return None
L274         s = s.sort_index()
L275         v0, v1 = s.iloc[-1], s.iloc[-2]
L276         pair = _valid_ratio(v0, v1)
L277         if pair is None:
L278             return None
L279         a, b = pair
L280         return float(a / b - 1.0)
L281
L282     def ttm_delta(series: pd.Series) -> float | None:
L283         s = _ensure_series(series)
L284         if s.size < 2:
L285             return None
L286         s = s.sort_index()
L287         k = int(min(4, s.size))
L288         cur_slice = s.iloc[-k:]
L289         prev_slice = s.iloc[:-k]
L290         if prev_slice.empty:
L291             return None
L292         prev_k = int(min(k, prev_slice.size))
L293         cur_sum = float(cur_slice.sum())
L294         prev_sum = float(prev_slice.iloc[-prev_k:].sum())
L295         pair = _valid_ratio(cur_sum, prev_sum)
L296         if pair is None:
L297             return None
L298         a, b = pair
L299         return float(a / b - 1.0)
L300
L301     def yoy_y(series: pd.Series) -> float | None:
L302         s = _ensure_series(series)
L303         if s.size < 2:
L304             return None
L305         s = s.sort_index()
L306         v0, v1 = s.iloc[-1], s.iloc[-2]
L307         pair = _valid_ratio(v0, v1)
L308         if pair is None:
L309             return None
L310         a, b = pair
L311         return float(a / b - 1.0)
L312
L313     def price_proxy_growth() -> float | None:
L314         if not isinstance(close_series, pd.Series):
L315             return None
L316         close = close_series.sort_index().dropna()
L317         if close.empty:
L318             return None
L319         hh_window = int(min(126, len(close)))
L320         if hh_window < 20:
L321             return None
L322         hh = close.rolling(hh_window).max().iloc[-1]
L323         prox = None
L324         if np.isfinite(hh) and hh > 0:
L325             prox = float(close.iloc[-1] / hh)
L326         rs6 = None
L327         if len(close) >= 63:
L328             rs6 = float(close.pct_change(63).iloc[-1])
L329         rs12 = None
L330         if len(close) >= 126:
L331             rs12 = float(close.pct_change(126).iloc[-1])
L332         vexp = None
L333         if isinstance(volume_series, pd.Series):
L334             vol = volume_series.reindex(close.index).dropna()
L335             if len(vol) >= 50:
L336                 v20 = vol.rolling(20).mean().iloc[-1]
L337                 v50 = vol.rolling(50).mean().iloc[-1]
L338                 if np.isfinite(v20) and np.isfinite(v50) and v50 > 0:
L339                     vexp = float(v20 / v50 - 1.0)
L340         prox = 0.0 if prox is None or not np.isfinite(prox) else prox
L341         rs6 = 0.0 if rs6 is None or not np.isfinite(rs6) else rs6
L342         rs12 = 0.0 if rs12 is None or not np.isfinite(rs12) else rs12
L343         vexp = 0.0 if vexp is None or not np.isfinite(vexp) else vexp
L344         return 0.5 * prox + 0.3 * rs6 + 0.2 * rs12 + 0.2 * vexp
L345
L346     price_alt = price_proxy_growth() or 0.0
L347     core = 0.0
L348     core_raw = 0.0
L349     price_raw = price_alt
L350
L351     if nQ >= 5:
L352         path = "P5"
L353         yq = yoy_q(s_rev_q)
L354         parts["rev_yoy_q"] = yq
L355         tmp_prev = s_rev_q.iloc[:-1] if s_rev_q.size > 1 else s_rev_q
L356         acc = None
L357         if tmp_prev.size >= 5 and yq is not None:
L358             yq_prev = yoy_q(tmp_prev)
L359             if yq_prev is not None:
L360                 acc = float(yq - yq_prev)
L361         parts["rev_acc_q"] = acc
L362         eps_yoy = yoy_q(s_eps_q) if s_eps_q.size >= 5 else None
L363         parts["eps_yoy_q"] = eps_yoy
L364         eps_acc = None
L365         if eps_yoy is not None and s_eps_q.size > 5:
L366             eps_prev = s_eps_q.iloc[:-1]
L367             if eps_prev.size >= 5:
L368                 eps_prev_yoy = yoy_q(eps_prev)
L369                 if eps_prev_yoy is not None:
L370                     eps_acc = float(eps_yoy - eps_prev_yoy)
L371         parts["eps_acc_q"] = eps_acc
L372         w = 1.0
L373         core_raw = 
```