```text
ailed: %s", exc)
L129
L130         logger.info("===== DF_Z DUMP START =====")
L131         logger.info("\n%s", view.to_string(max_rows=None, max_cols=None))
L132         logger.info("===== DF_Z DUMP END =====")
L133     except Exception as exc:
L134         logger.warning("df_z dump failed: %s", exc)
L135
L136 def _safe_div(a, b):
L137     try: return np.nan if (b is None or float(b)==0 or pd.isna(b)) else float(a)/float(b)
L138     except Exception: return np.nan
L139
L140 def _safe_last(series: pd.Series, default=np.nan):
L141     try: return float(series.iloc[-1])
L142     except Exception: return default
L143
L144
L145 def _ensure_series(data) -> pd.Series:
L146     if isinstance(data, pd.Series):
L147         return data.dropna()
L148     if data is None:
L149         return pd.Series(dtype=float)
L150     if isinstance(data, (list, tuple, np.ndarray)):
L151         try:
L152             return pd.Series(list(data), dtype=float).dropna()
L153         except Exception:
L154             return pd.Series(dtype=float)
L155     try:
L156         if hasattr(data, "values") and hasattr(data, "index"):
L157             return pd.Series(data).dropna()
L158     except Exception:
L159         pass
L160     return pd.Series(dtype=float)
L161
L162
L163 def _nz(x) -> float:
L164     if x is None:
L165         return 0.0
L166     try:
L167         value = float(x)
L168     except Exception:
L169         return 0.0
L170     if not np.isfinite(value):
L171         return 0.0
L172     return value
L173
L174
L175 def _winsor(x, lo=-2.0, hi=2.0) -> float:
L176     v = _nz(x)
L177     if v < lo:
L178         return float(lo)
L179     if v > hi:
L180         return float(hi)
L181     return float(v)
L182
L183
L184 def _round_debug(x, ndigits: int = 4):
L185     try:
L186         value = float(x)
L187     except Exception:
L188         return None
L189     if not np.isfinite(value):
L190         return None
L191     return round(value, ndigits)
L192
L193
L194 def _calc_grw_flexible(
L195     ticker: str,
L196     info_entry: dict | None,
L197     close_series: pd.Series | None,
L198     volume_series: pd.Series | None,
L199 ):
L200     info_entry = info_entry if isinstance(info_entry, dict) else {}
L201
L202     s_rev_q = _ensure_series(info_entry.get("SEC_REV_Q_SERIES"))
L203     s_eps_q = _ensure_series(info_entry.get("SEC_EPS_Q_SERIES"))
L204     s_rev_y = _ensure_series(info_entry.get("SEC_REV_Y_SERIES"))
L205
L206     nQ = int(getattr(s_rev_q, "size", 0))
L207     nY = int(getattr(s_rev_y, "size", 0))
L208
L209     parts: dict[str, Any] = {"nQ": nQ, "nY": nY}
L210     path = "NONE"
L211     w = 0.0
L212
L213     def _valid_ratio(a, b):
L214         try:
L215             na, nb = float(a), float(b)
L216         except Exception:
L217             return None
L218         if not np.isfinite(na) or not np.isfinite(nb) or nb == 0:
L219             return None
L220         return na, nb
L221
L222     def yoy_q(series: pd.Series) -> float | None:
L223         s = _ensure_series(series)
L224         if s.empty:
L225             return None
L226         s = s.sort_index()
L227         if isinstance(s.index, pd.DatetimeIndex):
L228             last_idx = s.index[-1]
L229             window_start = last_idx - pd.DateOffset(months=15)
L230             window_end = last_idx - pd.DateOffset(months=9)
L231             candidates = s.loc[(s.index >= window_start) & (s.index <= window_end)]
L232             if candidates.empty:
L233                 candidates = s.loc[s.index <= window_end]
L234             if candidates.empty:
L235                 return None
L236             v1 = candidates.iloc[-1]
L237             v0 = s.iloc[-1]
L238         else:
L239             if s.size < 5:
L240                 return None
L241             v0 = s.iloc[-1]
L242             v1 = s.iloc[-5]
L243         pair = _valid_ratio(v0, v1)
L244         if pair is None:
L245             return None
L246         a, b = pair
L247         return float(a / b - 1.0)
L248
L249     def qoq(series: pd.Series) -> float | None:
L250         s = _ensure_series(series)
L251         if s.size < 2:
L252             return None
L253         s = s.sort_index()
L254         v0, v1 = s.iloc[-1], s.iloc[-2]
L255         pair = _valid_ratio(v0, v1)
L256         if pair is None:
L257             return None
L258         a, b = pair
L259         return float(a / b - 1.0)
L260
L261     def ttm_delta(series: pd.Series) -> float | None:
L262         s = _ensure_series(series)
L263         if s.size < 2:
L264             return None
L265         s = s.sort_index()
L266         k = int(min(4, s.size))
L267         cur_slice = s.iloc[-k:]
L268         prev_slice = s.iloc[:-k]
L269         if prev_slice.empty:
L270             return None
L271         prev_k = int(min(k, prev_slice.size))
L272         cur_sum = float(cur_slice.sum())
L273         prev_sum = float(prev_slice.iloc[-prev_k:].sum())
L274         pair = _valid_ratio(cur_sum, prev_sum)
L275         if pair is None:
L276             return None
L277         a, b = pair
L278         return float(a / b - 1.0)
L279
L280     def yoy_y(series: pd.Series) -> float | None:
L281         s = _ensure_series(series)
L282         if s.size < 2:
L283             return None
L284         s = s.sort_index()
L285         v0, v1 = s.iloc[-1], s.iloc[-2]
L286         pair = _valid_ratio(v0, v1)
L287         if pair is None:
L288             return None
L289         a, b = pair
L290         return float(a / b - 1.0)
L291
L292     def price_proxy_growth() -> float | None:
L293         if not isinstance(close_series, pd.Series):
L294             return None
L295         close = close_series.sort_index().dropna()
L296         if close.empty:
L297             return None
L298         hh_window = int(min(126, len(close)))
L299         if hh_window < 20:
L300             return None
L301         hh = close.rolling(hh_window).max().iloc[-1]
L302         prox = None
L303         if np.isfinite(hh) and hh > 0:
L304             prox = float(close.iloc[-1] / hh)
L305         rs6 = None
L306         if len(close) >= 63:
L307             rs6 = float(close.pct_change(63).iloc[-1])
L308         rs12 = None
L309         if len(close) >= 126:
L310             rs12 = float(close.pct_change(126).iloc[-1])
L311         vexp = None
L312         if isinstance(volume_series, pd.Series):
L313             vol = volume_series.reindex(close.index).dropna()
L314             if len(vol) >= 50:
L315                 v20 = vol.rolling(20).mean().iloc[-1]
L316                 v50 = vol.rolling(50).mean().iloc[-1]
L317                 if np.isfinite(v20) and np.isfinite(v50) and v50 > 0:
L318                     vexp = float(v20 / v50 - 1.0)
L319         prox = 0.0 if prox is None or not np.isfinite(prox) else prox
L320         rs6 = 0.0 if rs6 is None or not np.isfinite(rs6) else rs6
L321         rs12 = 0.0 if rs12 is None or not np.isfinite(rs12) else rs12
L322         vexp = 0.0 if vexp is None or not np.isfinite(vexp) else vexp
L323         return 0.5 * prox + 0.3 * rs6 + 0.2 * rs12 + 0.2 * vexp
L324
L325     price_alt = price_proxy_growth() or 0.0
L326     core = 0.0
L327     core_raw = 0.0
L328     price_raw = price_alt
L329
L330     if nQ >= 5:
L331         path = "P5"
L332         yq = yoy_q(s_rev_q)
L333         parts["rev_yoy_q"] = yq
L334         tmp_prev = s_rev_q.iloc[:-1] if s_rev_q.size > 1 else s_rev_q
L335         acc = None
L336         if tmp_prev.size >= 5 and yq is not None:
L337             yq_prev = yoy_q(tmp_prev)
L338             if yq_prev is not None:
L339                 acc = float(yq - yq_prev)
L340         parts["rev_acc_q"] = acc
L341         eps_yoy = yoy_q(s_eps_q) if s_eps_q.size >= 5 else None
L342         parts["eps_yoy_q"] = eps_yoy
L343         eps_acc = None
L344         if eps_yoy is not None and s_eps_q.size > 5:
L345             eps_prev = s_eps_q.iloc[:-1]
L346             if eps_prev.size >= 5:
L347                 eps_prev_yoy = yoy_q(eps_prev)
L348                 if eps_prev_yoy is not None:
L349                     eps_acc = float(eps_yoy - eps_prev_yoy)
L350         parts["eps_acc_q"] = eps_acc
L351         w = 1.0
L352         core_raw = (
L353             0.60 * _nz(yq)
L354             + 0.20 * _nz(acc)
L355             + 0.15 * _nz(eps_yoy)
L356             + 0.05 * _nz(eps_acc)
L357         )
L358         price_alt = 0.0
L359     elif 2 <= nQ <= 4:
L360         path = "P24"
L361         rev_qoq = qoq(s_rev_q)
L362         rev_ttm2 = ttm_delta(s_rev_q)
L363         parts["rev_qoq"] = rev_qoq
L364         parts["rev_ttm2"] = rev_ttm2
L365         eps_qoq = qoq(s_eps_q) if s_eps_q.size >= 2 else None
L366         parts["eps_qoq"] = eps_qoq
L367         w = min(1.0, nQ / 5.0)
L368         core_raw = 0.6 * _nz(rev_qoq) + 0.3 * _nz(rev_ttm2) + 0.1 * _nz(eps_qoq)
L369     else:
L370         path = "P1Y"
L371         rev_yoy_y = yoy_y(s_rev_y) if nY >= 2 else None
L372         parts["rev_yoy_y"] = rev_yoy_y
L373         w = 0.6 * min(1.0, nY / 3.0) if nY >= 2 else 0.4
L374         core_raw = _nz(rev_yoy_y)
L375         if nQ <= 1 and nY < 2 and price_alt == 0.0:
L376             price_alt = price_proxy_growth() or 0.0
L377
L378     core = _winsor(core_raw, lo=-1.5, hi=1.5)
L379     price_alt = _winsor(price_alt, lo=-1.5, hi=1.5)
L380     grw = _winsor(w * core + (1.0 - w) * (0.5 * _nz(price_alt)), lo=-2.0, hi=2.0)
L381
L382     parts.update(
L383         {
L384             "core_raw": core_raw,
L385             "core": core,
L386             "price_proxy_raw": price_raw,
L387             "price_proxy": price_alt,
L388             "weight": w,
L389             "score": grw,
L390         }
L391     )
L392
L393     parts_out: dict[str, Any] = {
L394         "nQ": nQ,
L395         "nY": nY,
L396     }
L397     for key, value in parts.items():
L398         if key in ("nQ", "nY"):
L399             continue
L400         rounded = _round_debug(value)
L401         parts_out[key] = rounded
L402
L403     info_entry["DEBUG_GRW_PATH"] = path
L404     info_entry["DEBUG_GRW_PARTS"] = json.dumps(parts_out, ensure_ascii=False, sort_keys=True)
L405     info_entry["GRW_SCORE"] = grw
L406     info_entry["GRW_WEIGHT"] = w
L407     info_entry["GRW_CORE"] = core
L408     info_entry["GRW_PRICE_PROXY"] = price_alt
L409
L410     return {
L411         "score": grw,
L412         "path": path,
L413         "parts": info_entry["DEBUG_GRW_PARTS"],
L414         "weight": w,
L415         "core": core,
L416         "price_proxy": price_alt,
L417     }
L418
L419
L420 D_WEIGHTS_EFF = None  # 出力表示互換のため
L421
L422
L423 def _scalar(v):
L424     """単一セル代入用に値をスカラーへ正規化する。
L425
L426     - pandas Series -> .iloc[-1]（最後を採用）
L427     - list/tuple/ndarray -> 最後の要素
L428     - それ以外          -> そのまま
L429     取得失敗時は np.nan を返す。
L430     """
L431     import numpy as _np
L432     import pandas as _pd
L433     try:
L434         if isinstance(v, _pd.Series):
L435             return v.iloc[-1] if len(v) else _np.nan
L436         if isinstance(v, (list, tuple, _np.ndarray)):
L437             return v[-1] if len(v) else _np.nan
L438         return v
L439     except Exception:
L440         return _np.nan
L441
L442
L443 # ---- Scorer 本体 -------------------------------------------------------------
L444 class Scorer:
L445     """
L446     - factor.py からは `aggregate_scores(ib, cfg)` を呼ぶだけでOK。
L447     - cfg は必須（factor.PipelineConfig を渡す）。
L448     - 旧カラム名を自動リネームして新スキーマに吸収します。
L449     """
L450
L451     # === 先頭で旧→新カラム名マップ（移行用） ===
L452     EPS_RENAME = {"eps_ttm":"EPS_TTM", "eps_q_recent":"EPS_Q_LastQ"}
L453     FCF_RENAME = {"fcf_ttm":"FCF_TTM"}
L454
L455     # === スキーマ簡易チェック（最低限） ===
L456     @staticmethod
L457     def _validate_ib_for_scorer(ib: Any):
L458         miss = [a for a in ["tickers","bench","data","px","spx","tickers_bulk","info","eps_df","fcf_df","returns"] if not hasattr(ib,a) or getattr(ib,a) is None]
L459         if miss: raise ValueError(f"InputBundle is missing required attributes for Scorer: {miss}")
L460         if any(c in ib.eps_df.
```