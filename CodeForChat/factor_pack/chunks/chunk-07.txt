```text
iv_sum(t)) for t in tickers]
L71     return float(np.mean(ys)) if ys else 0.0
L72
L73 # ---- 簡易ユーティリティ（安全な短縮のみ） -----------------------------------
L74 def winsorize_s(s: pd.Series, p=0.02):
L75     if s is None or s.dropna().empty: return s
L76     lo, hi = np.nanpercentile(s.astype(float), [100*p, 100*(1-p)]); return s.clip(lo, hi)
L77
L78 def robust_z(s: pd.Series, p=0.02):
L79     s2 = winsorize_s(s,p); return np.nan_to_num(zscore(s2.fillna(s2.mean())))
L80
L81 def robust_z_keepnan(s: pd.Series) -> pd.Series:
L82     """robust_z variant that preserves NaNs and falls back to rank-z when needed."""
L83     if s is None:
L84         return pd.Series(dtype=float)
L85     v = pd.to_numeric(s, errors="coerce")
L86     m = np.nanmedian(v)
L87     mad = np.nanmedian(np.abs(v - m))
L88     z = (v - m) / (1.4826 * mad + 1e-9)
L89     if np.nanstd(z) < 1e-9:
L90         r = v.rank(method="average", na_option="keep")
L91         z = (r - np.nanmean(r)) / (np.nanstd(r) + 1e-9)
L92     return pd.Series(z, index=v.index, dtype=float)
L93
L94
L95 def _safe_div(a, b):
L96     try: return np.nan if (b is None or float(b)==0 or pd.isna(b)) else float(a)/float(b)
L97     except Exception: return np.nan
L98
L99 def _safe_last(series: pd.Series, default=np.nan):
L100     try: return float(series.iloc[-1])
L101     except Exception: return default
L102
L103
L104 def _ensure_series(x):
L105     if x is None:
L106         return pd.Series(dtype=float)
L107     if isinstance(x, pd.Series):
L108         return x.dropna()
L109     if isinstance(x, (list, tuple)):
L110         if len(x) and isinstance(x[0], (tuple, list)) and len(x[0]) == 2:
L111             dt = pd.to_datetime([d for d, _ in x], errors="coerce")
L112             v = pd.to_numeric([_v for _, _v in x], errors="coerce")
L113             return pd.Series(v, index=dt).dropna()
L114         return pd.Series(pd.to_numeric(list(x), errors="coerce")).dropna()
L115     try:
L116         return pd.Series(x).dropna()
L117     except Exception:
L118         return pd.Series(dtype=float)
L119
L120
L121 def _to_quarterly(s: pd.Series) -> pd.Series:
L122     if s.empty or not isinstance(s.index, pd.DatetimeIndex):
L123         return s
L124     return s.resample("Q").last().dropna()
L125
L126
L127 def _ttm_yoy_from_quarterly(qs: pd.Series) -> pd.Series:
L128     if qs is None or qs.empty:
L129         return pd.Series(dtype=float)
L130     ttm = qs.rolling(4, min_periods=2).sum()
L131     yoy = ttm.pct_change(4)
L132     return yoy
L133
L134
L135 def _nz(x) -> float:
L136     if x is None:
L137         return 0.0
L138     try:
L139         value = float(x)
L140     except Exception:
L141         return 0.0
L142     if not np.isfinite(value):
L143         return 0.0
L144     return value
L145
L146
L147 def _winsor(x, lo=-2.0, hi=2.0) -> float:
L148     v = _nz(x)
L149     if v < lo:
L150         return float(lo)
L151     if v > hi:
L152         return float(hi)
L153     return float(v)
L154
L155
L156 def _round_debug(x, ndigits: int = 4):
L157     try:
L158         value = float(x)
L159     except Exception:
L160         return None
L161     if not np.isfinite(value):
L162         return None
L163     return round(value, ndigits)
L164
L165
L166 def _calc_grw_flexible(
L167     ticker: str,
L168     info_entry: dict | None,
L169     close_series: pd.Series | None,
L170     volume_series: pd.Series | None,
L171 ):
L172     info_entry = info_entry if isinstance(info_entry, dict) else {}
L173
L174     s_rev_q = _ensure_series(info_entry.get("SEC_REV_Q_SERIES"))
L175     s_eps_q = _ensure_series(info_entry.get("SEC_EPS_Q_SERIES"))
L176     s_rev_y = _ensure_series(info_entry.get("SEC_REV_Y_SERIES"))
L177
L178     nQ = int(getattr(s_rev_q, "size", 0))
L179     nY = int(getattr(s_rev_y, "size", 0))
L180
L181     parts: dict[str, Any] = {"nQ": nQ, "nY": nY}
L182     path = "NONE"
L183     w = 0.0
L184
L185     def _valid_ratio(a, b):
L186         try:
L187             na, nb = float(a), float(b)
L188         except Exception:
L189             return None
L190         if not np.isfinite(na) or not np.isfinite(nb) or nb == 0:
L191             return None
L192         return na, nb
L193
L194     def yoy_q(series: pd.Series) -> float | None:
L195         s = _ensure_series(series)
L196         if s.empty:
L197             return None
L198         s = s.sort_index()
L199         if isinstance(s.index, pd.DatetimeIndex):
L200             last_idx = s.index[-1]
L201             window_start = last_idx - pd.DateOffset(months=15)
L202             window_end = last_idx - pd.DateOffset(months=9)
L203             candidates = s.loc[(s.index >= window_start) & (s.index <= window_end)]
L204             if candidates.empty:
L205                 candidates = s.loc[s.index <= window_end]
L206             if candidates.empty:
L207                 return None
L208             v1 = candidates.iloc[-1]
L209             v0 = s.iloc[-1]
L210         else:
L211             if s.size < 5:
L212                 return None
L213             v0 = s.iloc[-1]
L214             v1 = s.iloc[-5]
L215         pair = _valid_ratio(v0, v1)
L216         if pair is None:
L217             return None
L218         a, b = pair
L219         return float(a / b - 1.0)
L220
L221     def qoq(series: pd.Series) -> float | None:
L222         s = _ensure_series(series)
L223         if s.size < 2:
L224             return None
L225         s = s.sort_index()
L226         v0, v1 = s.iloc[-1], s.iloc[-2]
L227         pair = _valid_ratio(v0, v1)
L228         if pair is None:
L229             return None
L230         a, b = pair
L231         return float(a / b - 1.0)
L232
L233     def ttm_delta(series: pd.Series) -> float | None:
L234         s = _ensure_series(series)
L235         if s.size < 2:
L236             return None
L237         s = s.sort_index()
L238         k = int(min(4, s.size))
L239         cur_slice = s.iloc[-k:]
L240         prev_slice = s.iloc[:-k]
L241         if prev_slice.empty:
L242             return None
L243         prev_k = int(min(k, prev_slice.size))
L244         cur_sum = float(cur_slice.sum())
L245         prev_sum = float(prev_slice.iloc[-prev_k:].sum())
L246         pair = _valid_ratio(cur_sum, prev_sum)
L247         if pair is None:
L248             return None
L249         a, b = pair
L250         return float(a / b - 1.0)
L251
L252     def yoy_y(series: pd.Series) -> float | None:
L253         s = _ensure_series(series)
L254         if s.size < 2:
L255             return None
L256         s = s.sort_index()
L257         v0, v1 = s.iloc[-1], s.iloc[-2]
L258         pair = _valid_ratio(v0, v1)
L259         if pair is None:
L260             return None
L261         a, b = pair
L262         return float(a / b - 1.0)
L263
L264     def price_proxy_growth() -> float | None:
L265         if not isinstance(close_series, pd.Series):
L266             return None
L267         close = close_series.sort_index().dropna()
L268         if close.empty:
L269             return None
L270         hh_window = int(min(126, len(close)))
L271         if hh_window < 20:
L272             return None
L273         hh = close.rolling(hh_window).max().iloc[-1]
L274         prox = None
L275         if np.isfinite(hh) and hh > 0:
L276             prox = float(close.iloc[-1] / hh)
L277         rs6 = None
L278         if len(close) >= 63:
L279             rs6 = float(close.pct_change(63).iloc[-1])
L280         rs12 = None
L281         if len(close) >= 126:
L282             rs12 = float(close.pct_change(126).iloc[-1])
L283         vexp = None
L284         if isinstance(volume_series, pd.Series):
L285             vol = volume_series.reindex(close.index).dropna()
L286             if len(vol) >= 50:
L287                 v20 = vol.rolling(20).mean().iloc[-1]
L288                 v50 = vol.rolling(50).mean().iloc[-1]
L289                 if np.isfinite(v20) and np.isfinite(v50) and v50 > 0:
L290                     vexp = float(v20 / v50 - 1.0)
L291         prox = 0.0 if prox is None or not np.isfinite(prox) else prox
L292         rs6 = 0.0 if rs6 is None or not np.isfinite(rs6) else rs6
L293         rs12 = 0.0 if rs12 is None or not np.isfinite(rs12) else rs12
L294         vexp = 0.0 if vexp is None or not np.isfinite(vexp) else vexp
L295         return 0.5 * prox + 0.3 * rs6 + 0.2 * rs12 + 0.2 * vexp
L296
L297     price_alt = price_proxy_growth() or 0.0
L298     core = 0.0
L299     core_raw = 0.0
L300     price_raw = price_alt
L301
L302     if nQ >= 5:
L303         path = "P5"
L304         yq = yoy_q(s_rev_q)
L305         parts["rev_yoy_q"] = yq
L306         tmp_prev = s_rev_q.iloc[:-1] if s_rev_q.size > 1 else s_rev_q
L307         acc = None
L308         if tmp_prev.size >= 5 and yq is not None:
L309             yq_prev = yoy_q(tmp_prev)
L310             if yq_prev is not None:
L311                 acc = float(yq - yq_prev)
L312         parts["rev_acc_q"] = acc
L313         eps_yoy = yoy_q(s_eps_q) if s_eps_q.size >= 5 else None
L314         parts["eps_yoy_q"] = eps_yoy
L315         eps_acc = None
L316         if eps_yoy is not None and s_eps_q.size > 5:
L317             eps_prev = s_eps_q.iloc[:-1]
L318             if eps_prev.size >= 5:
L319                 eps_prev_yoy = yoy_q(eps_prev)
L320                 if eps_prev_yoy is not None:
L321                     eps_acc = float(eps_yoy - eps_prev_yoy)
L322         parts["eps_acc_q"] = eps_acc
L323         w = 1.0
L324         core_raw = (
L325             0.60 * _nz(yq)
L326             + 0.20 * _nz(acc)
L327             + 0.15 * _nz(eps_yoy)
L328             + 0.05 * _nz(eps_acc)
L329         )
L330         price_alt = 0.0
L331     elif 2 <= nQ <= 4:
L332         path = "P24"
L333         rev_qoq = qoq(s_rev_q)
L334         rev_ttm2 = ttm_delta(s_rev_q)
L335         parts["rev_qoq"] = rev_qoq
L336         parts["rev_ttm2"] = rev_ttm2
L337         eps_qoq = qoq(s_eps_q) if s_eps_q.size >= 2 else None
L338         parts["eps_qoq"] = eps_qoq
L339         w = min(1.0, nQ / 5.0)
L340         core_raw = 0.6 * _nz(rev_qoq) + 0.3 * _nz(rev_ttm2) + 0.1 * _nz(eps_qoq)
L341     else:
L342         path = "P1Y"
L343         rev_yoy_y = yoy_y(s_rev_y) if nY >= 2 else None
L344         parts["rev_yoy_y"] = rev_yoy_y
L345         w = 0.6 * min(1.0, nY / 3.0) if nY >= 2 else 0.4
L346         core_raw = _nz(rev_yoy_y)
L347         if nQ <= 1 and nY < 2 and price_alt == 0.0:
L348             price_alt = price_proxy_growth() or 0.0
L349
L350     core = _winsor(core_raw, lo=-1.5, hi=1.5)
L351     price_alt = _winsor(price_alt, lo=-1.5, hi=1.5)
L352     grw = _winsor(w * core + (1.0 - w) * (0.5 * _nz(price_alt)), lo=-2.0, hi=2.0)
L353
L354     parts.update(
L355         {
L356             "core_raw": core_raw,
L357             "core": core,
L358             "price_proxy_raw": price_raw,
L359             "price_proxy": price_alt,
L360             "weight": w,
L361             "score": grw,
L362         }
L363     )
L364
L365     parts_out: dict[str, Any] = {
L366         "nQ": nQ,
L367         "nY": nY,
L368     }
L369     for key, value in parts.items():
L370         if key in ("nQ", "nY"):
L371             continue
L372         rounded = _round_debug(value)
L373         parts_out[key] = rounded
L374
L375     info_entry["DEBUG_GRW_PATH"] = path
L376     info_entry["DEBUG_GRW_PARTS"] = json.dumps(parts_out, ensure_ascii=False, sort_keys=True)
L377     info_entry["GRW_SCORE"] = grw
L378     info_entry["GRW_WEIGHT"] = w
L379     info_entry["GRW_CORE"] = core
L380     info_entry["GRW_PRICE_PROXY"] = price_alt
L381
L382     return {
L383         "score": grw,
L384         "path": path,
L385         "parts": info_entry["DEBUG_GRW_PARTS"],
L386         "weight": w,
L387         "core": core,
L388         "price_proxy": price_alt,
L389     }
L390
L391
L392 D_WEIGHTS_EFF = None  # 出力表示互換のため
L393
L394
L395 def _scalar(v):
L396     """単一セル代入用に値をスカラーへ正規化する。
L397
L398     - pandas Series -> .iloc[-1]（最後を採用）
L399     - list/tuple/ndarray -> 最後の要素
L400     - それ以外          -> そのまま
L401     取得失敗時は
```