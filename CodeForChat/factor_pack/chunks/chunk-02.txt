```text
tion:
L281                     continue
L282                 picks: list[dict] = []
L283                 if "USD/shares" in units:
L284                     picks.extend(list(units["USD/shares"]))
L285                 if "USD" in units:
L286                     picks.extend(list(units["USD"]))
L287                 if not picks:
L288                     for arr in units.values():
L289                         picks.extend(list(arr))
L290                 out.extend(picks)
L291         return out
L292
L293     @staticmethod
L294     def _only_quarterly(arr: list[dict]) -> list[dict]:
L295         """companyfactsの混在配列から『四半期』だけを抽出。
L296
L297         - frame に "Q" を含む（例: CY2024Q2I）
L298         - fp が Q1/Q2/Q3/Q4
L299         - form が 10-Q/10-Q/A/6-K
L300         """
L301         if not arr:
L302             return []
L303         q_forms = {"10-Q", "10-Q/A", "6-K"}
L304
L305         def is_q(x: dict) -> bool:
L306             frame = (x.get("frame") or "").upper()
L307             fp = (x.get("fp") or "").upper()
L308             form = (x.get("form") or "").upper()
L309             return ("Q" in frame) or (fp in {"Q1", "Q2", "Q3", "Q4"}) or (form in q_forms)
L310
L311         out = [x for x in arr if is_q(x)]
L312         out.sort(key=lambda x: (x.get("end") or ""), reverse=True)
L313         return out
L314
L315     @staticmethod
L316     def _series_from_facts(arr, key="val", normalize=float):
L317         out = []
L318         for x in (arr or []):
L319             try:
L320                 v = x.get(key)
L321                 out.append(normalize(v) if v is not None else float("nan"))
L322             except Exception:
L323                 out.append(float("nan"))
L324         return out
L325
L326     def fetch_eps_rev_from_sec(self, tickers: list[str]) -> dict:
L327         out = {}
L328         t2cik = self._sec_ticker_map()
L329         n_map = n_rev = n_eps = 0
L330         miss_map: list[str] = []
L331         miss_facts: list[str] = []
L332         for t in tickers:
L333             candidates: list[str] = []
L334
L335             def add(key: str) -> None:
L336                 if key and key not in candidates:
L337                     candidates.append(key)
L338
L339             add(t.upper())
L340             for key in self._normalize_ticker(t):
L341                 add(key)
L342
L343             cik = None
L344             for key in candidates:
L345                 cik = t2cik.get(key)
L346                 if cik:
L347                     break
L348             if not cik:
L349                 out[t] = {}
L350                 miss_map.append(t)
L351                 continue
L352             try:
L353                 j = self._sec_companyfacts(cik)
L354                 facts = j or {}
L355                 rev_tags = [
L356                     "Revenues",
L357                     "RevenueFromContractWithCustomerExcludingAssessedTax",
L358                     "SalesRevenueNet",
L359                     "SalesRevenueGoodsNet",
L360                     "SalesRevenueServicesNet",
L361                     "Revenue",
L362                 ]
L363                 eps_tags = [
L364                     "EarningsPerShareDiluted",
L365                     "EarningsPerShareBasicAndDiluted",
L366                     "EarningsPerShare",
L367                     "EarningsPerShareBasic",
L368                 ]
L369                 rev_arr = self._units_for_tags(facts, ["us-gaap", "ifrs-full"], rev_tags)
L370                 eps_arr = self._units_for_tags(facts, ["us-gaap", "ifrs-full"], eps_tags)
L371                 rev_q_items = self._only_quarterly(rev_arr)
L372                 eps_q_items = self._only_quarterly(eps_arr)
L373                 rev_vals = self._series_from_facts(rev_q_items)
L374                 eps_vals = self._series_from_facts(eps_q_items)
L375                 rev_q = float(rev_vals[0]) if rev_vals else float("nan")
L376                 eps_q = float(eps_vals[0]) if eps_vals else float("nan")
L377                 rev_ttm = float(sum([v for v in rev_vals[:4] if v == v])) if rev_vals else float("nan")
L378                 eps_ttm = float(sum([v for v in eps_vals[:4] if v == v])) if eps_vals else float("nan")
L379                 out[t] = {
L380                     "eps_q_recent": eps_q,
L381                     "eps_ttm": eps_ttm,
L382                     "rev_q_recent": rev_q,
L383                     "rev_ttm": rev_ttm,
L384                     "eps_q_series": eps_vals[:8],
L385                     "rev_q_series": rev_vals[:8],
L386                 }
L387                 n_map += 1
L388                 if rev_vals:
L389                     n_rev += 1
L390                 if eps_vals:
L391                     n_eps += 1
L392             except Exception:
L393                 out[t] = {}
L394                 miss_facts.append(t)
L395             time.sleep(0.12)
L396         # 取得サマリをログ（Actionsで確認しやすいよう print）
L397         try:
L398             total = len(tickers)
L399             print(f"[SEC] map={n_map}/{total}  rev_q_hit={n_rev}  eps_q_hit={n_eps}")
L400             if miss_map:
L401                 print(f"[SEC] no CIK map: {len(miss_map)} (例) {miss_map[:12]}")
L402             if miss_facts:
L403                 print(f"[SEC] CIKあり だが対象factなし: {len(miss_facts)} (例) {miss_facts[:12]}")
L404         except Exception:
L405             pass
L406         return out
L407     @staticmethod
L408     def impute_eps_ttm(df: pd.DataFrame, ttm_col: str="eps_ttm", q_col: str="eps_q_recent", out_col: str|None=None) -> pd.DataFrame:
L409         out_col = out_col or ttm_col; df = df.copy(); df["eps_imputed"] = False
L410         cand = df[q_col]*4; ok = df[ttm_col].isna() & cand.replace([np.inf,-np.inf], np.nan).notna()
L411         df.loc[ok, out_col], df.loc[ok,"eps_imputed"] = cand[ok], True; return df
L412
L413     _CF_ALIASES = {"cfo":["Operating Cash Flow","Total Cash From Operating Activities"], "capex":["Capital Expenditure","Capital Expenditures"]}
L414
L415     @staticmethod
L416     def _pick_row(df: pd.DataFrame, names: list[str]) -> pd.Series|None:
L417         if df is None or df.empty: return None
L418         idx_lower={str(i).lower():i for i in df.index}
L419         for n in names:
L420             k=n.lower()
L421             if k in idx_lower: return df.loc[idx_lower[k]]
L422         return None
L423
L424     @staticmethod
L425     def _sum_last_n(s: pd.Series|None, n: int) -> float|None:
L426         if s is None or s.empty: return None
L427         v=s.dropna().astype(float); return None if v.empty else v.iloc[:n].sum()
L428
L429     @staticmethod
L430     def _latest(s: pd.Series|None) -> float|None:
L431         if s is None or s.empty: return None
L432         v=s.dropna().astype(float); return v.iloc[0] if not v.empty else None
L433
L434     def fetch_cfo_capex_ttm_yf(self, tickers: list[str]) -> pd.DataFrame:
L435         from concurrent.futures import ThreadPoolExecutor, as_completed
L436         pick, sumn, latest, aliases = self._pick_row, self._sum_last_n, self._latest, self._CF_ALIASES
L437
L438         def one(t: str):
L439             try:
L440                 tk = yf.Ticker(t)  # ★ セッションは渡さない（YFがcurl_cffiで管理）
L441                 qcf = tk.quarterly_cashflow
L442                 cfo_q, capex_q = pick(qcf, aliases["cfo"]), pick(qcf, aliases["capex"])
L443                 fcf_q = pick(qcf, ["Free Cash Flow","FreeCashFlow","Free cash flow"])
L444                 cfo, capex, fcf = sumn(cfo_q,4), sumn(capex_q,4), sumn(fcf_q,4)
L445                 if any(v is None for v in (cfo, capex, fcf)):
L446                     acf = tk.cashflow
L447                     if cfo   is None: cfo   = latest(pick(acf, aliases["cfo"]))
L448                     if capex is None: capex = latest(pick(acf, aliases["capex"]))
L449                     if fcf   is None: fcf   = latest(pick(acf, ["Free Cash Flow","FreeCashFlow","Free cash flow"]))
L450             except Exception as e:
L451                 print(f"[warn] yf financials error: {t}: {e}"); cfo=capex=fcf=None
L452             n=np.nan
L453             return {"ticker":t,
L454                     "cfo_ttm_yf":   n if cfo   is None else cfo,
L455                     "capex_ttm_yf": n if capex is None else capex,
L456                     "fcf_ttm_yf_direct": n if fcf is None else fcf}
L457
L458         rows, mw = [], int(os.getenv("FIN_THREADS","8"))
L459         with ThreadPoolExecutor(max_workers=mw) as ex:
L460             rows=[f.result() for f in as_completed(ex.submit(one,t) for t in tickers)]
L461         return pd.DataFrame(rows).set_index("ticker")
L462
L463     _FINN_CFO_KEYS = ["netCashProvidedByOperatingActivities","netCashFromOperatingActivities","cashFlowFromOperatingActivities","operatingCashFlow"]
L464     _FINN_CAPEX_KEYS = ["capitalExpenditure","capitalExpenditures","purchaseOfPPE","investmentsInPropertyPlantAndEquipment"]
L465
L466     @staticmethod
L467     def _first_key(d: dict, keys: list[str]):
L468         for k in keys:
L469             if k in d and d[k] is not None: return d[k]
L470         return None
L471
L472     @staticmethod
L473     def _finn_get(session: requests.Session, url: str, params: dict, retries: int=3, sleep_s: float=0.5):
L474         for i in range(retries):
L475             r = session.get(url, params=params, timeout=15)
L476             if r.status_code==429: time.sleep(min(2**i*sleep_s,4.0)); continue
L477             r.raise_for_status(); return r.json()
L478         r.raise_for_status()
L479
L480     def fetch_cfo_capex_ttm_finnhub(self, tickers: list[str], api_key: str|None=None) -> pd.DataFrame:
L481         api_key = api_key or os.getenv("FINNHUB_API_KEY")
L482         if not api_key: raise ValueError("Finnhub API key not provided. Set FINNHUB_API_KEY or pass api_key=")
L483         base, s, rows = "https://finnhub.io/api/v1", requests.Session(), []
L484         for sym in tickers:
L485             cfo_ttm = capex_ttm = None
L486             try:
L487                 j = self._finn_get(s, f"{base}/stock/cash-flow", {"symbol":sym,"frequency":"quarterly","limit":8,"token":api_key})
L488                 arr = j.get("cashFlow") or []; cfo_vals, capex_vals = [], []
L489                 for item in arr[:4]:
L490                     cfo_vals.append(self._first_key(item,self._FINN_CFO_KEYS)); capex_vals.append(self._first_key(item,self._FINN_CAPEX_KEYS))
L491                 if any(v is not None for v in cfo_vals): cfo_ttm = float(np.nansum([np.nan if v is None else float(v) for v in cfo_vals]))
L492                 if any(v is not None for v in capex_vals): capex_ttm = float(np.nansum([np.nan if v is None else float(v) for v in capex_vals]))
L493             except Exception: pass
L494             if cfo_ttm is None or capex_ttm is None:
L495                 try:
L496                     j = self._finn_get(s, f"{base}/stock/cash-flow", {"symbol":sym,"frequency":"annual","limit":1,"token":api_key})
L497                     arr = j.get("cashFlow") or []
L498                     if arr:
L499                         item0 = arr[0]
L500                         if cfo_ttm is None:
L501                             v = self._first_key(item0,self._FINN_CFO_KEYS)
L502                             if v is not None: cfo_ttm = float(v)
L503                         if capex_ttm is None:
L504                             v = self._first_key(item0,self._FINN_CAPEX_KEYS)
L505                             if v is not None: capex_ttm = float(v)
L506                 except Exception: pass
L507             rows.append({"ticker":sym,"cfo_ttm_fh":np.nan if cfo_ttm is None else cfo_ttm,"capex_ttm_fh":np.nan if capex_ttm is None else capex_ttm})
L508         return pd.DataFrame(rows).set_index("ticker")
L509
L510     def compute_fcf_with_fallback(self, tickers: list[str], finnhub_api_key: str|None=None) -> pd.DataFrame:
L511         yf_df = self.fetch_cfo_capex_ttm_yf(tickers)
L512         T.log("financials (yf) done")
L513         miss_mask = yf_df[["cfo_ttm_yf","capex_ttm_yf","fcf_ttm_yf
```