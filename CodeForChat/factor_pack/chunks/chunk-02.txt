```text
r], tags: list[str]) -> list[dict]:
L280         """facts から namespace/tag を横断して units 配列を収集（存在順に連結）。"""
L281         out: list[dict] = []
L282         facts = facts or {}
L283         for ns in namespaces:
L284             try:
L285                 node = facts.get("facts", {}).get(ns, {})
L286             except Exception:
L287                 node = {}
L288             for tg in tags:
L289                 try:
L290                     units = node[tg]["units"]
L291                 except Exception:
L292                     continue
L293                 picks: list[dict] = []
L294                 if "USD/shares" in units:
L295                     picks.extend(list(units["USD/shares"]))
L296                 if "USD" in units:
L297                     picks.extend(list(units["USD"]))
L298                 if not picks:
L299                     for arr in units.values():
L300                         picks.extend(list(arr))
L301                 out.extend(picks)
L302         return out
L303
L304     @staticmethod
L305     def _only_quarterly(arr: list[dict]) -> list[dict]:
L306         """companyfactsの混在配列から『四半期』だけを抽出。
L307
L308         - frame に "Q" を含む（例: CY2024Q2I）
L309         - fp が Q1/Q2/Q3/Q4
L310         - form が 10-Q/10-Q/A/6-K
L311         """
L312         if not arr:
L313             return []
L314         q_forms = {"10-Q", "10-Q/A", "6-K"}
L315
L316         def is_q(x: dict) -> bool:
L317             frame = (x.get("frame") or "").upper()
L318             fp = (x.get("fp") or "").upper()
L319             form = (x.get("form") or "").upper()
L320             return ("Q" in frame) or (fp in {"Q1", "Q2", "Q3", "Q4"}) or (form in q_forms)
L321
L322         out = [x for x in arr if is_q(x)]
L323         out.sort(key=lambda x: (x.get("end") or ""), reverse=True)
L324         return out
L325
L326     @staticmethod
L327     def _series_from_facts(arr, key="val", normalize=float):
L328         out = []
L329         for x in (arr or []):
L330             try:
L331                 v = x.get(key)
L332                 out.append(normalize(v) if v is not None else float("nan"))
L333             except Exception:
L334                 out.append(float("nan"))
L335         return out
L336
L337     def fetch_eps_rev_from_sec(self, tickers: list[str]) -> dict:
L338         out = {}
L339         t2cik = self._sec_ticker_map()
L340         n_map = n_rev = n_eps = 0
L341         miss_map: list[str] = []
L342         miss_facts: list[str] = []
L343         for t in tickers:
L344             candidates: list[str] = []
L345
L346             def add(key: str) -> None:
L347                 if key and key not in candidates:
L348                     candidates.append(key)
L349
L350             add((t or "").upper())
L351             for key in self._normalize_ticker(t):
L352                 add(key)
L353
L354             cik = None
L355             for key in candidates:
L356                 cik = t2cik.get(key)
L357                 if cik:
L358                     break
L359             if not cik:
L360                 out[t] = {}
L361                 miss_map.append(t)
L362                 continue
L363             try:
L364                 j = self._sec_companyfacts(cik)
L365                 facts = j or {}
L366                 rev_tags = [
L367                     "Revenues",
L368                     "RevenueFromContractWithCustomerExcludingAssessedTax",
L369                     "SalesRevenueNet",
L370                     "SalesRevenueGoodsNet",
L371                     "SalesRevenueServicesNet",
L372                     "Revenue",
L373                 ]
L374                 eps_tags = [
L375                     "EarningsPerShareDiluted",
L376                     "EarningsPerShareBasicAndDiluted",
L377                     "EarningsPerShare",
L378                     "EarningsPerShareBasic",
L379                 ]
L380                 rev_arr = self._units_for_tags(facts, ["us-gaap", "ifrs-full"], rev_tags)
L381                 eps_arr = self._units_for_tags(facts, ["us-gaap", "ifrs-full"], eps_tags)
L382                 rev_q_items = self._only_quarterly(rev_arr)
L383                 eps_q_items = self._only_quarterly(eps_arr)
L384                 rev_vals = self._series_from_facts(rev_q_items)
L385                 eps_vals = self._series_from_facts(eps_q_items)
L386                 rev_q = float(rev_vals[0]) if rev_vals else float("nan")
L387                 eps_q = float(eps_vals[0]) if eps_vals else float("nan")
L388                 rev_ttm = float(sum([v for v in rev_vals[:4] if v == v])) if rev_vals else float("nan")
L389                 eps_ttm = float(sum([v for v in eps_vals[:4] if v == v])) if eps_vals else float("nan")
L390                 out[t] = {
L391                     "eps_q_recent": eps_q,
L392                     "eps_ttm": eps_ttm,
L393                     "rev_q_recent": rev_q,
L394                     "rev_ttm": rev_ttm,
L395                     "eps_q_series": eps_vals[:8],
L396                     "rev_q_series": rev_vals[:8],
L397                 }
L398                 n_map += 1
L399                 if rev_vals:
L400                     n_rev += 1
L401                 if eps_vals:
L402                     n_eps += 1
L403             except Exception:
L404                 out[t] = {}
L405                 miss_facts.append(t)
L406             time.sleep(0.30)
L407         # 取得サマリをログ（Actionsで確認しやすいよう print）
L408         try:
L409             total = len(tickers)
L410             print(f"[SEC] map={n_map}/{total}  rev_q_hit={n_rev}  eps_q_hit={n_eps}")
L411             if miss_map:
L412                 print(f"[SEC] no CIK map: {len(miss_map)} (サンプル例) {miss_map[:20]}")
L413             if miss_facts:
L414                 print(f"[SEC] CIKあり だが対象factなし: {len(miss_facts)} (サンプル例) {miss_facts[:20]}")
L415         except Exception:
L416             pass
L417         return out
L418
L419     def sec_dryrun_sample(self, tickers: list[str] | None = None) -> None:
L420         if not _env_true("SEC_DRYRUN_SAMPLE", False):
L421             return
L422         sample = tickers or ["BRK.B", "BF.B", "GOOGL", "META", "UBER", "PBR.A", "TSM", "NARI", "EVBN", "SWAV"]
L423         print(f"[SEC-DRYRUN] sample tickers: {sample}")
L424         try:
L425             t2cik = self._sec_ticker_map()
L426             hits = 0
L427             for sym in sample:
L428                 candidates: list[str] = []
L429
L430                 def add(key: str) -> None:
L431                     if key and key not in candidates:
L432                         candidates.append(key)
L433
L434                 add((sym or "").upper())
L435                 for alt in self._normalize_ticker(sym):
L436                     add(alt)
L437                 if any(t2cik.get(key) for key in candidates):
L438                     hits += 1
L439             sec_data = self.fetch_eps_rev_from_sec(sample)
L440             rev_hits = sum(1 for v in sec_data.values() if v.get("rev_q_series"))
L441             eps_hits = sum(1 for v in sec_data.values() if v.get("eps_q_series"))
L442             total = len(sample)
L443             print(f"[SEC-DRYRUN] CIK map hit: {hits}/{total}  rev_q_series hits: {rev_hits}  eps_q_series hits: {eps_hits}")
L444         except Exception as e:
L445             print(f"[SEC-DRYRUN] error: {e}")
L446     @staticmethod
L447     def impute_eps_ttm(df: pd.DataFrame, ttm_col: str="eps_ttm", q_col: str="eps_q_recent", out_col: str|None=None) -> pd.DataFrame:
L448         out_col = out_col or ttm_col; df = df.copy(); df["eps_imputed"] = False
L449         cand = df[q_col]*4; ok = df[ttm_col].isna() & cand.replace([np.inf,-np.inf], np.nan).notna()
L450         df.loc[ok, out_col], df.loc[ok,"eps_imputed"] = cand[ok], True; return df
L451
L452     _CF_ALIASES = {"cfo":["Operating Cash Flow","Total Cash From Operating Activities"], "capex":["Capital Expenditure","Capital Expenditures"]}
L453
L454     @staticmethod
L455     def _pick_row(df: pd.DataFrame, names: list[str]) -> pd.Series|None:
L456         if df is None or df.empty: return None
L457         idx_lower={str(i).lower():i for i in df.index}
L458         for n in names:
L459             k=n.lower()
L460             if k in idx_lower: return df.loc[idx_lower[k]]
L461         return None
L462
L463     @staticmethod
L464     def _sum_last_n(s: pd.Series|None, n: int) -> float|None:
L465         if s is None or s.empty: return None
L466         v=s.dropna().astype(float); return None if v.empty else v.iloc[:n].sum()
L467
L468     @staticmethod
L469     def _latest(s: pd.Series|None) -> float|None:
L470         if s is None or s.empty: return None
L471         v=s.dropna().astype(float); return v.iloc[0] if not v.empty else None
L472
L473     def fetch_cfo_capex_ttm_yf(self, tickers: list[str]) -> pd.DataFrame:
L474         from concurrent.futures import ThreadPoolExecutor, as_completed
L475         pick, sumn, latest, aliases = self._pick_row, self._sum_last_n, self._latest, self._CF_ALIASES
L476
L477         def one(t: str):
L478             try:
L479                 tk = yf.Ticker(t)  # ★ セッションは渡さない（YFがcurl_cffiで管理）
L480                 qcf = tk.quarterly_cashflow
L481                 cfo_q, capex_q = pick(qcf, aliases["cfo"]), pick(qcf, aliases["capex"])
L482                 fcf_q = pick(qcf, ["Free Cash Flow","FreeCashFlow","Free cash flow"])
L483                 cfo, capex, fcf = sumn(cfo_q,4), sumn(capex_q,4), sumn(fcf_q,4)
L484                 if any(v is None for v in (cfo, capex, fcf)):
L485                     acf = tk.cashflow
L486                     if cfo   is None: cfo   = latest(pick(acf, aliases["cfo"]))
L487                     if capex is None: capex = latest(pick(acf, aliases["capex"]))
L488                     if fcf   is None: fcf   = latest(pick(acf, ["Free Cash Flow","FreeCashFlow","Free cash flow"]))
L489             except Exception as e:
L490                 print(f"[warn] yf financials error: {t}: {e}"); cfo=capex=fcf=None
L491             n=np.nan
L492             return {"ticker":t,
L493                     "cfo_ttm_yf":   n if cfo   is None else cfo,
L494                     "capex_ttm_yf": n if capex is None else capex,
L495                     "fcf_ttm_yf_direct": n if fcf is None else fcf}
L496
L497         rows, mw = [], int(os.getenv("FIN_THREADS","8"))
L498         with ThreadPoolExecutor(max_workers=mw) as ex:
L499             rows=[f.result() for f in as_completed(ex.submit(one,t) for t in tickers)]
L500         return pd.DataFrame(rows).set_index("ticker")
L501
L502     _FINN_CFO_KEYS = ["netCashProvidedByOperatingActivities","netCashFromOperatingActivities","cashFlowFromOperatingActivities","operatingCashFlow"]
L503     _FINN_CAPEX_KEYS = ["capitalExpenditure","capitalExpenditures","purchaseOfPPE","investmentsInPropertyPlantAndEquipment"]
L504
L505     @staticmethod
L506     def _first_key(d: dict, keys: list[str]):
L507         for k in keys:
L508             if k in d and d[k] is not None: return d[k]
L509         return None
L510
L511     @staticmethod
L512     def _finn_get(session: requests.Session, url: str, params: dict, retries: int=3, sleep_s: float=0.5):
L513         for i in range(retries):
L514             r = session.get(url, params=params, timeout=15)
L515             if r.status_code==429: time.sleep(min(2**i*sleep_s,4.0)); continue
L516             r.raise_for_status(); return r.json()
L517         r.raise_for_status()
L518
L519     def fetch_cfo_capex_ttm_finnhub(self, tickers: list[str], api_key: str|None=None) -> pd.DataFrame:
L520         api_key = api_key or os.getenv("FINNHUB_API_KEY")
L521         if not api_key: raise ValueError("Finnhub API key not provided. Set FINNHUB_API_KEY or pass api_key=")
L522         base, s, rows = "https://finnhub.io/api/v1", requests.Session(), []
L523         for sym in tickers:
L524             cfo_ttm = capex_ttm = None
L525             try:
L526                 j = self._finn_get(s, f"{base}/stock/cash-flow", {"symbol":sym,"frequency":"quarterly
```