```text
(filtered[0])
L586             return float("nan")
L587
L588         q_clean = _clean(q_vals or [])
L589         ttm_q = _sum4(q_clean)
L590         if ttm_q == ttm_q:
L591             return ttm_q
L592         for v in _clean(a_vals or []):
L593             if v == v:
L594                 return float(v)
L595         return float("nan")
L596
L597     def fetch_eps_rev_from_sec(self, tickers: list[str]) -> dict:
L598         out = {}
L599         t2cik = self._sec_ticker_map()
L600         n_map = n_rev = n_eps = 0
L601         miss_map: list[str] = []
L602         miss_facts: list[str] = []
L603         for t in tickers:
L604             base = (t or "").upper()
L605             candidates: list[str] = []
L606             for key in [base, *self._normalize_ticker(t)]:
L607                 if key and key not in candidates:
L608                     candidates.append(key)
L609             cik = next((t2cik.get(key) for key in candidates if t2cik.get(key)), None)
L610             if not cik:
L611                 out[t] = {}
L612                 miss_map.append(t)
L613                 continue
L614             try:
L615                 j = self._sec_companyfacts(cik)
L616                 facts = j or {}
L617                 rev_tags = [
L618                     "Revenues",
L619                     "RevenueFromContractWithCustomerExcludingAssessedTax",
L620                     "SalesRevenueNet",
L621                     "SalesRevenueGoodsNet",
L622                     "SalesRevenueServicesNet",
L623                     "Revenue",
L624                 ]
L625                 eps_tags = [
L626                     "EarningsPerShareDiluted",
L627                     "EarningsPerShareBasicAndDiluted",
L628                     "EarningsPerShare",
L629                     "EarningsPerShareBasic",
L630                 ]
L631                 rev_arr = self._units_for_tags(facts, ["us-gaap", "ifrs-full"], rev_tags)
L632                 eps_arr = self._units_for_tags(facts, ["us-gaap", "ifrs-full"], eps_tags)
L633                 rev_q_pairs, rev_a_pairs = self._series_q_and_a(rev_arr)
L634                 eps_q_pairs, eps_a_pairs = self._series_q_and_a(eps_arr)
L635
L636                 rev_q_pairs = rev_q_pairs[:12]
L637                 eps_q_pairs = eps_q_pairs[:12]
L638                 rev_a_pairs = rev_a_pairs[:6]
L639                 eps_a_pairs = eps_a_pairs[:6]
L640
L641                 def _vals(pairs: list[tuple[str, float]]) -> list[float]:
L642                     vals: list[float] = []
L643                     for _d, v in pairs:
L644                         try:
L645                             vals.append(float(v))
L646                         except Exception:
L647                             vals.append(float("nan"))
L648                     return vals
L649
L650                 rev_q_vals = _vals(rev_q_pairs)
L651                 eps_q_vals = _vals(eps_q_pairs)
L652                 rev_a_vals = _vals(rev_a_pairs)
L653                 eps_a_vals = _vals(eps_a_pairs)
L654
L655                 def _first_valid(vals: list[float]) -> float:
L656                     for v in vals:
L657                         if v == v:
L658                             return float(v)
L659                     return float("nan")
L660
L661                 def _nth_valid(vals: list[float], n: int) -> float:
L662                     idx = 0
L663                     for v in vals:
L664                         if v == v:
L665                             if idx == n:
L666                                 return float(v)
L667                             idx += 1
L668                     return float("nan")
L669
L670                 def _quarter_from_annual(vals: list[float]) -> float:
L671                     v = _first_valid(vals)
L672                     return float(v / 4.0) if v == v else float("nan")
L673
L674                 def _quarter_from_annual_prev(vals: list[float]) -> float:
L675                     v = _nth_valid(vals, 1)
L676                     return float(v / 4.0) if v == v else float("nan")
L677
L678                 rev_lastq = _first_valid(rev_q_vals)
L679                 if rev_lastq != rev_lastq:
L680                     rev_lastq = _quarter_from_annual(rev_a_vals)
L681                 eps_lastq = _first_valid(eps_q_vals)
L682                 if eps_lastq != eps_lastq:
L683                     eps_lastq = _quarter_from_annual(eps_a_vals)
L684
L685                 rev_lastq_prev = _nth_valid(rev_q_vals, 4)
L686                 if rev_lastq_prev != rev_lastq_prev:
L687                     rev_lastq_prev = _quarter_from_annual_prev(rev_a_vals)
L688                 eps_lastq_prev = _nth_valid(eps_q_vals, 4)
L689                 if eps_lastq_prev != eps_lastq_prev:
L690                     eps_lastq_prev = _quarter_from_annual_prev(eps_a_vals)
L691
L692                 rev_ttm = self._ttm_from_q_or_a(rev_q_vals, rev_a_vals)
L693                 eps_ttm = self._ttm_from_q_or_a(eps_q_vals, eps_a_vals)
L694                 rev_ttm_prev = self._ttm_from_q_or_a(rev_q_vals[4:], rev_a_vals[1:])
L695                 eps_ttm_prev = self._ttm_from_q_or_a(eps_q_vals[4:], eps_a_vals[1:])
L696
L697                 rev_annual_latest = _first_valid(rev_a_vals)
L698                 rev_annual_prev = _nth_valid(rev_a_vals, 1)
L699                 eps_annual_latest = _first_valid(eps_a_vals)
L700                 eps_annual_prev = _nth_valid(eps_a_vals, 1)
L701
L702                 def _cagr3(vals: list[float]) -> float:
L703                     vals_valid = [v for v in vals if v == v]
L704                     if len(vals_valid) >= 3:
L705                         latest, base = float(vals_valid[0]), float(vals_valid[2])
L706                         if latest > 0 and base > 0:
L707                             try:
L708                                 return float((latest / base) ** (1 / 2) - 1.0)
L709                             except Exception:
L710                                 return float("nan")
L711                     return float("nan")
L712
L713                 rev_cagr3 = _cagr3(rev_a_vals)
L714                 eps_cagr3 = _cagr3(eps_a_vals)
L715
L716                 out[t] = {
L717                     "eps_q_recent": eps_lastq,
L718                     "eps_ttm": eps_ttm,
L719                     "eps_ttm_prev": eps_ttm_prev,
L720                     "eps_lastq_prev": eps_lastq_prev,
L721                     "rev_q_recent": rev_lastq,
L722                     "rev_ttm": rev_ttm,
L723                     "rev_ttm_prev": rev_ttm_prev,
L724                     "rev_lastq_prev": rev_lastq_prev,
L725                     # 後段でDatetimeIndex化できるよう (date,value) を保持。値だけの互換キーも残す。
L726                     # 3年運用に合わせて四半期は直近12本のみ保持（約3年=12Q）
L727                     "eps_q_series_pairs": eps_q_pairs,
L728                     "rev_q_series_pairs": rev_q_pairs,
L729                     "eps_q_series": eps_q_vals,
L730                     "rev_q_series": rev_q_vals,
L731                     "eps_a_series_pairs": eps_a_pairs,
L732                     "rev_a_series_pairs": rev_a_pairs,
L733                     "eps_a_series": eps_a_vals,
L734                     "rev_a_series": rev_a_vals,
L735                     "eps_annual_latest": eps_annual_latest,
L736                     "eps_annual_prev": eps_annual_prev,
L737                     "rev_annual_latest": rev_annual_latest,
L738                     "rev_annual_prev": rev_annual_prev,
L739                     "eps_cagr3": eps_cagr3,
L740                     "rev_cagr3": rev_cagr3,
L741                 }
L742                 n_map += 1
L743                 if any(v == v for v in rev_q_vals) or any(v == v for v in rev_a_vals):
L744                     n_rev += 1
L745                 if any(v == v for v in eps_q_vals) or any(v == v for v in eps_a_vals):
L746                     n_eps += 1
L747             except Exception:
L748                 out[t] = {}
L749                 miss_facts.append(t)
L750             time.sleep(0.30)
L751         # 取得サマリをログ（Actionsで確認しやすいよう print）
L752         try:
L753             total = len(tickers)
L754             print(f"[SEC] map={n_map}/{total}  rev_q_hit={n_rev}  eps_q_hit={n_eps}")
L755             # デバッグ: 取得本数の分布（先頭のみ）
L756             try:
L757                 lens = [len((out.get(t, {}) or {}).get("rev_q_series", [])) for t in tickers]
L758                 print(f"[SEC] rev_q_series length: min={min(lens) if lens else 0} "
L759                       f"p25={np.percentile(lens,25) if lens else 0} median={np.median(lens) if lens else 0} "
L760                       f"p75={np.percentile(lens,75) if lens else 0} max={max(lens) if lens else 0}")
L761             except Exception:
L762                 pass
L763             if miss_map:
L764                 print(f"[SEC] no CIK map: {len(miss_map)} (サンプル例) {miss_map[:20]}")
L765             if miss_facts:
L766                 print(f"[SEC] CIKあり だが対象factなし: {len(miss_facts)} (サンプル例) {miss_facts[:20]}")
L767         except Exception:
L768             pass
L769         return out
L770
L771     def sec_dryrun_sample(self, tickers: list[str] | None = None) -> None:
L772         if not _env_true("SEC_DRYRUN_SAMPLE", False):
L773             return
L774         sample = tickers or ["BRK.B", "BF.B", "GOOGL", "META", "UBER", "PBR.A", "TSM", "NARI", "EVBN", "SWAV"]
L775         print(f"[SEC-DRYRUN] sample tickers: {sample}")
L776         try:
L777             t2cik = self._sec_ticker_map()
L778             hits = 0
L779             for sym in sample:
L780                 candidates: list[str] = []
L781
L782                 def add(key: str) -> None:
L783                     if key and key not in candidates:
L784                         candidates.append(key)
L785
L786                 add((sym or "").upper())
L787                 for alt in self._normalize_ticker(sym):
L788                     add(alt)
L789                 if any(t2cik.get(key) for key in candidates):
L790                     hits += 1
L791             sec_data = self.fetch_eps_rev_from_sec(sample)
L792             rev_hits = sum(1 for v in sec_data.values() if v.get("rev_q_series"))
L793             eps_hits = sum(1 for v in sec_data.values() if v.get("eps_q_series"))
L794             total = len(sample)
L795             print(f"[SEC-DRYRUN] CIK map hit: {hits}/{total}  rev_q_series hits: {rev_hits}  eps_q_series hits: {eps_hits}")
L796         except Exception as e:
L797             print(f"[SEC-DRYRUN] error: {e}")
L798     @staticmethod
L799     def impute_eps_ttm(df: pd.DataFrame, ttm_col: str="eps_ttm", q_col: str="eps_q_recent", out_col: str|None=None) -> pd.DataFrame:
L800         out_col = out_col or ttm_col; df = df.copy(); df["eps_imputed"] = False
L801         cand = df[q_col]*4; ok = df[ttm_col].isna() & cand.replace([np.inf,-np.inf], np.nan).notna()
L802         df.loc[ok, out_col], df.loc[ok,"eps_imputed"] = cand[ok], True; return df
L803
L804     _CF_ALIASES = {"cfo":["Operating Cash Flow","Total Cash From Operating Activities"], "capex":["Capital Expenditure","Capital Expenditures"]}
L805
L806     @staticmethod
L807     def _pick_row(df: pd.DataFrame, names: list[str]) -> pd.Series|None:
L808         if df is None or df.empty: return None
L809         idx_lower={str(i).lower():i for i in df.index}
L810         for n in names:
L811             k=n.lower()
L812             if k in idx_lower: return df.loc[idx_lower[k]]
L813         return None
L814
L815     @staticmethod
L816     def _sum_last_n(s: pd.Series|None, n: int) -> float|None:
L817         if s is None or s.empty: return None
L818         v=s.dropna().astype(float); return None if v.empty else v.iloc[:n].sum()
L819
L820     @staticmethod
L821     def _latest(s: pd.Series|None) -> float|None:
L822         if s is None or s.empty: return None
L823         v=s.dropna().astype(float); return v.iloc[0] if not v.empty else None
L824
L825     def fetch_cfo_capex_ttm_yf(self, tickers: list[str]) -> pd.DataFrame:
L826         from concurrent.futures im
```