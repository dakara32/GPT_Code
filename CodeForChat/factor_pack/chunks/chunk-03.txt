```text
pairs = rev_q_pairs[:12]
L558                 eps_q_pairs = eps_q_pairs[:12]
L559                 rev_a_pairs = rev_a_pairs[:6]
L560                 eps_a_pairs = eps_a_pairs[:6]
L561
L562                 def _vals(pairs: list[tuple[str, float]]) -> list[float]:
L563                     vals: list[float] = []
L564                     for _d, v in pairs:
L565                         try:
L566                             vals.append(float(v))
L567                         except Exception:
L568                             vals.append(float("nan"))
L569                     return vals
L570
L571                 rev_q_vals = _vals(rev_q_pairs)
L572                 eps_q_vals = _vals(eps_q_pairs)
L573                 rev_a_vals = _vals(rev_a_pairs)
L574                 eps_a_vals = _vals(eps_a_pairs)
L575
L576                 def _first_valid(vals: list[float]) -> float:
L577                     for v in vals:
L578                         if v == v:
L579                             return float(v)
L580                     return float("nan")
L581
L582                 def _nth_valid(vals: list[float], n: int) -> float:
L583                     idx = 0
L584                     for v in vals:
L585                         if v == v:
L586                             if idx == n:
L587                                 return float(v)
L588                             idx += 1
L589                     return float("nan")
L590
L591                 def _quarter_from_annual(vals: list[float]) -> float:
L592                     v = _first_valid(vals)
L593                     return float(v / 4.0) if v == v else float("nan")
L594
L595                 def _quarter_from_annual_prev(vals: list[float]) -> float:
L596                     v = _nth_valid(vals, 1)
L597                     return float(v / 4.0) if v == v else float("nan")
L598
L599                 rev_lastq = _first_valid(rev_q_vals)
L600                 if rev_lastq != rev_lastq:
L601                     rev_lastq = _quarter_from_annual(rev_a_vals)
L602                 eps_lastq = _first_valid(eps_q_vals)
L603                 if eps_lastq != eps_lastq:
L604                     eps_lastq = _quarter_from_annual(eps_a_vals)
L605
L606                 rev_lastq_prev = _nth_valid(rev_q_vals, 4)
L607                 if rev_lastq_prev != rev_lastq_prev:
L608                     rev_lastq_prev = _quarter_from_annual_prev(rev_a_vals)
L609                 eps_lastq_prev = _nth_valid(eps_q_vals, 4)
L610                 if eps_lastq_prev != eps_lastq_prev:
L611                     eps_lastq_prev = _quarter_from_annual_prev(eps_a_vals)
L612
L613                 rev_ttm = self._ttm_from_q_or_a(rev_q_vals, rev_a_vals)
L614                 eps_ttm = self._ttm_from_q_or_a(eps_q_vals, eps_a_vals)
L615                 rev_ttm_prev = self._ttm_from_q_or_a(rev_q_vals[4:], rev_a_vals[1:])
L616                 eps_ttm_prev = self._ttm_from_q_or_a(eps_q_vals[4:], eps_a_vals[1:])
L617
L618                 rev_annual_latest = _first_valid(rev_a_vals)
L619                 rev_annual_prev = _nth_valid(rev_a_vals, 1)
L620                 eps_annual_latest = _first_valid(eps_a_vals)
L621                 eps_annual_prev = _nth_valid(eps_a_vals, 1)
L622
L623                 def _cagr3(vals: list[float]) -> float:
L624                     vals_valid = [v for v in vals if v == v]
L625                     if len(vals_valid) >= 3:
L626                         latest, base = float(vals_valid[0]), float(vals_valid[2])
L627                         if latest > 0 and base > 0:
L628                             try:
L629                                 return float((latest / base) ** (1 / 2) - 1.0)
L630                             except Exception:
L631                                 return float("nan")
L632                     return float("nan")
L633
L634                 rev_cagr3 = _cagr3(rev_a_vals)
L635                 eps_cagr3 = _cagr3(eps_a_vals)
L636
L637                 out[t] = {
L638                     "eps_q_recent": eps_lastq,
L639                     "eps_ttm": eps_ttm,
L640                     "eps_ttm_prev": eps_ttm_prev,
L641                     "eps_lastq_prev": eps_lastq_prev,
L642                     "rev_q_recent": rev_lastq,
L643                     "rev_ttm": rev_ttm,
L644                     "rev_ttm_prev": rev_ttm_prev,
L645                     "rev_lastq_prev": rev_lastq_prev,
L646                     # 後段でDatetimeIndex化できるよう (date,value) を保持。値だけの互換キーも残す。
L647                     # 3年運用に合わせて四半期は直近12本のみ保持（約3年=12Q）
L648                     "eps_q_series_pairs": eps_q_pairs,
L649                     "rev_q_series_pairs": rev_q_pairs,
L650                     "eps_q_series": eps_q_vals,
L651                     "rev_q_series": rev_q_vals,
L652                     "eps_a_series_pairs": eps_a_pairs,
L653                     "rev_a_series_pairs": rev_a_pairs,
L654                     "eps_a_series": eps_a_vals,
L655                     "rev_a_series": rev_a_vals,
L656                     "eps_annual_latest": eps_annual_latest,
L657                     "eps_annual_prev": eps_annual_prev,
L658                     "rev_annual_latest": rev_annual_latest,
L659                     "rev_annual_prev": rev_annual_prev,
L660                     "eps_cagr3": eps_cagr3,
L661                     "rev_cagr3": rev_cagr3,
L662                 }
L663                 n_map += 1
L664                 if any(v == v for v in rev_q_vals) or any(v == v for v in rev_a_vals):
L665                     n_rev += 1
L666                 if any(v == v for v in eps_q_vals) or any(v == v for v in eps_a_vals):
L667                     n_eps += 1
L668             except Exception:
L669                 out[t] = {}
L670                 miss_facts.append(t)
L671             time.sleep(0.30)
L672         # 取得サマリをログ（Actionsで確認しやすいよう print）
L673         try:
L674             total = len(tickers)
L675             print(f"[SEC] map={n_map}/{total}  rev_q_hit={n_rev}  eps_q_hit={n_eps}")
L676             # デバッグ: 取得本数の分布（先頭のみ）
L677             try:
L678                 lens = [len((out.get(t, {}) or {}).get("rev_q_series", [])) for t in tickers]
L679                 print(f"[SEC] rev_q_series length: min={min(lens) if lens else 0} "
L680                       f"p25={np.percentile(lens,25) if lens else 0} median={np.median(lens) if lens else 0} "
L681                       f"p75={np.percentile(lens,75) if lens else 0} max={max(lens) if lens else 0}")
L682             except Exception:
L683                 pass
L684             if miss_map:
L685                 print(f"[SEC] no CIK map: {len(miss_map)} (サンプル例) {miss_map[:20]}")
L686             if miss_facts:
L687                 print(f"[SEC] CIKあり だが対象factなし: {len(miss_facts)} (サンプル例) {miss_facts[:20]}")
L688         except Exception:
L689             pass
L690         return out
L691
L692     def sec_dryrun_sample(self, tickers: list[str] | None = None) -> None:
L693         if not _env_true("SEC_DRYRUN_SAMPLE", False):
L694             return
L695         sample = tickers or ["BRK.B", "BF.B", "GOOGL", "META", "UBER", "PBR.A", "TSM", "NARI", "EVBN", "SWAV"]
L696         print(f"[SEC-DRYRUN] sample tickers: {sample}")
L697         try:
L698             t2cik = self._sec_ticker_map()
L699             hits = 0
L700             for sym in sample:
L701                 candidates: list[str] = []
L702
L703                 def add(key: str) -> None:
L704                     if key and key not in candidates:
L705                         candidates.append(key)
L706
L707                 add((sym or "").upper())
L708                 for alt in self._normalize_ticker(sym):
L709                     add(alt)
L710                 if any(t2cik.get(key) for key in candidates):
L711                     hits += 1
L712             sec_data = self.fetch_eps_rev_from_sec(sample)
L713             rev_hits = sum(1 for v in sec_data.values() if v.get("rev_q_series"))
L714             eps_hits = sum(1 for v in sec_data.values() if v.get("eps_q_series"))
L715             total = len(sample)
L716             print(f"[SEC-DRYRUN] CIK map hit: {hits}/{total}  rev_q_series hits: {rev_hits}  eps_q_series hits: {eps_hits}")
L717         except Exception as e:
L718             print(f"[SEC-DRYRUN] error: {e}")
L719     @staticmethod
L720     def impute_eps_ttm(df: pd.DataFrame, ttm_col: str="eps_ttm", q_col: str="eps_q_recent", out_col: str|None=None) -> pd.DataFrame:
L721         out_col = out_col or ttm_col; df = df.copy(); df["eps_imputed"] = False
L722         cand = df[q_col]*4; ok = df[ttm_col].isna() & cand.replace([np.inf,-np.inf], np.nan).notna()
L723         df.loc[ok, out_col], df.loc[ok,"eps_imputed"] = cand[ok], True; return df
L724
L725     _CF_ALIASES = {"cfo":["Operating Cash Flow","Total Cash From Operating Activities"], "capex":["Capital Expenditure","Capital Expenditures"]}
L726
L727     @staticmethod
L728     def _pick_row(df: pd.DataFrame, names: list[str]) -> pd.Series|None:
L729         if df is None or df.empty: return None
L730         idx_lower={str(i).lower():i for i in df.index}
L731         for n in names:
L732             k=n.lower()
L733             if k in idx_lower: return df.loc[idx_lower[k]]
L734         return None
L735
L736     @staticmethod
L737     def _sum_last_n(s: pd.Series|None, n: int) -> float|None:
L738         if s is None or s.empty: return None
L739         v=s.dropna().astype(float); return None if v.empty else v.iloc[:n].sum()
L740
L741     @staticmethod
L742     def _latest(s: pd.Series|None) -> float|None:
L743         if s is None or s.empty: return None
L744         v=s.dropna().astype(float); return v.iloc[0] if not v.empty else None
L745
L746     def fetch_cfo_capex_ttm_yf(self, tickers: list[str]) -> pd.DataFrame:
L747         from concurrent.futures import ThreadPoolExecutor, as_completed
L748         pick, sumn, latest, aliases = self._pick_row, self._sum_last_n, self._latest, self._CF_ALIASES
L749
L750         def one(t: str):
L751             try:
L752                 tk = yf.Ticker(t)  # ★ セッションは渡さない（YFがcurl_cffiで管理）
L753                 qcf = tk.quarterly_cashflow
L754                 cfo_q, capex_q = pick(qcf, aliases["cfo"]), pick(qcf, aliases["capex"])
L755                 fcf_q = pick(qcf, ["Free Cash Flow","FreeCashFlow","Free cash flow"])
L756                 cfo, capex, fcf = sumn(cfo_q,4), sumn(capex_q,4), sumn(fcf_q,4)
L757                 if any(v is None for v in (cfo, capex, fcf)):
L758                     acf = tk.cashflow
L759                     if cfo   is None: cfo   = latest(pick(acf, aliases["cfo"]))
L760                     if capex is None: capex = latest(pick(acf, aliases["capex"]))
L761                     if fcf   is None: fcf   = latest(pick(acf, ["Free Cash Flow","FreeCashFlow","Free cash flow"]))
L762             except Exception as e:
L763                 print(f"[warn] yf financials error: {t}: {e}"); cfo=capex=fcf=None
L764             n=np.nan
L765             return {"ticker":t,
L766                     "cfo_ttm_yf":   n if cfo   is None else cfo,
L767                     "capex_ttm_yf": n if capex is None else capex,
L768                     "fcf_ttm_yf_direct": n if fcf is None else fcf}
L769
L770         rows, mw = [], int(os.getenv("FIN_THREADS","8"))
L771         with ThreadPoolExecutor(max_workers=mw) as ex:
L772             rows=[f.result() for f in as_completed(ex.submit(one,t) for t in tickers)]
L773         return pd.DataFrame(rows).set_index("ticker")
L774
L775     _FINN_CFO_KEYS = ["netCashProvidedByOperatingActivities","netCashFromOperatingActivities","cashFlowFromOperatingActivities","operatingCashFlow"]
L776     _FINN_CAPEX_KEYS = ["capitalExpenditure","capitalExpenditures","purchaseOfPPE","investmentsInPropertyPlantAndEquipment"]
L777
L778     @staticmethod
L779     def _first_key(d: dict, keys: list[str]):
L780         for k in keys:
L781             if k in d and d[k] is not None: return d[k]
L782         return None
L783
L784     @staticmethod
L785     def _finn_get(ses
```