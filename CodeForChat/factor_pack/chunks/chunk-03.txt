```text
L584                     out.append(f)
L585                 else:
L586                     out.append(float("nan"))
L587             return out
L588
L589         def _sum4(vs: list[float]) -> float:
L590             filtered = [v for v in vs[:4] if v == v]
L591             if len(filtered) >= 2:
L592                 return float(sum(filtered))
L593             if len(filtered) == 1:
L594                 return float(filtered[0])
L595             return float("nan")
L596
L597         q_clean = _clean(q_vals or [])
L598         ttm_q = _sum4(q_clean)
L599         if ttm_q == ttm_q:
L600             return ttm_q
L601         for v in _clean(a_vals or []):
L602             if v == v:
L603                 return float(v)
L604         return float("nan")
L605
L606     def fetch_eps_rev_from_sec(self, tickers: list[str]) -> dict:
L607         out = {}
L608         t2cik = self._sec_ticker_map()
L609         n_map = n_rev = n_eps = 0
L610         miss_map: list[str] = []
L611         miss_facts: list[str] = []
L612         for t in tickers:
L613             base = (t or "").upper()
L614             candidates: list[str] = []
L615             for key in [base, *self._normalize_ticker(t)]:
L616                 if key and key not in candidates:
L617                     candidates.append(key)
L618             cik = next((t2cik.get(key) for key in candidates if t2cik.get(key)), None)
L619             if not cik:
L620                 out[t] = {}
L621                 miss_map.append(t)
L622                 continue
L623             try:
L624                 j = self._sec_companyfacts(cik)
L625                 facts = j or {}
L626                 rev_tags = [
L627                     "Revenues",
L628                     "RevenueFromContractWithCustomerExcludingAssessedTax",
L629                     "SalesRevenueNet",
L630                     "SalesRevenueGoodsNet",
L631                     "SalesRevenueServicesNet",
L632                     "Revenue",
L633                 ]
L634                 eps_tags = [
L635                     "EarningsPerShareDiluted",
L636                     "EarningsPerShareBasicAndDiluted",
L637                     "EarningsPerShare",
L638                     "EarningsPerShareBasic",
L639                 ]
L640                 rev_arr = self._units_for_tags(facts, ["us-gaap", "ifrs-full"], rev_tags)
L641                 eps_arr = self._units_for_tags(facts, ["us-gaap", "ifrs-full"], eps_tags)
L642                 rev_q_pairs, rev_a_pairs = self._series_q_and_a(rev_arr)
L643                 eps_q_pairs, eps_a_pairs = self._series_q_and_a(eps_arr)
L644
L645                 rev_q_pairs = rev_q_pairs[:12]
L646                 eps_q_pairs = eps_q_pairs[:12]
L647                 rev_a_pairs = rev_a_pairs[:6]
L648                 eps_a_pairs = eps_a_pairs[:6]
L649
L650                 def _vals(pairs: list[tuple[str, float]]) -> list[float]:
L651                     vals: list[float] = []
L652                     for _d, v in pairs:
L653                         try:
L654                             vals.append(float(v))
L655                         except Exception:
L656                             vals.append(float("nan"))
L657                     return vals
L658
L659                 rev_q_vals = _vals(rev_q_pairs)
L660                 eps_q_vals = _vals(eps_q_pairs)
L661                 rev_a_vals = _vals(rev_a_pairs)
L662                 eps_a_vals = _vals(eps_a_pairs)
L663
L664                 def _first_valid(vals: list[float]) -> float:
L665                     for v in vals:
L666                         if v == v:
L667                             return float(v)
L668                     return float("nan")
L669
L670                 def _nth_valid(vals: list[float], n: int) -> float:
L671                     idx = 0
L672                     for v in vals:
L673                         if v == v:
L674                             if idx == n:
L675                                 return float(v)
L676                             idx += 1
L677                     return float("nan")
L678
L679                 def _quarter_from_annual(vals: list[float]) -> float:
L680                     v = _first_valid(vals)
L681                     return float(v / 4.0) if v == v else float("nan")
L682
L683                 def _quarter_from_annual_prev(vals: list[float]) -> float:
L684                     v = _nth_valid(vals, 1)
L685                     return float(v / 4.0) if v == v else float("nan")
L686
L687                 rev_lastq = _first_valid(rev_q_vals)
L688                 if rev_lastq != rev_lastq:
L689                     rev_lastq = _quarter_from_annual(rev_a_vals)
L690                 eps_lastq = _first_valid(eps_q_vals)
L691                 if eps_lastq != eps_lastq:
L692                     eps_lastq = _quarter_from_annual(eps_a_vals)
L693
L694                 rev_lastq_prev = _nth_valid(rev_q_vals, 4)
L695                 if rev_lastq_prev != rev_lastq_prev:
L696                     rev_lastq_prev = _quarter_from_annual_prev(rev_a_vals)
L697                 eps_lastq_prev = _nth_valid(eps_q_vals, 4)
L698                 if eps_lastq_prev != eps_lastq_prev:
L699                     eps_lastq_prev = _quarter_from_annual_prev(eps_a_vals)
L700
L701                 rev_ttm = self._ttm_from_q_or_a(rev_q_vals, rev_a_vals)
L702                 eps_ttm = self._ttm_from_q_or_a(eps_q_vals, eps_a_vals)
L703                 rev_ttm_prev = self._ttm_from_q_or_a(rev_q_vals[4:], rev_a_vals[1:])
L704                 eps_ttm_prev = self._ttm_from_q_or_a(eps_q_vals[4:], eps_a_vals[1:])
L705
L706                 rev_annual_latest = _first_valid(rev_a_vals)
L707                 rev_annual_prev = _nth_valid(rev_a_vals, 1)
L708                 eps_annual_latest = _first_valid(eps_a_vals)
L709                 eps_annual_prev = _nth_valid(eps_a_vals, 1)
L710
L711                 def _cagr3(vals: list[float]) -> float:
L712                     vals_valid = [v for v in vals if v == v]
L713                     if len(vals_valid) >= 3:
L714                         latest, base = float(vals_valid[0]), float(vals_valid[2])
L715                         if latest > 0 and base > 0:
L716                             try:
L717                                 return float((latest / base) ** (1 / 2) - 1.0)
L718                             except Exception:
L719                                 return float("nan")
L720                     return float("nan")
L721
L722                 rev_cagr3 = _cagr3(rev_a_vals)
L723                 eps_cagr3 = _cagr3(eps_a_vals)
L724
L725                 out[t] = {
L726                     "eps_q_recent": eps_lastq,
L727                     "eps_ttm": eps_ttm,
L728                     "eps_ttm_prev": eps_ttm_prev,
L729                     "eps_lastq_prev": eps_lastq_prev,
L730                     "rev_q_recent": rev_lastq,
L731                     "rev_ttm": rev_ttm,
L732                     "rev_ttm_prev": rev_ttm_prev,
L733                     "rev_lastq_prev": rev_lastq_prev,
L734                     # 後段でDatetimeIndex化できるよう (date,value) を保持。値だけの互換キーも残す。
L735                     # 3年運用に合わせて四半期は直近12本のみ保持（約3年=12Q）
L736                     "eps_q_series_pairs": eps_q_pairs,
L737                     "rev_q_series_pairs": rev_q_pairs,
L738                     "eps_q_series": eps_q_vals,
L739                     "rev_q_series": rev_q_vals,
L740                     "eps_a_series_pairs": eps_a_pairs,
L741                     "rev_a_series_pairs": rev_a_pairs,
L742                     "eps_a_series": eps_a_vals,
L743                     "rev_a_series": rev_a_vals,
L744                     "eps_annual_latest": eps_annual_latest,
L745                     "eps_annual_prev": eps_annual_prev,
L746                     "rev_annual_latest": rev_annual_latest,
L747                     "rev_annual_prev": rev_annual_prev,
L748                     "eps_cagr3": eps_cagr3,
L749                     "rev_cagr3": rev_cagr3,
L750                 }
L751                 n_map += 1
L752                 if any(v == v for v in rev_q_vals) or any(v == v for v in rev_a_vals):
L753                     n_rev += 1
L754                 if any(v == v for v in eps_q_vals) or any(v == v for v in eps_a_vals):
L755                     n_eps += 1
L756             except Exception:
L757                 out[t] = {}
L758                 miss_facts.append(t)
L759             time.sleep(0.30)
L760         # 取得サマリをログ（Actionsで確認しやすいよう print）
L761         try:
L762             total = len(tickers)
L763             print(f"[SEC] map={n_map}/{total}  rev_q_hit={n_rev}  eps_q_hit={n_eps}")
L764             # デバッグ: 取得本数の分布（先頭のみ）
L765             try:
L766                 lens = [len((out.get(t, {}) or {}).get("rev_q_series", [])) for t in tickers]
L767                 print(f"[SEC] rev_q_series length: min={min(lens) if lens else 0} "
L768                       f"p25={np.percentile(lens,25) if lens else 0} median={np.median(lens) if lens else 0} "
L769                       f"p75={np.percentile(lens,75) if lens else 0} max={max(lens) if lens else 0}")
L770             except Exception:
L771                 pass
L772             if miss_map:
L773                 print(f"[SEC] no CIK map: {len(miss_map)} (サンプル例) {miss_map[:20]}")
L774             if miss_facts:
L775                 print(f"[SEC] CIKあり だが対象factなし: {len(miss_facts)} (サンプル例) {miss_facts[:20]}")
L776         except Exception:
L777             pass
L778         return out
L779
L780     def sec_dryrun_sample(self, tickers: list[str] | None = None) -> None:
L781         if not _env_true("SEC_DRYRUN_SAMPLE", False):
L782             return
L783         sample = tickers or ["BRK.B", "BF.B", "GOOGL", "META", "UBER", "PBR.A", "TSM", "NARI", "EVBN", "SWAV"]
L784         print(f"[SEC-DRYRUN] sample tickers: {sample}")
L785         try:
L786             t2cik = self._sec_ticker_map()
L787             hits = 0
L788             for sym in sample:
L789                 candidates: list[str] = []
L790
L791                 def add(key: str) -> None:
L792                     if key and key not in candidates:
L793                         candidates.append(key)
L794
L795                 add((sym or "").upper())
L796                 for alt in self._normalize_ticker(sym):
L797                     add(alt)
L798                 if any(t2cik.get(key) for key in candidates):
L799                     hits += 1
L800             sec_data = self.fetch_eps_rev_from_sec(sample)
L801             rev_hits = sum(1 for v in sec_data.values() if v.get("rev_q_series"))
L802             eps_hits = sum(1 for v in sec_data.values() if v.get("eps_q_series"))
L803             total = len(sample)
L804             print(f"[SEC-DRYRUN] CIK map hit: {hits}/{total}  rev_q_series hits: {rev_hits}  eps_q_series hits: {eps_hits}")
L805         except Exception as e:
L806             print(f"[SEC-DRYRUN] error: {e}")
L807     @staticmethod
L808     def impute_eps_ttm(df: pd.DataFrame, ttm_col: str="eps_ttm", q_col: str="eps_q_recent", out_col: str|None=None) -> pd.DataFrame:
L809         out_col = out_col or ttm_col; df = df.copy(); df["eps_imputed"] = False
L810         cand = df[q_col]*4; ok = df[ttm_col].isna() & cand.replace([np.inf,-np.inf], np.nan).notna()
L811         df.loc[ok, out_col], df.loc[ok,"eps_imputed"] = cand[ok], True; return df
L812
L813     _CF_ALIASES = {"cfo":["Operating Cash Flow","Total Cash From Operating Activities"], "capex":["Capital Expenditure","Capital Expenditures"]}
L814
L815     @staticmethod
L816     def _pick_row(df: pd.DataFrame, names: list[str]) -> pd.Series|None:
L817         if df is None or df.empty: return None
L818         idx_lower={str(i).lower():i for i in df.index}
L819         for n in names:
L820             k=n.lower()
L821             if k in idx_lower: return df.loc[idx_lower[k]]
L822         return None
L823
L824     @staticmethod
L825     def _sum_last_n(s: pd.Series|None, n: int) -> float|None:
L826         if s is None or s.empty: return None
L827  
```