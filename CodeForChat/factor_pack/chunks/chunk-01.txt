```text
# === Chat Paste Pack ===
# Repo: dakara32/GPT_Code @ main
# Files: config.py, factor.py, scorer.py, .github/workflows/weekly-report.yml, documents/README.md, documents/factor_design.md
# 作成日時: 2025-09-18 23:55:01 (JST)
# 使い方: 下のチャンクを順に貼ればこのチャットで全体把握できます。
# 注記: 各ファイルは個別に L1.. で行番号付与。
---

## <config.py>
```text
L1 # 共通設定（factor / drift から参照）
L2 from dataclasses import dataclass
L3
L4 TOTAL_TARGETS = 20
L5
L6 # 基準のバケット数（NORMAL）
L7 COUNTS_BASE = {"G": 12, "D": 8}
L8
L9 # モード別の推奨バケット数
L10 COUNTS_BY_MODE = {
L11     "NORMAL": {"G": 12, "D": 8},
L12     "CAUTION": {"G": 10, "D": 8},
L13     "EMERG": {"G": 8,  "D": 8},
L14 }
L15
L16 # モード別のドリフト閾値（%）
L17 DRIFT_THRESHOLD_BY_MODE = {"NORMAL": 12, "CAUTION": 14, "EMERG": float("inf")}
L18
L19 # モード別のTS（基本幅, 小数=割合）
L20 TS_BASE_BY_MODE = {"NORMAL": 0.15, "CAUTION": 0.13, "EMERG": 0.10}
L21 # 利益到達(+30/+60/+100%)時の段階タイト化（ポイント差）
L22 TS_STEP_DELTAS_PT = (3, 6, 8)
L23
L24 # Breadthの校正は N_G に連動（緊急解除=ceil(1.5*N_G), 通常復帰=3*N_G）
L25 N_G = COUNTS_BASE["G"]
L26 N_D = COUNTS_BASE["D"]
L27
```

## <factor.py>
```text
L1 '''ROLE: Orchestration ONLY（外部I/O・SSOT・Slack出力）, 計算は scorer.py'''
L2 # === NOTE: 機能・入出力・ログ文言・例外挙動は不変。安全な短縮（import統合/複数代入/内包表記/メソッドチェーン/一行化/空行圧縮など）のみ適用 ===
L3 BONUS_COEFF = 0.55  # 推奨: 攻め=0.45 / 中庸=0.55 / 守り=0.65
L4 SWAP_DELTA_Z = 0.15   # 僅差判定: σの15%。(緩め=0.10 / 標準=0.15 / 固め=0.20)
L5 SWAP_KEEP_BUFFER = 3  # n_target+この順位以内の現行は保持。(粘り弱=2 / 標準=3 / 粘り強=4〜5)
L6 import os, time, requests
L7 import logging
L8 from time import perf_counter
L9 from dataclasses import dataclass
L10 from typing import Any, Dict, List
L11 from concurrent.futures import ThreadPoolExecutor
L12 import numpy as np
L13 import pandas as pd
L14 import yfinance as yf
L15 from scipy.stats import zscore  # used via scorer
L16 from scorer import Scorer, ttm_div_yield_portfolio
L17 import config
L18
L19 # その他
L20 debug_mode, FINNHUB_API_KEY = True, os.environ.get("FINNHUB_API_KEY")
L21
L22 logger = logging.getLogger(__name__)
L23 if debug_mode:
L24     logging.basicConfig(level=logging.INFO, force=True)
L25 else:
L26     logging.basicConfig(level=logging.WARNING, force=True)
L27
L28 class T:
L29     t = perf_counter()
L30     log = staticmethod(lambda tag: (lambda now=perf_counter(): (print(f"[T] {tag}: {now - T.t:.2f}s"), setattr(T, "t", now))[-1])())
L31
L32 T.log("start")
L33
L34 # === ユニバースと定数（冒頭に固定） ===
L35 exist, cand = [pd.read_csv(f, header=None)[0].tolist() for f in ("current_tickers.csv","candidate_tickers.csv")]
L36 T.log(f"csv loaded: exist={len(exist)} cand={len(cand)}")
L37 CAND_PRICE_MAX, bench = 450, '^GSPC'  # 価格上限・ベンチマーク
L38 N_G, N_D = config.N_G, config.N_D  # G/D枠サイズ（NORMAL基準: G12/D8）
L39 g_weights = {'GROWTH_F':0.35,'MOM':0.55,'VOL':-0.10}
L40 D_BETA_MAX = float(os.environ.get("D_BETA_MAX", "0.8"))
L41 FILTER_SPEC = {"G":{"pre_mask":["trend_template"]},"D":{"pre_filter":{"beta_max":D_BETA_MAX}}}
L42 D_weights = {'QAL':0.1,'YLD':0.3,'VOL':-0.5,'TRD':0.1}
L43 _fmt_w = lambda w: " ".join(f"{k}{int(v*100)}" for k, v in w.items())
L44
L45 # DRRS 初期プール・各種パラメータ
L46 corrM = 45
L47 DRRS_G, DRRS_D = dict(lookback=252,n_pc=3,gamma=1.2,lam=0.68,eta=0.8), dict(lookback=504,n_pc=4,gamma=0.8,lam=0.85,eta=0.5)
L48 DRRS_SHRINK = 0.10  # 残差相関の対角シュリンク（基礎）
L49
L50 # クロス相関ペナルティ（未定義なら設定）
L51 try: CROSS_MU_GD
L52 except NameError: CROSS_MU_GD = 0.40  # 推奨 0.35–0.45（lam=0.85想定）
L53
L54 # 出力関連
L55 RESULTS_DIR = "results"
L56 os.makedirs(RESULTS_DIR, exist_ok=True)
L57
L58 # === 共有DTO（クラス間I/O契約）＋ Config ===
L59 @dataclass(frozen=True)
L60 class InputBundle:
L61     # Input → Scorer で受け渡す素材（I/O禁止の生データ）
L62     cand: List[str]
L63     tickers: List[str]
L64     bench: str
L65     data: pd.DataFrame              # yfinance download結果（'Close','Volume'等の階層列）
L66     px: pd.DataFrame                # data['Close']
L67     spx: pd.Series                  # data['Close'][bench]
L68     tickers_bulk: object            # yfinance.Tickers
L69     info: Dict[str, dict]           # yfinance info per ticker
L70     eps_df: pd.DataFrame            # ['eps_ttm','eps_q_recent',...]
L71     fcf_df: pd.DataFrame            # ['fcf_ttm', ...]
L72     returns: pd.DataFrame           # px[tickers].pct_change()
L73
L74 @dataclass(frozen=True)
L75 class FeatureBundle:
L76     df: pd.DataFrame
L77     df_z: pd.DataFrame
L78     g_score: pd.Series
L79     d_score_all: pd.Series
L80     missing_logs: pd.DataFrame
L81     df_full: pd.DataFrame | None = None
L82     df_full_z: pd.DataFrame | None = None
L83     scaler: Any | None = None
L84
L85 @dataclass(frozen=True)
L86 class SelectionBundle:
L87     resG: dict
L88     resD: dict
L89     top_G: List[str]
L90     top_D: List[str]
L91     init_G: List[str]
L92     init_D: List[str]
L93
L94 @dataclass(frozen=True)
L95 class WeightsConfig:
L96     g: Dict[str,float]
L97     d: Dict[str,float]
L98
L99 @dataclass(frozen=True)
L100 class DRRSParams:
L101     corrM: int
L102     shrink: float
L103     G: Dict[str,float]   # lookback, n_pc, gamma, lam, eta
L104     D: Dict[str,float]
L105     cross_mu_gd: float
L106
L107 @dataclass(frozen=True)
L108 class PipelineConfig:
L109     weights: WeightsConfig
L110     drrs: DRRSParams
L111     price_max: float
L112
L113 # === 共通ユーティリティ（複数クラスで使用） ===
L114 # (unused local utils removed – use scorer.py versions if needed)
L115
L116 _env_true = lambda name, default=False: (os.getenv(name) or str(default)).strip().lower() == "true"
L117
L118 def _post_slack(payload: dict):
L119     url = os.getenv("SLACK_WEBHOOK_URL")
L120     if not url: print("⚠️ SLACK_WEBHOOK_URL 未設定"); return
L121     try:
L122         requests.post(url, json=payload).raise_for_status()
L123     except Exception as e:
L124         print(f"⚠️ Slack通知エラー: {e}")
L125
L126 def _slack_send_text_chunks(url: str, text: str, chunk: int = 2800) -> None:
L127     """Slackへテキストを分割送信（コードブロック形式）。"""
L128
L129     def _post_text(payload: str) -> None:
L130         try:
L131             resp = requests.post(url, json={"text": payload})
L132             print(f"[DBG] debug_post status={getattr(resp, 'status_code', None)} size={len(payload)}")
L133             if resp is not None:
L134                 resp.raise_for_status()
L135         except Exception as e:
L136             print(f"[ERR] debug_post_failed: {e}")
L137
L138     body = str(text or "").strip()
L139     if not body:
L140         print("[DBG] skip debug send: empty body")
L141         return
L142
L143     lines = body.splitlines()
L144     block: list[str] = []
L145     block_len = 0
L146
L147     def _flush() -> None:
L148         nonlocal block, block_len
L149         if not block:
L150             return
L151         payload = "```" + "\n".join(block) + "```"
L152         _post_text(payload)
L153         block, block_len = [], 0
L154
L155     for raw in lines:
L156         line = raw or ""
L157         while len(line) > chunk:
L158             head, line = line[:chunk], line[chunk:]
L159             _flush()
L160             _post_text("```" + head + "```")
L161         add_len = len(line) if not block else len(line) + 1
L162         if block and block_len + add_len > chunk:
L163             _flush()
L164             add_len = len(line)
L165         block.append(line)
L166         block_len += add_len
L167     _flush()
L168
L169 def _disjoint_keepG(top_G, top_D, poolD):
L170     """G重複をDから除去し、poolDで順次補充（枯渇時は元銘柄維持）。"""
L171     used, D, i = set(top_G), list(top_D), 0
L172     for j, t in enumerate(D):
L173         if t in used:
L174             while i < len(poolD) and (poolD[i] in used or poolD[i] in D):
L175                 i += 1
L176             if i < len(poolD):
L177                 D[j] = poolD[i]; used.add(D[j]); i += 1
L178     return top_G, D
L179
L180
L181 def _sticky_keep_current(agg: pd.Series, pick: list[str], incumbents: list[str],
L182                          n_target: int, delta_z: float, keep_buffer: int) -> list[str]:
L183     import pandas as pd, numpy as np
L184     sel = list(pick)
L185     if not sel: return sel
L186     ranked_sel = agg.reindex(sel).sort_values(ascending=False)
L187     kth = ranked_sel.iloc[min(len(sel), n_target)-1]
L188     sigma = float(agg.std()) if pd.notna(agg.std()) else 0.0
L189     thresh = kth - delta_z * sigma
L190     ranked_all = agg.sort_values(ascending=False)
L191     cand = [t for t in incumbents if (t not in sel) and (t in agg.index)]
L192     for t in cand:
L193         within_score = (pd.notna(agg[t]) and agg[t] >= thresh)
L194         within_rank  = (t in ranked_all.index) and (ranked_all.index.get_loc(t) < n_target + keep_buffer)
L195         if within_score or within_rank:
L196             non_inc = [x for x in sel if x not in incumbents]
L197             if not non_inc: break
L198             weakest = min(non_inc, key=lambda x: agg.get(x, -np.inf))
L199             if weakest in sel and agg.get(t, -np.inf) >= agg.get(weakest, -np.inf):
L200                 sel.remove(weakest); sel.append(t)
L201     if len(sel) > n_target:
L202         sel = sorted(sel, key=lambda x: agg.get(x, -1e9), reverse=True)[:n_target]
L203     return sel
L204
L205
L206 # === Input：外部I/Oと前処理（CSV/API・欠損補完） ===
L207 class Input:
L208     def __init__(self, cand, exist, bench, price_max, finnhub_api_key=None):
L209         self.cand, self.exist, self.bench, self.price_max = cand, exist, bench, price_max
L210         self.api_key = finnhub_api_key or os.environ.get("FINNHUB_API_KEY")
L211
L212     # ---- （Input専用）EPS補完・FCF算出系 ----
L213     @staticmethod
L214     def impute_eps_ttm(df: pd.DataFrame, ttm_col: str="eps_ttm", q_col: str="eps_q_recent", out_col: str|None=None) -> pd.DataFrame:
L215         out_col = out_col or ttm_col; df = df.copy(); df["eps_imputed"] = False
L216         cand = df[q_col]*4; ok = df[ttm_col].isna() & cand.replace([np.inf,-np.inf], np.nan).notna()
L217         df.loc[ok, out_col], df.loc[ok,"eps_imputed"] = cand[ok], True; return df
L218
L219     _CF_ALIASES = {"cfo":["Operating Cash Flow","Total Cash From Operating Activities"], "capex":["Capital Expenditure","Capital Expenditures"]}
L220
L221     @staticmethod
L222     def _pick_row(df: pd.DataFrame, names: list[str]) -> pd.Series|None:
L223         if df is None or df.empty: return None
L224         idx_lower={str(i).lower():i for i in df.index}
L225         for n in names:
L226             k=n.lower()
L227             if k in idx_lower: return df.loc[idx_lower[k]]
L228         return None
L229
L230     @staticmethod
L231     def _sum_last_n(s: pd.Series|None, n: int) -> float|None:
L232         if s is None or s.empty: return None
L233         v=s.dropna().astype(float); return None if v.empty else v.iloc[:n].sum()
L234
L235     @staticmethod
L236     def _latest(s: pd.Series|None) -> float|None:
L237         if s is None or s.empty: return None
L238         v=s.dropna().astype(float); return v.iloc[0] if not v.empty else None
L239
L240     def fetch_cfo_capex_ttm_yf(self, tickers: list[str]) -> pd.DataFrame:
L241         from concurrent.futures import ThreadPoolExecutor, as_completed
L242         pick, sumn, latest, aliases = self._pick_row, self._sum_last_n, self._latest, self._CF_ALIASES
L243
L244         def one(t: str):
L245             try:
L246                 tk = yf.Ticker(t)  # ★ セッションは渡さない（YFがcurl_cffiで管理）
L247                 qcf = tk.quarterly_cashflow
L248                 cfo_q, capex_q = pick(qcf, aliases["cfo"]), pick(qcf, aliases["capex"])
L249                 fcf_q = pick(qcf, ["Free Cash Flow","FreeCashFlow","Free cash flow"])
L250                 cfo, capex, fcf = sumn(cfo_q,4), sumn(capex_q,4), sumn(fcf_q,4)
L251                 if any(v is None for v in (cfo, capex, fcf)):
L252                     acf = tk.cashflow
L253                     if cfo   is None: cfo   = latest(pick(acf, aliases["cfo"]))
L254                     if capex is None: capex = latest(pick(acf, aliases["capex"]))
L255                     if fcf   is None: fcf   = latest(pick(acf, ["Free Cash Flow","FreeCashFlow","Free cash flow"]))
L256             except Exception as e:
L257                
```