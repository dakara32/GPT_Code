```text
# === Chat Paste Pack ===
# Repo: dakara32/GPT_Code @ main
# Files: config.py, factor.py, scorer.py, .github/workflows/weekly-report.yml, documents/README.md, documents/factor_design.md
# 作成日時: 2025-09-27 16:29:19 (JST)
# 使い方: 下のチャンクを順に貼ればこのチャットで全体把握できます。
# 注記: 各ファイルは個別に L1.. で行番号付与。
---

## <config.py>
```text
L1 # 共通設定（factor / drift から参照）
L2 TOTAL_TARGETS = 20
L3
L4 # 基準のバケット数（NORMAL）
L5 COUNTS_BASE = {"G": 12, "D": 8}
L6
L7 # モード別の推奨バケット数
L8 COUNTS_BY_MODE = {
L9     "NORMAL": {"G": 12, "D": 8},
L10     "CAUTION": {"G": 10, "D": 8},
L11     "EMERG": {"G": 8,  "D": 8},
L12 }
L13
L14 # モード別のドリフト閾値（%）
L15 DRIFT_THRESHOLD_BY_MODE = {"NORMAL": 12, "CAUTION": 14, "EMERG": float("inf")}
L16
L17 # モード別の推奨現金比率
L18 CASH_RATIO_BY_MODE = {
L19     "NORMAL": 0.10,  # 10%
L20     "CAUTION": 0.20,  # 20%
L21     "EMERG": 0.30,  # 30%
L22 }
L23
L24 # モード別のTS（基本幅, 小数=割合）
L25 TS_BASE_BY_MODE = {"NORMAL": 0.15, "CAUTION": 0.13, "EMERG": 0.10}
L26 # 利益到達(+30/+60/+100%)時の段階タイト化（ポイント差）
L27 TS_STEP_DELTAS_PT = (3, 6, 8)
L28
L29 # Breadthの校正は N_G に連動（緊急解除=ceil(1.5*N_G), 通常復帰=3*N_G）
L30 N_G = COUNTS_BASE["G"]
L31 N_D = COUNTS_BASE["D"]
L32
```

## <factor.py>
```text
L1 '''ROLE: Orchestration ONLY（外部I/O・SSOT・Slack出力）, 計算は scorer.py'''
L2 # === NOTE: 機能・入出力・ログ文言・例外挙動は不変。安全な短縮（import統合/複数代入/内包表記/メソッドチェーン/一行化/空行圧縮など）のみ適用 ===
L3 import logging, os, time, requests
L4 from concurrent.futures import ThreadPoolExecutor
L5 from dataclasses import dataclass
L6 from time import perf_counter
L7 from typing import Any, Dict, List, Tuple
L8
L9 import numpy as np
L10 import pandas as pd
L11 import yfinance as yf
L12 from typing import Iterable, Optional
L13
L14
L15 # --- [MOD] bucket更新ヘルパー（対象拡張 & 優先順位つき） ---
L16 def _update_bucket_by_selection(
L17     csv_path: str,
L18     top_G: Iterable[str],
L19     top_D: Iterable[str],
L20     extra_G: Optional[Iterable[str]] = None,
L21     extra_D: Optional[Iterable[str]] = None,
L22 ) -> None:
L23     """
L24     current_tickers.csv の bucket 列を、選定結果に基づき部分上書きする。
L25     - 対象は (top_G/top_D) に加えて (resG['tickers']/resD['tickers']/init_G/init_D 等) も反映
L26     - 優先順位: top_G > top_D > extra_G > extra_D > 現状維持
L27     - 常にヘッダー無しで (ticker,qty,bucket) の3列で保存
L28     """
L29     df = pd.read_csv(csv_path, header=None, names=["ticker", "qty", "bucket"])
L30     df["ticker"] = df["ticker"].astype(str).str.strip().str.upper()
L31     df["qty"] = pd.to_numeric(df["qty"], errors="coerce").fillna(0).astype(int)
L32     df["bucket"] = df["bucket"].fillna("").astype(str).str.strip().str.upper()
L33
L34     g_top = set(t.upper() for t in (top_G or []))
L35     d_top = set(t.upper() for t in (top_D or []))
L36     g_ext = set(t.upper() for t in (extra_G or []))
L37     d_ext = set(t.upper() for t in (extra_D or []))
L38
L39     def _assign(row):
L40         t = row["ticker"]
L41         # 優先順位: top_G > top_D > extra_G > extra_D > 現状維持
L42         if t in g_top:
L43             return "G"
L44         if t in d_top:
L45             return "D"
L46         if t in g_ext:
L47             return "G"
L48         if t in d_ext:
L49             return "D"
L50         return row["bucket"]
L51
L52     df["bucket"] = df.apply(_assign, axis=1)
L53     df[["ticker", "qty", "bucket"]].to_csv(csv_path, index=False, header=False)
L54     logging.info("current_tickers.csv abspath: %s", os.path.abspath(csv_path))
L55     logging.info(
L56         "[I/O] current_tickers.csv bucket updated (topG=%d, topD=%d, extraG=%d, extraD=%d)",
L57         len(g_top), len(d_top), len(g_ext), len(d_ext)
L58     )
L59 from scipy.stats import zscore  # used via scorer
L60
L61 from scorer import Scorer, ttm_div_yield_portfolio, _log, _as_numeric_series
L62 import config
L63
L64 import warnings, atexit, threading
L65 from collections import Counter
L66
L67 # === 定数・設定・DTO（import直後に集約） ===
L68 BONUS_COEFF = 0.55  # 推奨: 攻め=0.45 / 中庸=0.55 / 守り=0.65
L69 SWAP_DELTA_Z = 0.15   # 僅差判定: σの15%。(緩め=0.10 / 標準=0.15 / 固め=0.20)
L70 SWAP_KEEP_BUFFER = 3  # n_target+この順位以内の現行は保持。(粘り弱=2 / 標準=3 / 粘り強=4〜5)
L71
L72 debug_mode, FINNHUB_API_KEY = True, os.environ.get("FINNHUB_API_KEY")
L73
L74 _CSV_LOAD_START = perf_counter()
L75 exist, cand = [pd.read_csv(f, header=None)[0].tolist() for f in ("current_tickers.csv","candidate_tickers.csv")]
L76 CAND_PRICE_MAX, bench = 450, '^GSPC'  # 価格上限・ベンチマーク
L77 N_G, N_D = config.N_G, config.N_D  # G/D枠サイズ（NORMAL基準: G12/D8）
L78 g_weights = {'GROWTH_F':0.30,'MOM':0.60,'VOL':-0.10}
L79 D_BETA_MODE = os.environ.get("D_BETA_MODE", "z").lower()   # "raw" or "z"
L80 D_BETA_CUTOFF = float(os.environ.get("D_BETA_CUTOFF", "-0.8"))
L81 FILTER_SPEC = {"G":{"pre_mask":["trend_template"]},"D":{"pre_filter":{"beta_max":D_BETA_CUTOFF}}}
L82 D_weights = {'QAL':0.15,'YLD':0.25,'VOL':-0.40,'TRD':0.20}
L83 _fmt_w = lambda w: " ".join(f"{k}{int(v*100)}" for k, v in w.items())
L84
L85 def _zscore_series(s: pd.Series) -> pd.Series:
L86     # NaNはそのまま、標準偏差0なら全NaNにする（暴走防止）
L87     v = s.astype(float)
L88     m, std = v.mean(skipna=True), v.std(skipna=True, ddof=0)
L89     if not np.isfinite(std) or std == 0:
L90         return pd.Series(index=v.index, dtype=float)
L91     return (v - m) / std
L92
L93 # DRRS 初期プール・各種パラメータ
L94 corrM = 45
L95 DRRS_G, DRRS_D = dict(lookback=252,n_pc=3,gamma=1.2,lam=0.68,eta=0.8), dict(lookback=504,n_pc=4,gamma=0.8,lam=0.85,eta=0.5)
L96 DRRS_SHRINK = 0.10  # 残差相関の対角シュリンク（基礎）
L97
L98 # クロス相関ペナルティ（未定義なら設定）
L99 try: CROSS_MU_GD
L100 except NameError: CROSS_MU_GD = 0.40  # 推奨 0.35–0.45（lam=0.85想定）
L101
L102 # 出力関連
L103 RESULTS_DIR = "results"
L104 os.makedirs(RESULTS_DIR, exist_ok=True)
L105
L106 def _write_leaders_csv(results_dir: str, top_g, n: int = config.N_G) -> None:
L107     import os, logging
L108
L109     os.makedirs(results_dir, exist_ok=True)
L110     arr = [str(t).strip().upper() for t in list(top_g)[:n] if t]
L111     path = os.path.join(results_dir, "leaders.csv")
L112     with open(path, "w", encoding="utf-8") as f:
L113         f.write("\n".join(arr) + ("\n" if arr else ""))
L114     logging.info("[I/O] results/leaders.csv updated (%d lines)", len(arr))
L115
L116 # === 共有DTO（クラス間I/O契約）＋ Config ===
L117 @dataclass(frozen=True)
L118 class InputBundle:
L119     # Input → Scorer で受け渡す素材（I/O禁止の生データ）
L120     cand: List[str]
L121     tickers: List[str]
L122     bench: str
L123     data: pd.DataFrame              # yfinance download結果（'Close','Volume'等の階層列）
L124     px: pd.DataFrame                # data['Close']
L125     spx: pd.Series                  # data['Close'][bench]
L126     tickers_bulk: object            # yfinance.Tickers
L127     info: Dict[str, dict]           # yfinance info per ticker
L128     eps_df: pd.DataFrame            # ['eps_ttm','eps_q_recent',...]
L129     fcf_df: pd.DataFrame            # ['fcf_ttm', ...]
L130     returns: pd.DataFrame           # px[tickers].pct_change()
L131     missing_logs: pd.DataFrame
L132
L133 @dataclass(frozen=True)
L134 class FeatureBundle:
L135     df: pd.DataFrame
L136     df_z: pd.DataFrame
L137     g_score: pd.Series
L138     d_score_all: pd.Series
L139     missing_logs: pd.DataFrame
L140     df_full: pd.DataFrame | None = None
L141     df_full_z: pd.DataFrame | None = None
L142     scaler: Any | None = None
L143
L144 @dataclass(frozen=True)
L145 class SelectionBundle:
L146     resG: dict
L147     resD: dict
L148     top_G: List[str]
L149     top_D: List[str]
L150     init_G: List[str]
L151     init_D: List[str]
L152
L153 @dataclass(frozen=True)
L154 class WeightsConfig:
L155     g: Dict[str,float]
L156     d: Dict[str,float]
L157
L158 @dataclass(frozen=True)
L159 class DRRSParams:
L160     corrM: int
L161     shrink: float
L162     G: Dict[str,float]   # lookback, n_pc, gamma, lam, eta
L163     D: Dict[str,float]
L164     cross_mu_gd: float
L165
L166 @dataclass(frozen=True)
L167 class PipelineConfig:
L168     weights: WeightsConfig
L169     drrs: DRRSParams
L170     price_max: float
L171     debug_mode: bool = False
L172
L173 # ---------- 重複警告の集約ロジック ----------
L174 _warn_lock = threading.Lock()
L175 _warn_seen = set()                     # 初回表示済みキー
L176 _warn_count = Counter()                # (category, message, module) → 件数
L177 _warn_first_ctx = {}                   # 初回の (filename, lineno)
L178
L179 def _warn_key(message, category, filename, lineno, *_args, **_kwargs):
L180     # "同じ警告" を定義: カテゴリ + 正規化メッセージ + モジュールパス(先頭数階層)
L181     mod = filename.split("/site-packages/")[-1] if "/site-packages/" in filename else filename
L182     mod = mod.rsplit("/", 3)[-1]  # 長すぎ抑制（末尾3階層まで）
L183     msg = str(message).strip()
L184     return (category.__name__, msg, mod)
L185
L186 _orig_showwarning = warnings.showwarning
L187
L188 def _compact_showwarning(message, category, filename, lineno, file=None, line=None):
L189     key = _warn_key(message, category, filename, lineno)
L190     with _warn_lock:
L191         _warn_count[key] += 1
L192         if key not in _warn_seen:
L193             # 初回だけ1行で出す（カテゴリ | モジュール | メッセージ）
L194             _warn_seen.add(key)
L195             _warn_first_ctx[key] = (filename, lineno)
L196             # 1行フォーマット（行数節約）
L197             txt = f"[WARN][{category.__name__}] {message} | {filename}:{lineno}"
L198             print(txt)
L199         # 2回目以降は出さない（集約）
L200
L201 warnings.showwarning = _compact_showwarning
L202
L203 # ベースポリシー: 通常は警告を出す（default）→ ただし同一メッセージは集約
L204 warnings.resetwarnings()
L205 warnings.simplefilter("default")
L206
L207 # 2) ピンポイント間引き: yfinance 'Ticker.earnings' は "once"（初回のみ可視化）
L208 warnings.filterwarnings(
L209     "once",
L210     message="'Ticker.earnings' is deprecated",
L211     category=DeprecationWarning,
L212     module="yfinance"
L213 )
L214
L215 # 3) 最終サマリ: 同一警告が何回出たかを最後に1行で
L216 @atexit.register
L217 def _print_warning_summary():
L218     suppressed = []
L219     for key, cnt in _warn_count.items():
L220         if cnt > 1:
L221             (cat, msg, mod) = key
L222             filename, lineno = _warn_first_ctx.get(key, ("", 0))
L223             suppressed.append((cnt, cat, msg, mod, filename, lineno))
L224     if suppressed:
L225         suppressed.sort(reverse=True)  # 件数降順
L226         # 最多上位だけ出す（必要なら上限制御：ここでは上位10件）
L227         top = suppressed[:10]
L228         print(f"[WARN-SUMMARY] duplicated warning groups: {len(suppressed)}")
L229         for cnt, cat, msg, mod, filename, lineno in top:
L230             print(f"[WARN-SUMMARY] {cnt-1} more | [{cat}] {msg} | {mod} ({filename}:{lineno})")
L231         if len(suppressed) > len(top):
L232             print(f"[WARN-SUMMARY] ... and {len(suppressed)-len(top)} more groups suppressed")
L233
L234 # 4) 追加（任意）: 1ジョブあたりの総警告上限を設定したい場合
L235 #    例: 上限1000を超えたら以降は完全サイレント
L236 _WARN_HARD_LIMIT = int(os.getenv("WARN_HARD_LIMIT", "0") or "0")  # 0なら無効
L237 if _WARN_HARD_LIMIT > 0:
L238     _orig_warn_func = warnings.warn
L239     def _limited_warn(*a, **k):
L240         total = sum(_warn_count.values())
L241         if total < _WARN_HARD_LIMIT:
L242             return _orig_warn_func(*a, **k)
L243         # 超過後は捨てる（最後にsummaryだけ残る）
L244     warnings.warn = _limited_warn
L245
L246 # ---------- ここまでで警告の“可視性は維持”しつつ“重複で行数爆発”を抑止 ----------
L247
L248 # その他
L249 logger = logging.getLogger(__name__)
L250 logging.basicConfig(level=(logging.INFO if debug_mode else logging.WARNING), force=True)
L251
L252 _T0 = [perf_counter()]
L253
L254
L255 def _tlog(tag: str) -> None:
L256     now = perf_counter()
L257     print(f"[T] {tag}: {now - _T0[0]:.2f}s")
L258     _T0[0] = now
L259
L260
L261 _tlog("start")
L262 try:
L263     _T0[0] = _CSV_LOAD_START
L264 except NameError:
L265     pass
L266 _tlog(f"csv loaded: exist={len(exist)} cand={len(cand)}")
L267
L268 # === Utilities ===
L269 # （ここには “本体ロジック直下で使う軽量ヘルパ” のみを残す）
L270
L271
L272 _env_true = lambda name, default=False: (os.getenv(name) or str(default)).strip().lower() == "true"
L273
L274 def _disjoint_keepG(top_G, top_D, poolD):
L275     """G重複をDから除去し、poolDで順次補充（枯渇時は元銘柄維持）。"""
L276     used, D, i = set(top_G), list(top_D), 0
L277     for j, t in enumerate(D):
L278         if t not in used:
L279            
```