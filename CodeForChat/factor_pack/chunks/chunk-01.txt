```text
# === Chat Paste Pack ===
# Repo: dakara32/GPT_Code @ main
# Files: config.py, factor.py, scorer.py, .github/workflows/weekly-report.yml, documents/README.md, documents/factor_design.md
# 作成日時: 2025-09-26 14:46:12 (JST)
# 使い方: 下のチャンクを順に貼ればこのチャットで全体把握できます。
# 注記: 各ファイルは個別に L1.. で行番号付与。
---

## <config.py>
```text
L1 # 共通設定（factor / drift から参照）
L2 TOTAL_TARGETS = 20
L3
L4 # 基準のバケット数（NORMAL）
L5 COUNTS_BASE = {"G": 12, "D": 8}
L6
L7 # モード別の推奨バケット数
L8 COUNTS_BY_MODE = {
L9     "NORMAL": {"G": 12, "D": 8},
L10     "CAUTION": {"G": 10, "D": 8},
L11     "EMERG": {"G": 8,  "D": 8},
L12 }
L13
L14 # モード別のドリフト閾値（%）
L15 DRIFT_THRESHOLD_BY_MODE = {"NORMAL": 12, "CAUTION": 14, "EMERG": float("inf")}
L16
L17 # モード別のTS（基本幅, 小数=割合）
L18 TS_BASE_BY_MODE = {"NORMAL": 0.15, "CAUTION": 0.13, "EMERG": 0.10}
L19 # 利益到達(+30/+60/+100%)時の段階タイト化（ポイント差）
L20 TS_STEP_DELTAS_PT = (3, 6, 8)
L21
L22 # Breadthの校正は N_G に連動（緊急解除=ceil(1.5*N_G), 通常復帰=3*N_G）
L23 N_G = COUNTS_BASE["G"]
L24 N_D = COUNTS_BASE["D"]
L25
```

## <factor.py>
```text
L1 '''ROLE: Orchestration ONLY（外部I/O・SSOT・Slack出力）, 計算は scorer.py'''
L2 # === NOTE: 機能・入出力・ログ文言・例外挙動は不変。安全な短縮（import統合/複数代入/内包表記/メソッドチェーン/一行化/空行圧縮など）のみ適用 ===
L3 import logging, os, time, requests
L4 from concurrent.futures import ThreadPoolExecutor
L5 from dataclasses import dataclass
L6 from time import perf_counter
L7 from typing import Any, Dict, List, Tuple
L8
L9 import numpy as np
L10 import pandas as pd
L11 import yfinance as yf
L12
L13
L14 # --- [ADD] bucket更新ヘルパー（ヘッダー無し3列: ticker,qty,bucket を前提） ---
L15 def _update_bucket_by_selection(csv_path: str, top_G: list[str], top_D: list[str]) -> None:
L16     """
L17     current_tickers.csv の bucket 列を、選定結果に基づき部分上書きする。
L18     - 該当ティッカーのみ "G"/"D" に更新、未登場は既存値（空欄含む）を維持
L19     - 常にヘッダー無しで (ticker,qty,bucket) の3列で保存
L20     """
L21     df = pd.read_csv(csv_path, header=None, names=["ticker", "qty", "bucket"])
L22     df["ticker"] = df["ticker"].astype(str).str.strip().str.upper()
L23     df["qty"] = pd.to_numeric(df["qty"], errors="coerce").fillna(0).astype(int)
L24     df["bucket"] = df["bucket"].fillna("").astype(str).str.strip().str.upper()
L25
L26     gset = set([t.upper() for t in (top_G or [])])
L27     dset = set([t.upper() for t in (top_D or [])])
L28
L29     def _assign(row):
L30         t = row["ticker"]
L31         if t in gset:
L32             return "G"
L33         if t in dset:
L34             return "D"
L35         return row["bucket"]
L36
L37     df["bucket"] = df.apply(_assign, axis=1)
L38     df[["ticker", "qty", "bucket"]].to_csv(csv_path, index=False, header=False)
L39     logging.info("current_tickers.csv abspath: %s", os.path.abspath(csv_path))
L40     logging.info("[I/O] current_tickers.csv bucket updated (G=%d, D=%d)", len(gset), len(dset))
L41 from scipy.stats import zscore  # used via scorer
L42
L43 from scorer import Scorer, ttm_div_yield_portfolio, _log, _as_numeric_series
L44 import config
L45
L46 import warnings, atexit, threading
L47 from collections import Counter
L48
L49 # === 定数・設定・DTO（import直後に集約） ===
L50 BONUS_COEFF = 0.55  # 推奨: 攻め=0.45 / 中庸=0.55 / 守り=0.65
L51 SWAP_DELTA_Z = 0.15   # 僅差判定: σの15%。(緩め=0.10 / 標準=0.15 / 固め=0.20)
L52 SWAP_KEEP_BUFFER = 3  # n_target+この順位以内の現行は保持。(粘り弱=2 / 標準=3 / 粘り強=4〜5)
L53
L54 debug_mode, FINNHUB_API_KEY = True, os.environ.get("FINNHUB_API_KEY")
L55
L56 _CSV_LOAD_START = perf_counter()
L57 exist, cand = [pd.read_csv(f, header=None)[0].tolist() for f in ("current_tickers.csv","candidate_tickers.csv")]
L58 CAND_PRICE_MAX, bench = 450, '^GSPC'  # 価格上限・ベンチマーク
L59 N_G, N_D = config.N_G, config.N_D  # G/D枠サイズ（NORMAL基準: G12/D8）
L60 g_weights = {'GROWTH_F':0.30,'MOM':0.60,'VOL':-0.10}
L61 D_BETA_MODE = os.environ.get("D_BETA_MODE", "z").lower()   # "raw" or "z"
L62 D_BETA_CUTOFF = float(os.environ.get("D_BETA_CUTOFF", "-0.8"))
L63 FILTER_SPEC = {"G":{"pre_mask":["trend_template"]},"D":{"pre_filter":{"beta_max":D_BETA_CUTOFF}}}
L64 D_weights = {'QAL':0.15,'YLD':0.25,'VOL':-0.40,'TRD':0.20}
L65 _fmt_w = lambda w: " ".join(f"{k}{int(v*100)}" for k, v in w.items())
L66
L67 def _zscore_series(s: pd.Series) -> pd.Series:
L68     # NaNはそのまま、標準偏差0なら全NaNにする（暴走防止）
L69     v = s.astype(float)
L70     m, std = v.mean(skipna=True), v.std(skipna=True, ddof=0)
L71     if not np.isfinite(std) or std == 0:
L72         return pd.Series(index=v.index, dtype=float)
L73     return (v - m) / std
L74
L75 # DRRS 初期プール・各種パラメータ
L76 corrM = 45
L77 DRRS_G, DRRS_D = dict(lookback=252,n_pc=3,gamma=1.2,lam=0.68,eta=0.8), dict(lookback=504,n_pc=4,gamma=0.8,lam=0.85,eta=0.5)
L78 DRRS_SHRINK = 0.10  # 残差相関の対角シュリンク（基礎）
L79
L80 # クロス相関ペナルティ（未定義なら設定）
L81 try: CROSS_MU_GD
L82 except NameError: CROSS_MU_GD = 0.40  # 推奨 0.35–0.45（lam=0.85想定）
L83
L84 # 出力関連
L85 RESULTS_DIR = "results"
L86 os.makedirs(RESULTS_DIR, exist_ok=True)
L87
L88 # === 共有DTO（クラス間I/O契約）＋ Config ===
L89 @dataclass(frozen=True)
L90 class InputBundle:
L91     # Input → Scorer で受け渡す素材（I/O禁止の生データ）
L92     cand: List[str]
L93     tickers: List[str]
L94     bench: str
L95     data: pd.DataFrame              # yfinance download結果（'Close','Volume'等の階層列）
L96     px: pd.DataFrame                # data['Close']
L97     spx: pd.Series                  # data['Close'][bench]
L98     tickers_bulk: object            # yfinance.Tickers
L99     info: Dict[str, dict]           # yfinance info per ticker
L100     eps_df: pd.DataFrame            # ['eps_ttm','eps_q_recent',...]
L101     fcf_df: pd.DataFrame            # ['fcf_ttm', ...]
L102     returns: pd.DataFrame           # px[tickers].pct_change()
L103     missing_logs: pd.DataFrame
L104
L105 @dataclass(frozen=True)
L106 class FeatureBundle:
L107     df: pd.DataFrame
L108     df_z: pd.DataFrame
L109     g_score: pd.Series
L110     d_score_all: pd.Series
L111     missing_logs: pd.DataFrame
L112     df_full: pd.DataFrame | None = None
L113     df_full_z: pd.DataFrame | None = None
L114     scaler: Any | None = None
L115
L116 @dataclass(frozen=True)
L117 class SelectionBundle:
L118     resG: dict
L119     resD: dict
L120     top_G: List[str]
L121     top_D: List[str]
L122     init_G: List[str]
L123     init_D: List[str]
L124
L125 @dataclass(frozen=True)
L126 class WeightsConfig:
L127     g: Dict[str,float]
L128     d: Dict[str,float]
L129
L130 @dataclass(frozen=True)
L131 class DRRSParams:
L132     corrM: int
L133     shrink: float
L134     G: Dict[str,float]   # lookback, n_pc, gamma, lam, eta
L135     D: Dict[str,float]
L136     cross_mu_gd: float
L137
L138 @dataclass(frozen=True)
L139 class PipelineConfig:
L140     weights: WeightsConfig
L141     drrs: DRRSParams
L142     price_max: float
L143     debug_mode: bool = False
L144
L145 # ---------- 重複警告の集約ロジック ----------
L146 _warn_lock = threading.Lock()
L147 _warn_seen = set()                     # 初回表示済みキー
L148 _warn_count = Counter()                # (category, message, module) → 件数
L149 _warn_first_ctx = {}                   # 初回の (filename, lineno)
L150
L151 def _warn_key(message, category, filename, lineno, *_args, **_kwargs):
L152     # "同じ警告" を定義: カテゴリ + 正規化メッセージ + モジュールパス(先頭数階層)
L153     mod = filename.split("/site-packages/")[-1] if "/site-packages/" in filename else filename
L154     mod = mod.rsplit("/", 3)[-1]  # 長すぎ抑制（末尾3階層まで）
L155     msg = str(message).strip()
L156     return (category.__name__, msg, mod)
L157
L158 _orig_showwarning = warnings.showwarning
L159
L160 def _compact_showwarning(message, category, filename, lineno, file=None, line=None):
L161     key = _warn_key(message, category, filename, lineno)
L162     with _warn_lock:
L163         _warn_count[key] += 1
L164         if key not in _warn_seen:
L165             # 初回だけ1行で出す（カテゴリ | モジュール | メッセージ）
L166             _warn_seen.add(key)
L167             _warn_first_ctx[key] = (filename, lineno)
L168             # 1行フォーマット（行数節約）
L169             txt = f"[WARN][{category.__name__}] {message} | {filename}:{lineno}"
L170             print(txt)
L171         # 2回目以降は出さない（集約）
L172
L173 warnings.showwarning = _compact_showwarning
L174
L175 # ベースポリシー: 通常は警告を出す（default）→ ただし同一メッセージは集約
L176 warnings.resetwarnings()
L177 warnings.simplefilter("default")
L178
L179 # 2) ピンポイント間引き: yfinance 'Ticker.earnings' は "once"（初回のみ可視化）
L180 warnings.filterwarnings(
L181     "once",
L182     message="'Ticker.earnings' is deprecated",
L183     category=DeprecationWarning,
L184     module="yfinance"
L185 )
L186
L187 # 3) 最終サマリ: 同一警告が何回出たかを最後に1行で
L188 @atexit.register
L189 def _print_warning_summary():
L190     suppressed = []
L191     for key, cnt in _warn_count.items():
L192         if cnt > 1:
L193             (cat, msg, mod) = key
L194             filename, lineno = _warn_first_ctx.get(key, ("", 0))
L195             suppressed.append((cnt, cat, msg, mod, filename, lineno))
L196     if suppressed:
L197         suppressed.sort(reverse=True)  # 件数降順
L198         # 最多上位だけ出す（必要なら上限制御：ここでは上位10件）
L199         top = suppressed[:10]
L200         print(f"[WARN-SUMMARY] duplicated warning groups: {len(suppressed)}")
L201         for cnt, cat, msg, mod, filename, lineno in top:
L202             print(f"[WARN-SUMMARY] {cnt-1} more | [{cat}] {msg} | {mod} ({filename}:{lineno})")
L203         if len(suppressed) > len(top):
L204             print(f"[WARN-SUMMARY] ... and {len(suppressed)-len(top)} more groups suppressed")
L205
L206 # 4) 追加（任意）: 1ジョブあたりの総警告上限を設定したい場合
L207 #    例: 上限1000を超えたら以降は完全サイレント
L208 _WARN_HARD_LIMIT = int(os.getenv("WARN_HARD_LIMIT", "0") or "0")  # 0なら無効
L209 if _WARN_HARD_LIMIT > 0:
L210     _orig_warn_func = warnings.warn
L211     def _limited_warn(*a, **k):
L212         total = sum(_warn_count.values())
L213         if total < _WARN_HARD_LIMIT:
L214             return _orig_warn_func(*a, **k)
L215         # 超過後は捨てる（最後にsummaryだけ残る）
L216     warnings.warn = _limited_warn
L217
L218 # ---------- ここまでで警告の“可視性は維持”しつつ“重複で行数爆発”を抑止 ----------
L219
L220 # その他
L221 logger = logging.getLogger(__name__)
L222 logging.basicConfig(level=(logging.INFO if debug_mode else logging.WARNING), force=True)
L223
L224 _T0 = [perf_counter()]
L225
L226
L227 def _tlog(tag: str) -> None:
L228     now = perf_counter()
L229     print(f"[T] {tag}: {now - _T0[0]:.2f}s")
L230     _T0[0] = now
L231
L232
L233 _tlog("start")
L234 try:
L235     _T0[0] = _CSV_LOAD_START
L236 except NameError:
L237     pass
L238 _tlog(f"csv loaded: exist={len(exist)} cand={len(cand)}")
L239
L240 # === Utilities ===
L241 # （ここには “本体ロジック直下で使う軽量ヘルパ” のみを残す）
L242
L243
L244 _env_true = lambda name, default=False: (os.getenv(name) or str(default)).strip().lower() == "true"
L245
L246 def _disjoint_keepG(top_G, top_D, poolD):
L247     """G重複をDから除去し、poolDで順次補充（枯渇時は元銘柄維持）。"""
L248     used, D, i = set(top_G), list(top_D), 0
L249     for j, t in enumerate(D):
L250         if t not in used:
L251             continue
L252         while i < len(poolD) and (poolD[i] in used or poolD[i] in D):
L253             i += 1
L254         if i < len(poolD):
L255             D[j] = poolD[i]; used.add(D[j]); i += 1
L256     return top_G, D
L257
L258
L259 def _sticky_keep_current(agg: pd.Series, pick: list[str], incumbents: list[str],
L260                          n_target: int, delta_z: float, keep_buffer: int) -> list[str]:
L261     import pandas as pd, numpy as np
L262     sel = list(pick)
L263     if not sel: return sel
L264     ranked_sel = agg.reindex(sel).sort_values(ascending=False)
L265     kth = ranked_sel.iloc[min(len(sel), n_target)-1]
L266     std = agg.std()
L267     sigma = float(std) if pd.notna(std) else 0.0
L268     thresh = kth - delta_z * sigma
L269     ranked_all = agg.sort_values(ascending=False)
L270     cand = [t for t in incumbents if (t not in sel) and (t in agg.index)]
L271     for t in cand:
L272         within_score = pd.notna(agg[t]) and agg[t] >= thresh
L273         within_rank = t in ranked_all.index and ranked_all.index.get_loc(t) < n_target + keep_buffer
L274         if not (within_score or within_rank):
L275             continue
L276         non_inc = [x for x in sel if x not in incumbents]
L277         if not non_inc:
L278             break
L279
```