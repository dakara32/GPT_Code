```text
# === Chat Paste Pack ===
# Repo: dakara32/GPT_Code @ main
# Files: config.py, factor.py, scorer.py, .github/workflows/weekly-report.yml, documents/README.md, documents/factor_design.md
# 作成日時: 2025-09-26 14:26:02 (JST)
# 使い方: 下のチャンクを順に貼ればこのチャットで全体把握できます。
# 注記: 各ファイルは個別に L1.. で行番号付与。
---

## <config.py>
```text
L1 # 共通設定（factor / drift から参照）
L2 TOTAL_TARGETS = 20
L3
L4 # 基準のバケット数（NORMAL）
L5 COUNTS_BASE = {"G": 12, "D": 8}
L6
L7 # モード別の推奨バケット数
L8 COUNTS_BY_MODE = {
L9     "NORMAL": {"G": 12, "D": 8},
L10     "CAUTION": {"G": 10, "D": 8},
L11     "EMERG": {"G": 8,  "D": 8},
L12 }
L13
L14 # モード別のドリフト閾値（%）
L15 DRIFT_THRESHOLD_BY_MODE = {"NORMAL": 12, "CAUTION": 14, "EMERG": float("inf")}
L16
L17 # モード別のTS（基本幅, 小数=割合）
L18 TS_BASE_BY_MODE = {"NORMAL": 0.15, "CAUTION": 0.13, "EMERG": 0.10}
L19 # 利益到達(+30/+60/+100%)時の段階タイト化（ポイント差）
L20 TS_STEP_DELTAS_PT = (3, 6, 8)
L21
L22 # Breadthの校正は N_G に連動（緊急解除=ceil(1.5*N_G), 通常復帰=3*N_G）
L23 N_G = COUNTS_BASE["G"]
L24 N_D = COUNTS_BASE["D"]
L25
```

## <factor.py>
```text
L1 '''ROLE: Orchestration ONLY（外部I/O・SSOT・Slack出力）, 計算は scorer.py'''
L2 # === NOTE: 機能・入出力・ログ文言・例外挙動は不変。安全な短縮（import統合/複数代入/内包表記/メソッドチェーン/一行化/空行圧縮など）のみ適用 ===
L3 import logging, os, time, requests
L4 from concurrent.futures import ThreadPoolExecutor
L5 from dataclasses import dataclass
L6 from time import perf_counter
L7 from typing import Any, Dict, List, Tuple
L8
L9 import numpy as np
L10 import pandas as pd
L11 import yfinance as yf
L12
L13
L14 # --- [ADD] bucket更新ヘルパー（ヘッダー無し3列: ticker,qty,bucket を前提） ---
L15 def _update_bucket_by_selection(csv_path: str, top_G: list[str], top_D: list[str]) -> None:
L16     """
L17     current_tickers.csv の bucket 列を、選定結果に基づき部分上書きする。
L18     - 該当ティッカーのみ "G"/"D" に更新、未登場は既存値（空欄含む）を維持
L19     - 常にヘッダー無しで (ticker,qty,bucket) の3列で保存
L20     """
L21     df = pd.read_csv(csv_path, header=None, names=["ticker", "qty", "bucket"])
L22     df["ticker"] = df["ticker"].astype(str).str.strip().str.upper()
L23     df["qty"] = pd.to_numeric(df["qty"], errors="coerce").fillna(0).astype(int)
L24     df["bucket"] = df["bucket"].fillna("").astype(str).str.strip().str.upper()
L25
L26     gset = set([t.upper() for t in (top_G or [])])
L27     dset = set([t.upper() for t in (top_D or [])])
L28
L29     def _assign(row):
L30         t = row["ticker"]
L31         if t in gset:
L32             return "G"
L33         if t in dset:
L34             return "D"
L35         return row["bucket"]
L36
L37     df["bucket"] = df.apply(_assign, axis=1)
L38     df[["ticker", "qty", "bucket"]].to_csv(csv_path, index=False, header=False)
L39     logging.info("[I/O] current_tickers.csv bucket updated (G=%d, D=%d)", len(gset), len(dset))
L40 from scipy.stats import zscore  # used via scorer
L41
L42 from scorer import Scorer, ttm_div_yield_portfolio, _log, _as_numeric_series
L43 import config
L44
L45 import warnings, atexit, threading
L46 from collections import Counter
L47
L48 # === 定数・設定・DTO（import直後に集約） ===
L49 BONUS_COEFF = 0.55  # 推奨: 攻め=0.45 / 中庸=0.55 / 守り=0.65
L50 SWAP_DELTA_Z = 0.15   # 僅差判定: σの15%。(緩め=0.10 / 標準=0.15 / 固め=0.20)
L51 SWAP_KEEP_BUFFER = 3  # n_target+この順位以内の現行は保持。(粘り弱=2 / 標準=3 / 粘り強=4〜5)
L52
L53 debug_mode, FINNHUB_API_KEY = True, os.environ.get("FINNHUB_API_KEY")
L54
L55 _CSV_LOAD_START = perf_counter()
L56 exist, cand = [pd.read_csv(f, header=None)[0].tolist() for f in ("current_tickers.csv","candidate_tickers.csv")]
L57 CAND_PRICE_MAX, bench = 450, '^GSPC'  # 価格上限・ベンチマーク
L58 N_G, N_D = config.N_G, config.N_D  # G/D枠サイズ（NORMAL基準: G12/D8）
L59 g_weights = {'GROWTH_F':0.30,'MOM':0.60,'VOL':-0.10}
L60 D_BETA_MODE = os.environ.get("D_BETA_MODE", "z").lower()   # "raw" or "z"
L61 D_BETA_CUTOFF = float(os.environ.get("D_BETA_CUTOFF", "-0.8"))
L62 FILTER_SPEC = {"G":{"pre_mask":["trend_template"]},"D":{"pre_filter":{"beta_max":D_BETA_CUTOFF}}}
L63 D_weights = {'QAL':0.15,'YLD':0.25,'VOL':-0.40,'TRD':0.20}
L64 _fmt_w = lambda w: " ".join(f"{k}{int(v*100)}" for k, v in w.items())
L65
L66 def _zscore_series(s: pd.Series) -> pd.Series:
L67     # NaNはそのまま、標準偏差0なら全NaNにする（暴走防止）
L68     v = s.astype(float)
L69     m, std = v.mean(skipna=True), v.std(skipna=True, ddof=0)
L70     if not np.isfinite(std) or std == 0:
L71         return pd.Series(index=v.index, dtype=float)
L72     return (v - m) / std
L73
L74 # DRRS 初期プール・各種パラメータ
L75 corrM = 45
L76 DRRS_G, DRRS_D = dict(lookback=252,n_pc=3,gamma=1.2,lam=0.68,eta=0.8), dict(lookback=504,n_pc=4,gamma=0.8,lam=0.85,eta=0.5)
L77 DRRS_SHRINK = 0.10  # 残差相関の対角シュリンク（基礎）
L78
L79 # クロス相関ペナルティ（未定義なら設定）
L80 try: CROSS_MU_GD
L81 except NameError: CROSS_MU_GD = 0.40  # 推奨 0.35–0.45（lam=0.85想定）
L82
L83 # 出力関連
L84 RESULTS_DIR = "results"
L85 os.makedirs(RESULTS_DIR, exist_ok=True)
L86
L87 # === 共有DTO（クラス間I/O契約）＋ Config ===
L88 @dataclass(frozen=True)
L89 class InputBundle:
L90     # Input → Scorer で受け渡す素材（I/O禁止の生データ）
L91     cand: List[str]
L92     tickers: List[str]
L93     bench: str
L94     data: pd.DataFrame              # yfinance download結果（'Close','Volume'等の階層列）
L95     px: pd.DataFrame                # data['Close']
L96     spx: pd.Series                  # data['Close'][bench]
L97     tickers_bulk: object            # yfinance.Tickers
L98     info: Dict[str, dict]           # yfinance info per ticker
L99     eps_df: pd.DataFrame            # ['eps_ttm','eps_q_recent',...]
L100     fcf_df: pd.DataFrame            # ['fcf_ttm', ...]
L101     returns: pd.DataFrame           # px[tickers].pct_change()
L102     missing_logs: pd.DataFrame
L103
L104 @dataclass(frozen=True)
L105 class FeatureBundle:
L106     df: pd.DataFrame
L107     df_z: pd.DataFrame
L108     g_score: pd.Series
L109     d_score_all: pd.Series
L110     missing_logs: pd.DataFrame
L111     df_full: pd.DataFrame | None = None
L112     df_full_z: pd.DataFrame | None = None
L113     scaler: Any | None = None
L114
L115 @dataclass(frozen=True)
L116 class SelectionBundle:
L117     resG: dict
L118     resD: dict
L119     top_G: List[str]
L120     top_D: List[str]
L121     init_G: List[str]
L122     init_D: List[str]
L123
L124 @dataclass(frozen=True)
L125 class WeightsConfig:
L126     g: Dict[str,float]
L127     d: Dict[str,float]
L128
L129 @dataclass(frozen=True)
L130 class DRRSParams:
L131     corrM: int
L132     shrink: float
L133     G: Dict[str,float]   # lookback, n_pc, gamma, lam, eta
L134     D: Dict[str,float]
L135     cross_mu_gd: float
L136
L137 @dataclass(frozen=True)
L138 class PipelineConfig:
L139     weights: WeightsConfig
L140     drrs: DRRSParams
L141     price_max: float
L142     debug_mode: bool = False
L143
L144 # ---------- 重複警告の集約ロジック ----------
L145 _warn_lock = threading.Lock()
L146 _warn_seen = set()                     # 初回表示済みキー
L147 _warn_count = Counter()                # (category, message, module) → 件数
L148 _warn_first_ctx = {}                   # 初回の (filename, lineno)
L149
L150 def _warn_key(message, category, filename, lineno, *_args, **_kwargs):
L151     # "同じ警告" を定義: カテゴリ + 正規化メッセージ + モジュールパス(先頭数階層)
L152     mod = filename.split("/site-packages/")[-1] if "/site-packages/" in filename else filename
L153     mod = mod.rsplit("/", 3)[-1]  # 長すぎ抑制（末尾3階層まで）
L154     msg = str(message).strip()
L155     return (category.__name__, msg, mod)
L156
L157 _orig_showwarning = warnings.showwarning
L158
L159 def _compact_showwarning(message, category, filename, lineno, file=None, line=None):
L160     key = _warn_key(message, category, filename, lineno)
L161     with _warn_lock:
L162         _warn_count[key] += 1
L163         if key not in _warn_seen:
L164             # 初回だけ1行で出す（カテゴリ | モジュール | メッセージ）
L165             _warn_seen.add(key)
L166             _warn_first_ctx[key] = (filename, lineno)
L167             # 1行フォーマット（行数節約）
L168             txt = f"[WARN][{category.__name__}] {message} | {filename}:{lineno}"
L169             print(txt)
L170         # 2回目以降は出さない（集約）
L171
L172 warnings.showwarning = _compact_showwarning
L173
L174 # ベースポリシー: 通常は警告を出す（default）→ ただし同一メッセージは集約
L175 warnings.resetwarnings()
L176 warnings.simplefilter("default")
L177
L178 # 2) ピンポイント間引き: yfinance 'Ticker.earnings' は "once"（初回のみ可視化）
L179 warnings.filterwarnings(
L180     "once",
L181     message="'Ticker.earnings' is deprecated",
L182     category=DeprecationWarning,
L183     module="yfinance"
L184 )
L185
L186 # 3) 最終サマリ: 同一警告が何回出たかを最後に1行で
L187 @atexit.register
L188 def _print_warning_summary():
L189     suppressed = []
L190     for key, cnt in _warn_count.items():
L191         if cnt > 1:
L192             (cat, msg, mod) = key
L193             filename, lineno = _warn_first_ctx.get(key, ("", 0))
L194             suppressed.append((cnt, cat, msg, mod, filename, lineno))
L195     if suppressed:
L196         suppressed.sort(reverse=True)  # 件数降順
L197         # 最多上位だけ出す（必要なら上限制御：ここでは上位10件）
L198         top = suppressed[:10]
L199         print(f"[WARN-SUMMARY] duplicated warning groups: {len(suppressed)}")
L200         for cnt, cat, msg, mod, filename, lineno in top:
L201             print(f"[WARN-SUMMARY] {cnt-1} more | [{cat}] {msg} | {mod} ({filename}:{lineno})")
L202         if len(suppressed) > len(top):
L203             print(f"[WARN-SUMMARY] ... and {len(suppressed)-len(top)} more groups suppressed")
L204
L205 # 4) 追加（任意）: 1ジョブあたりの総警告上限を設定したい場合
L206 #    例: 上限1000を超えたら以降は完全サイレント
L207 _WARN_HARD_LIMIT = int(os.getenv("WARN_HARD_LIMIT", "0") or "0")  # 0なら無効
L208 if _WARN_HARD_LIMIT > 0:
L209     _orig_warn_func = warnings.warn
L210     def _limited_warn(*a, **k):
L211         total = sum(_warn_count.values())
L212         if total < _WARN_HARD_LIMIT:
L213             return _orig_warn_func(*a, **k)
L214         # 超過後は捨てる（最後にsummaryだけ残る）
L215     warnings.warn = _limited_warn
L216
L217 # ---------- ここまでで警告の“可視性は維持”しつつ“重複で行数爆発”を抑止 ----------
L218
L219 # その他
L220 logger = logging.getLogger(__name__)
L221 logging.basicConfig(level=(logging.INFO if debug_mode else logging.WARNING), force=True)
L222
L223 _T0 = [perf_counter()]
L224
L225
L226 def _tlog(tag: str) -> None:
L227     now = perf_counter()
L228     print(f"[T] {tag}: {now - _T0[0]:.2f}s")
L229     _T0[0] = now
L230
L231
L232 _tlog("start")
L233 try:
L234     _T0[0] = _CSV_LOAD_START
L235 except NameError:
L236     pass
L237 _tlog(f"csv loaded: exist={len(exist)} cand={len(cand)}")
L238
L239 # === Utilities ===
L240 # （ここには “本体ロジック直下で使う軽量ヘルパ” のみを残す）
L241
L242
L243 _env_true = lambda name, default=False: (os.getenv(name) or str(default)).strip().lower() == "true"
L244
L245 def _disjoint_keepG(top_G, top_D, poolD):
L246     """G重複をDから除去し、poolDで順次補充（枯渇時は元銘柄維持）。"""
L247     used, D, i = set(top_G), list(top_D), 0
L248     for j, t in enumerate(D):
L249         if t not in used:
L250             continue
L251         while i < len(poolD) and (poolD[i] in used or poolD[i] in D):
L252             i += 1
L253         if i < len(poolD):
L254             D[j] = poolD[i]; used.add(D[j]); i += 1
L255     return top_G, D
L256
L257
L258 def _sticky_keep_current(agg: pd.Series, pick: list[str], incumbents: list[str],
L259                          n_target: int, delta_z: float, keep_buffer: int) -> list[str]:
L260     import pandas as pd, numpy as np
L261     sel = list(pick)
L262     if not sel: return sel
L263     ranked_sel = agg.reindex(sel).sort_values(ascending=False)
L264     kth = ranked_sel.iloc[min(len(sel), n_target)-1]
L265     std = agg.std()
L266     sigma = float(std) if pd.notna(std) else 0.0
L267     thresh = kth - delta_z * sigma
L268     ranked_all = agg.sort_values(ascending=False)
L269     cand = [t for t in incumbents if (t not in sel) and (t in agg.index)]
L270     for t in cand:
L271         within_score = pd.notna(agg[t]) and agg[t] >= thresh
L272         within_rank = t in ranked_all.index and ranked_all.index.get_loc(t) < n_target + keep_buffer
L273         if not (within_score or within_rank):
L274             continue
L275         non_inc = [x for x in sel if x not in incumbents]
L276         if not non_inc:
L277             break
L278         weakest = min(non_inc, key=lambda x: agg.get(x, -np.inf))
L279         if w
```