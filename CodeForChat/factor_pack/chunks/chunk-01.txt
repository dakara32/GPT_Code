```text
# === Chat Paste Pack ===
# Repo: dakara32/GPT_Code @ main
# Files: config.py, factor.py, scorer.py, .github/workflows/weekly-report.yml, documents/README.md, documents/factor_design.md
# 作成日時: 2025-09-19 20:58:24 (JST)
# 使い方: 下のチャンクを順に貼ればこのチャットで全体把握できます。
# 注記: 各ファイルは個別に L1.. で行番号付与。
---

## <config.py>
```text
L1 # 共通設定（factor / drift から参照）
L2 TOTAL_TARGETS = 20
L3
L4 # 基準のバケット数（NORMAL）
L5 COUNTS_BASE = {"G": 12, "D": 8}
L6
L7 # モード別の推奨バケット数
L8 COUNTS_BY_MODE = {
L9     "NORMAL": {"G": 12, "D": 8},
L10     "CAUTION": {"G": 10, "D": 8},
L11     "EMERG": {"G": 8,  "D": 8},
L12 }
L13
L14 # モード別のドリフト閾値（%）
L15 DRIFT_THRESHOLD_BY_MODE = {"NORMAL": 12, "CAUTION": 14, "EMERG": float("inf")}
L16
L17 # モード別のTS（基本幅, 小数=割合）
L18 TS_BASE_BY_MODE = {"NORMAL": 0.15, "CAUTION": 0.13, "EMERG": 0.10}
L19 # 利益到達(+30/+60/+100%)時の段階タイト化（ポイント差）
L20 TS_STEP_DELTAS_PT = (3, 6, 8)
L21
L22 # Breadthの校正は N_G に連動（緊急解除=ceil(1.5*N_G), 通常復帰=3*N_G）
L23 N_G = COUNTS_BASE["G"]
L24 N_D = COUNTS_BASE["D"]
L25
```

## <factor.py>
```text
L1 '''ROLE: Orchestration ONLY（外部I/O・SSOT・Slack出力）, 計算は scorer.py'''
L2 # === NOTE: 機能・入出力・ログ文言・例外挙動は不変。安全な短縮（import統合/複数代入/内包表記/メソッドチェーン/一行化/空行圧縮など）のみ適用 ===
L3 BONUS_COEFF = 0.55  # 推奨: 攻め=0.45 / 中庸=0.55 / 守り=0.65
L4 SWAP_DELTA_Z = 0.15   # 僅差判定: σの15%。(緩め=0.10 / 標準=0.15 / 固め=0.20)
L5 SWAP_KEEP_BUFFER = 3  # n_target+この順位以内の現行は保持。(粘り弱=2 / 標準=3 / 粘り強=4〜5)
L6 import logging, os, time, requests
L7 from concurrent.futures import ThreadPoolExecutor
L8 from dataclasses import dataclass
L9 from time import perf_counter
L10 from typing import Any, Dict, List, Tuple
L11
L12 import numpy as np
L13 import pandas as pd
L14 import yfinance as yf
L15 from scipy.stats import zscore  # used via scorer
L16
L17 from scorer import Scorer, ttm_div_yield_portfolio, _log
L18 import config
L19
L20 # その他
L21 debug_mode, FINNHUB_API_KEY = True, os.environ.get("FINNHUB_API_KEY")
L22
L23 logger = logging.getLogger(__name__)
L24 logging.basicConfig(level=(logging.INFO if debug_mode else logging.WARNING), force=True)
L25
L26 class T:
L27     t = perf_counter()
L28
L29     @staticmethod
L30     def log(tag):
L31         now = perf_counter()
L32         print(f"[T] {tag}: {now - T.t:.2f}s")
L33         T.t = now
L34
L35 T.log("start")
L36
L37 # === ユニバースと定数（冒頭に固定） ===
L38 exist, cand = [pd.read_csv(f, header=None)[0].tolist() for f in ("current_tickers.csv","candidate_tickers.csv")]
L39 T.log(f"csv loaded: exist={len(exist)} cand={len(cand)}")
L40 CAND_PRICE_MAX, bench = 450, '^GSPC'  # 価格上限・ベンチマーク
L41 N_G, N_D = config.N_G, config.N_D  # G/D枠サイズ（NORMAL基準: G12/D8）
L42 g_weights = {'GROWTH_F':0.35,'MOM':0.55,'VOL':-0.10}
L43 D_BETA_MAX = float(os.environ.get("D_BETA_MAX", "0.8"))
L44 FILTER_SPEC = {"G":{"pre_mask":["trend_template"]},"D":{"pre_filter":{"beta_max":D_BETA_MAX}}}
L45 D_weights = {'QAL':0.1,'YLD':0.3,'VOL':-0.5,'TRD':0.1}
L46 _fmt_w = lambda w: " ".join(f"{k}{int(v*100)}" for k, v in w.items())
L47
L48 # DRRS 初期プール・各種パラメータ
L49 corrM = 45
L50 DRRS_G, DRRS_D = dict(lookback=252,n_pc=3,gamma=1.2,lam=0.68,eta=0.8), dict(lookback=504,n_pc=4,gamma=0.8,lam=0.85,eta=0.5)
L51 DRRS_SHRINK = 0.10  # 残差相関の対角シュリンク（基礎）
L52
L53 # クロス相関ペナルティ（未定義なら設定）
L54 try: CROSS_MU_GD
L55 except NameError: CROSS_MU_GD = 0.40  # 推奨 0.35–0.45（lam=0.85想定）
L56
L57 # 出力関連
L58 RESULTS_DIR = "results"
L59 os.makedirs(RESULTS_DIR, exist_ok=True)
L60
L61 # === 共有DTO（クラス間I/O契約）＋ Config ===
L62 @dataclass(frozen=True)
L63 class InputBundle:
L64     # Input → Scorer で受け渡す素材（I/O禁止の生データ）
L65     cand: List[str]
L66     tickers: List[str]
L67     bench: str
L68     data: pd.DataFrame              # yfinance download結果（'Close','Volume'等の階層列）
L69     px: pd.DataFrame                # data['Close']
L70     spx: pd.Series                  # data['Close'][bench]
L71     tickers_bulk: object            # yfinance.Tickers
L72     info: Dict[str, dict]           # yfinance info per ticker
L73     eps_df: pd.DataFrame            # ['eps_ttm','eps_q_recent',...]
L74     fcf_df: pd.DataFrame            # ['fcf_ttm', ...]
L75     returns: pd.DataFrame           # px[tickers].pct_change()
L76
L77 @dataclass(frozen=True)
L78 class FeatureBundle:
L79     df: pd.DataFrame
L80     df_z: pd.DataFrame
L81     g_score: pd.Series
L82     d_score_all: pd.Series
L83     missing_logs: pd.DataFrame
L84     df_full: pd.DataFrame | None = None
L85     df_full_z: pd.DataFrame | None = None
L86     scaler: Any | None = None
L87
L88 @dataclass(frozen=True)
L89 class SelectionBundle:
L90     resG: dict
L91     resD: dict
L92     top_G: List[str]
L93     top_D: List[str]
L94     init_G: List[str]
L95     init_D: List[str]
L96
L97 @dataclass(frozen=True)
L98 class WeightsConfig:
L99     g: Dict[str,float]
L100     d: Dict[str,float]
L101
L102 @dataclass(frozen=True)
L103 class DRRSParams:
L104     corrM: int
L105     shrink: float
L106     G: Dict[str,float]   # lookback, n_pc, gamma, lam, eta
L107     D: Dict[str,float]
L108     cross_mu_gd: float
L109
L110 @dataclass(frozen=True)
L111 class PipelineConfig:
L112     weights: WeightsConfig
L113     drrs: DRRSParams
L114     price_max: float
L115     debug_mode: bool = False
L116
L117 # === 共通ユーティリティ（複数クラスで使用） ===
L118 # (unused local utils removed – use scorer.py versions if needed)
L119
L120 _env_true = lambda name, default=False: (os.getenv(name) or str(default)).strip().lower() == "true"
L121
L122 def _post_slack(payload: dict):
L123     url = os.getenv("SLACK_WEBHOOK_URL")
L124     if not url: print("⚠️ SLACK_WEBHOOK_URL 未設定"); return
L125     try:
L126         requests.post(url, json=payload).raise_for_status()
L127     except Exception as e:
L128         print(f"⚠️ Slack通知エラー: {e}")
L129
L130 def _slack_send_text_chunks(url: str, text: str, chunk: int = 2800) -> None:
L131     """Slackへテキストを分割送信（コードブロック形式）。"""
L132
L133     def _post_text(payload: str) -> None:
L134         try:
L135             resp = requests.post(url, json={"text": payload})
L136             print(f"[DBG] debug_post status={getattr(resp,'status_code',None)} size={len(payload)}")
L137             if resp is not None:
L138                 resp.raise_for_status()
L139         except Exception as e:
L140             print(f"[ERR] debug_post_failed: {e}")
L141
L142     body = (text or "").strip()
L143     if not body:
L144         print("[DBG] skip debug send: empty body")
L145         return
L146
L147     block, block_len = [], 0
L148
L149     def _flush():
L150         nonlocal block, block_len
L151         if block:
L152             _post_text("```" + "\n".join(block) + "```")
L153             block, block_len = [], 0
L154
L155     for raw in body.splitlines():
L156         line = raw or ""
L157         while len(line) > chunk:
L158             head, line = line[:chunk], line[chunk:]
L159             _flush()
L160             _post_text("```" + head + "```")
L161         add_len = len(line) if not block else len(line) + 1
L162         if block and block_len + add_len > chunk:
L163             _flush(); add_len = len(line)
L164         block.append(line)
L165         block_len += add_len
L166     _flush()
L167
L168 def _disjoint_keepG(top_G, top_D, poolD):
L169     """G重複をDから除去し、poolDで順次補充（枯渇時は元銘柄維持）。"""
L170     used, D, i = set(top_G), list(top_D), 0
L171     for j, t in enumerate(D):
L172         if t not in used:
L173             continue
L174         while i < len(poolD) and (poolD[i] in used or poolD[i] in D):
L175             i += 1
L176         if i < len(poolD):
L177             D[j] = poolD[i]; used.add(D[j]); i += 1
L178     return top_G, D
L179
L180
L181 def _sticky_keep_current(agg: pd.Series, pick: list[str], incumbents: list[str],
L182                          n_target: int, delta_z: float, keep_buffer: int) -> list[str]:
L183     import pandas as pd, numpy as np
L184     sel = list(pick)
L185     if not sel: return sel
L186     ranked_sel = agg.reindex(sel).sort_values(ascending=False)
L187     kth = ranked_sel.iloc[min(len(sel), n_target)-1]
L188     std = agg.std()
L189     sigma = float(std) if pd.notna(std) else 0.0
L190     thresh = kth - delta_z * sigma
L191     ranked_all = agg.sort_values(ascending=False)
L192     cand = [t for t in incumbents if (t not in sel) and (t in agg.index)]
L193     for t in cand:
L194         within_score = pd.notna(agg[t]) and agg[t] >= thresh
L195         within_rank = t in ranked_all.index and ranked_all.index.get_loc(t) < n_target + keep_buffer
L196         if not (within_score or within_rank):
L197             continue
L198         non_inc = [x for x in sel if x not in incumbents]
L199         if not non_inc:
L200             break
L201         weakest = min(non_inc, key=lambda x: agg.get(x, -np.inf))
L202         if weakest in sel and agg.get(t, -np.inf) >= agg.get(weakest, -np.inf):
L203             sel.remove(weakest); sel.append(t)
L204     if len(sel) > n_target:
L205         sel = sorted(sel, key=lambda x: agg.get(x, -1e9), reverse=True)[:n_target]
L206     return sel
L207
L208
L209 # === Input：外部I/Oと前処理（CSV/API・欠損補完） ===
L210 class Input:
L211     def __init__(self, cand, exist, bench, price_max, finnhub_api_key=None):
L212         self.cand, self.exist, self.bench, self.price_max = cand, exist, bench, price_max
L213         self.api_key = finnhub_api_key or os.environ.get("FINNHUB_API_KEY")
L214
L215     # ---- （Input専用）EPS補完・FCF算出系 ----
L216     @staticmethod
L217     def _sec_headers():
L218         mail = (os.getenv("SEC_CONTACT_EMAIL") or "yasonba55@gmail.com").strip()
L219         app = (os.getenv("SEC_APP_NAME") or "FactorBot/1.0").strip()
L220         return {"User-Agent": f"{app} ({mail})", "From": mail, "Accept": "application/json"}
L221
L222     @staticmethod
L223     def _sec_get(url: str, retries: int = 3, backoff: float = 0.5):
L224         for i in range(retries):
L225             r = requests.get(url, headers=Input._sec_headers(), timeout=20)
L226             if r.status_code in (429, 503, 403):
L227                 time.sleep(min(2 ** i * backoff, 8.0))
L228                 continue
L229             r.raise_for_status(); return r.json()
L230         r.raise_for_status()
L231
L232     @staticmethod
L233     def _sec_ticker_map():
L234         j = Input._sec_get("https://data.sec.gov/api/xbrl/company_tickers.json")
L235         mp = {}
L236         for _, v in (j or {}).items():
L237             try:
L238                 mp[str(v["ticker"]).upper()] = f"{int(v['cik_str']):010d}"
L239             except Exception:
L240                 continue
L241         return mp
L242
L243     # --- 追加: ADR/OTC向けの簡易正規化（末尾Y/F, ドット等） ---
L244     @staticmethod
L245     def _normalize_ticker(sym: str) -> list[str]:
L246         s = (sym or "").upper().strip()
L247         # 追加: 先頭の$や全角の記号を除去
L248         s = s.lstrip("$").replace("＄", "").replace("．", ".").replace("－", "-")
L249         cand: list[str] = []
L250
L251         def add(x: str) -> None:
L252             if x and x not in cand:
L253                 cand.append(x)
L254
L255         # 1) 原文を最優先（SECは BRK.B, BF.B など . を正式採用）
L256         add(s)
L257         # 2) Yahoo系バリアント（. と - の揺れを相互に）
L258         if "." in s:
L259             add(s.replace(".", "-"))
L260             add(s.replace(".", ""))
L261         if "-" in s:
L262             add(s.replace("-", "."))
L263             add(s.replace("-", ""))
L264         # 3) ドット・ハイフン・ピリオド無し版（最後の保険）
L265         add(s.replace("-", "").replace(".", ""))
L266         # 4) ADR簡易：末尾Y/Fの除去（SECマップは本体ティッカーを持つことがある）
L267         if len(s) >= 2 and s[-1] in {"Y", "F"}:
L268             add(s[:-1])
L269         return cand
L270
L271     @staticmethod
L272     def _sec_companyfacts(cik: str):
L273         return Input._sec_get(f"https://data.sec.gov/api/xbrl/companyfacts/CIK{cik}.json")
L274
L275     @staticmethod
L276     def _units_for_tags(facts: dict, namespaces: list[str], tags: list[str]) -> list[dict]:
L277         """facts から namespace/tag を横断して units 配列を収集（存在順に連結）。"""
L278         out: list[dict] = []
L279         facts = (facts or {}).get("facts", {})
L280         for ns in namespaces
```